<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<bodyText confidence="0.144428">
Topology in Distributed
Computing
</bodyText>
<sectionHeader confidence="0.82927" genericHeader="abstract">
DIPLOMARBEIT
</sectionHeader>
<bodyText confidence="0.305797909090909">
zur Erlangung des akademischen Grades
Diplom-Ingenieur
im Rahmen des Studiums
Technische Informatik
ausgeführt von
Thomas Nowak
Matrikelnummer 0425201
an der
Fakultät für Informatik der Technischen Universität Wien
Betreuer: Univ.Prof. Dr. Ulrich Schmid
Wien, 18.03.2010
</bodyText>
<note confidence="0.458285666666667">
(Unterschrift Verfasser) (Unterschrift Betreuer)
Technische Universität Wien
A-1040 Wien ■ Karlsplatz 13 ■ Tel. +43/(0)1/58801-0 http://www.tuwien.ac.at
</note>
<bodyText confidence="0.6180005">
Erklärung
Thomas Nowak
Rechte Wienzeile 73/23
1050 Wien
Hiermit erkläre ich, dass ich diese Arbeit selbstständig verfasst habe, dass ich
die verwendeten Quellen und Hilfsmittel vollständig angegeben habe und dass
ich die Stellen der Arbeit – einschließlich Tabellen, Karten und Abbildungen –,
die anderen Werken oder dem Internet im Wortlaut oder dem Sinn nach
entnommen sind, auf jeden Fall unter Angabe der Quelle als Entlehnung
kenntlich gemacht habe.
Wien, 18.03.2010
(Unterschrift)
</bodyText>
<sectionHeader confidence="0.982973" genericHeader="keywords">
Abstract
</sectionHeader>
<bodyText confidence="0.999833">
Topology is the general mathematical theory of convergence. Distributed com-
puting is the formal investigation of communicating concurrent processes. We
explore applications of topology to distributed computing in two directions: (1)
Point-set topology and (2) algebraic topology.
We use the former to study the topological structure of infinite execution
trees. This enables us to unify a number of impossibility proofs, in particular,
the impossibility of distributed consensus — the task of all processes in a system
agreeing on a single value — in various (close to) asynchronous systems with
crash failures.
The latter is used to look into the combinatorial structure of configurations,
i.e., the collection of current process states in the system. Configurations are
regarded as simplices in a simplicial complex, and topological incompatibility
of such complexes is utilized to prove the impossibility of a generalization of
distributed consensus in certain systems. The particular problem considered is
k-set agreement, which is the task of letting all processes agree to values within
a set of at most k elements.
</bodyText>
<sectionHeader confidence="0.499841" genericHeader="introduction">
Kurzfassung
</sectionHeader>
<bodyText confidence="0.999956368421053">
Topologie ist die mathematisch adäquate Art, um über Konvergenz zu sprechen.
Distributed Computing ist das formale Studium von verteilten Systemen. Die
Arbeit beschäftigt sich mit zwei Anwendungen der Topologie im Bereich des
Distributed Computing: (1) Mengentheoretische Topologie und (2) algebraische
Topologie.
Erstere wird verwendet, um die topologische Struktur von unendlichen
Bäumen, die die Information über mögliche Ausführungen der Algorithmen sub-
sumieren, zu untersuchen. Dieses Wissen wird verwendet, um einen einheitlichen
Beweis der Unmöglichkeit von Distributed Consensus in mehreren Systemmo-
dellen zu geben. Consensus ist das Einigen aller Prozesse des Systems auf einen
einzigen Wert.
Zweitere wird verwendet, um die kombinatorische Struktur von Konfiguratio-
nen, also der Zusammenfassung aller lokaler Zustände der Prozesse, zu untersu-
chen. Hierbei wird eine Konfiguration als Simplex in einem Simplizialkomplex
aufgefasst. Die topologische Unvereinbarkeit solcher Komplexe ermöglicht einen
Beweis der Unmöglichkeit von k-Set Agreement in gewissen Systemen. Das ist
eine Verallgemeinerung des Consensus-Problems: Es wird nicht mehr verlangt,
dass sich die Prozesse auf nur einen Wert einigen, sondern es wird erlaubt, dass
bis zu k unterschiedliche Werte auftreten.
</bodyText>
<figure confidence="0.9498833">
Contents
1. Introduction 1
1.1. Distributed Computing 1
1.2. Topology 2
1.3. Structure of the Thesis 2
1.4. A Word on Notation 2
2. Distributed Computing Models 4
2.1. Introduction 4
2.2. Asynchronous Message Passing ä la FLP 5
2.2.1. A Formal Description 5
2.3. Omission Failure Model 6
2.3.1. A Formal Description 7
2.4. Asynchronous Shared Memory 8
2.4.1. A Formal Description 8
2.4.2. Atomic Snapshots 9
2.5. Safety and Liveness 9
3. Problem Specifications 11
3.1. Consensus 11
3.2. k-Set Agreement 12
4. Point-Set Topology 13
</figure>
<footnote confidence="0.86848075">
4.1. The Topology of Execution Spaces 13
4.1.1. Motivation 16
4.1.2. Execution Trees 19
4.1.3. Path–Sequence Duality 21
4.2. Topological Impossibility 22
4.2.1. Additional Structure — Configuration Similarity 23
4.3. Impossibility Results 25
4.3.1. Asynchronous Message Passing 25
4.3.2. Asynchronous Shared Memory 26
4.3.3. Transient Message Loss 27
5. Algebraic Topology 28
5.1. Introduction 28
5.2. Homology 29
5.2.1. Chain Complexes 29
5.2.2. The Homology Functor 29
5.3. Simplicial Complexes 30
</footnote>
<page confidence="0.577571">
v
</page>
<figure confidence="0.62568456">
5.3.1. Simplicial Homology 30
5.4. Algebraic vs. Combinatorial Topology 32
5.4.1. Singular Homology 32
5.4.2. Geometric Realization of Simplicial Complexes 33
5.4.3. Equivalence 34
5.5. Configuration Complexes 34
5.5.1. Input Complexes 34
5.5.2. Output Complexes 35
5.5.3. Protocol Complexes 36
5.6. Impossibility of k-Set Agreement 36
5.6.1. Full Information Protocols 37
5.6.2. Properties of Full Information Protocols 37
5.6.3. This Implies Impossibility 38
6. Summary 39
A. Topological Prerequisites 40
A.1. Motivation and Examples 40
A.1.1. Distances 40
A.1.2. Compactness in Rn 46
A.2. Topologies 48
A.2.1. Open Sets and Neighborhoods 48
A.2.2. Closure, Interior, Boundary, Density 52
A.2.3. Continuity 57
A.2.4. Compactness 59
A.2.5. Product Spaces 60
Bibliography 61
</figure>
<page confidence="0.589998">
vi
</page>
<sectionHeader confidence="0.995761" genericHeader="method">
1. Introduction
</sectionHeader>
<bodyText confidence="0.99815125">
This thesis deals with applications of topology to distributed computing. These
are twofold: Firstly, we use point-set topology to provide a unifying topological
framework for consensus impossibility proofs. Secondly, we present the impossibility
proof of k-set agreement by Herlihy and Shavit (1993) which uses algebraic topology.
</bodyText>
<subsectionHeader confidence="0.955296">
1.1. Distributed Computing
</subsectionHeader>
<bodyText confidence="0.997730166666667">
Consider a system of N processes that communicate by means of passing messages.
All processes take steps simultaneously at times t = 0, 1, 2,... and in zero time. All
message delays are equal to 1/2, i.e., processes at time t+1 have received all messages
sent in computing steps at time t. Processes are modeled as state machines and run
a local algorithm which governs state transitions and message sendings. Interesting
questions to ask might include:
</bodyText>
<listItem confidence="0.999426666666667">
(1) How many steps does it take until the last process has terminated?
(2) How many messages are sent in the execution of the algorithm?
(3) Is the algorithm correct, i.e., does it indeed fulfill its task specification?
</listItem>
<subsectionHeader confidence="0.596544">
The investigation of such questions is the realm of distributed computing.
</subsectionHeader>
<bodyText confidence="0.998693615384615">
We can spice things up a bit by varying model parameters. For example, we may
allow more general message delays than fixing them all at exactly 1/2. Likewise, we
might choose not to fix the times at which processes take steps to exactly 0, 1, 2, .. .
Of course, also the restriction that all processes take steps simultaneously might seem
overly limiting.
We may also introduce the possibility of lost messages: In the completely syn-
chronous model with message delays equal to 1/2, suppose that in every time frame
[t, t + 1), up to N − 1 message may be lost. That is, these messages do not get deliv-
ered although all other messages are delivered timely. A surprising result (Santoro
and Widmayer 1989) is that even in such a system with relatively few faults (there
exist up to N2 − N point-to-point links; at most N − 1 are lossy each round) it is
impossible for any deterministic algorithm to solve consensus. Consensus is the task
of all processes in the system agreeing on a single value.
</bodyText>
<page confidence="0.894375">
1
</page>
<note confidence="0.342984">
1 Introduction 1.2 Topology
</note>
<subsectionHeader confidence="0.564268">
1.2. Topology
</subsectionHeader>
<bodyText confidence="0.846514">
Topology is the general mathematical theory of convergence. Its most popular special
case is the study of metric spaces. It tackles questions like:
</bodyText>
<listItem confidence="0.9895598">
(1) Does the image of a continuous function f : [0, 1] → 1R, have a maximum?
(2) Does every Cauchy sequence converge?
(3) How many holes does a given manifold have?
(4) Can you cut two pizzas in half with a single cut, no matter how ugly they are
shaped?
</listItem>
<bodyText confidence="0.9016866">
The immediate investigation of topological spaces is called point-set topology, which
questions (1) and (2) can be attributed to. Another common technique is to as-
sign algebraic structures to topological spaces, reason about relations between these
structures and map these insights back into the world of topological spaces. This
method is called algebraic topology.
</bodyText>
<subsectionHeader confidence="0.986193">
1.3. Structure of the Thesis
</subsectionHeader>
<bodyText confidence="0.9990913">
Chapter 2 introduces distributed computing as a discipline and presents formal sys-
tem models. In Chapter 3, we talk about an important problem specification in
distributed computing: k-set agreement and its important special case, consensus.
Chapter 4 investigates execution spaces of distributed algorithms by means of point-
set topology and provides a unified proof of the impossibility of consensus in some
important system models. Chapter 5 deals with methods from algebraic topology. It
explains the approach taken by Herlihy and Shavit (1993) to prove the impossibility
of k-set agreement in the presence of up to k crash failures. A summary of the thesis
is given in Chapter 6. Appendix A gives a self-contained introduction to point-set
topology.
</bodyText>
<subsectionHeader confidence="0.98469">
1.4. A Word on Notation
</subsectionHeader>
<bodyText confidence="0.998325142857143">
The purpose of this section is to introduce some conventions of the mathematical
notation used in the thesis.
We denote the set of real numbers by 1R, and the set of non-negative real numbers by
1R,+. Real intervals are written with round and square parentheses, e.g., [0, 1) = {x E
1R,  |0 &lt; x &lt; 1}. For a set X C 1R,, inf X denotes the infimum of X and sup X denotes
its supremum. The letter Z denotes the set of integers. We set N = {k E Z  |k &gt; 1}
and ω = {k E Z  |k &gt; 0}.
</bodyText>
<page confidence="0.977232">
2
</page>
<note confidence="0.608711">
1 Introduction 1.4 A Word on Notation
</note>
<bodyText confidence="0.9779102">
For arbitrary sets A and B, we write BA = {f : A → B} to denote the set of all
functions with domain A and range B. For a mapping f : A → B and subsets A&apos; C A
and B&apos; C B, we define f[A&apos;] = {f(x)  |x E A&apos;} and f—1[B&apos;] = {x E A  |f(x) E B&apos;}.
The predicate A C B means bx(x E A =&gt; x E B) and we set P(A) = {A&apos; C A}. If
M is a set of sets, then UM denotes the set {x  |3A E M : x E A}.
</bodyText>
<equation confidence="0.952281666666667">
If (X, d) is a metric space, x E X and ε &gt; 0, then we write
Bε(x) = {y E X  |d(x, y) &lt; ε}. (1.1)
If X is a topological space and S C X, then S denotes the closure of S in X.
</equation>
<bodyText confidence="0.813422">
Additional notation will be defined when necessary.
</bodyText>
<page confidence="0.987619">
3
</page>
<sectionHeader confidence="0.993741" genericHeader="method">
2. Distributed Computing Models
</sectionHeader>
<bodyText confidence="0.99914525">
This chapter introduces the field of distributed computing to the extent needed to
present the results in subsequent chapters. We start by examining some questions
that are tackled and then introduce a number of mathematical models that are used
in distributed computing.
</bodyText>
<sectionHeader confidence="0.63522" genericHeader="method">
2.1. Introduction
</sectionHeader>
<bodyText confidence="0.998642777777778">
Distributed computing (Attiya and Welch 2004, Lynch 1996) is the investigation of
concurrent processes that communicate by means of some communication medium.
Commonly, processes are modeled as deterministic state machines taking steps (per-
forming state transitions) in zero time. Examples of communication media include
point-to-point RS232 links, a common data bus or a shared memory area allocated
by the Linux kernel. These types of communicating differ in a number of properties:
While changes to a shared memory are potentially visible immediately, messages
which were sent at time t may arrive at time t + δ with δ &gt; 0, i.e., the message sent
at time t is not immediately visible to the receiver. The transmission delay on a bus
might be equal for all processes, while transmission delays on point-to-point links
might be different for different links (processes).
In message-passing systems, a fundamental distinction is whether message delays
are bounded or not. Message delays are bounded if there is a constant Δ such that
every message sent at time t is guaranteed to have arrived at time t + Δ. Systems
that lack this property are called message asynchronous.
Other important properties of communicating distributed systems are process syn-
chrony properties. The most process synchronous system imaginable might be a sys-
tem in which all processes run at exactly the same speed, i.e., steps of processes are
triggered by perfectly synchronous hardware clocks. A most process asynchronous
system is one in which no information whatsoever is available on when processes
take a step (perform a state transition). Of course, systems with more synchrony
allow for harder problems to be solved than systems with weaker synchrony. It is,
for example, impossible to do any kind of real-time clock synchronization in com-
pletely asynchronous systems. A major problem, however, is to determine whether
one system is “more synchronous” than some other system (e.g., Dolev, Dwork, and
Stockmeyer 1987) and for many pairs of systems, none is more synchronous than the
other.
</bodyText>
<page confidence="0.987095">
4
</page>
<sectionHeader confidence="0.352902" genericHeader="method">
2 Distributed Computing Models 2.2 Asynchronous Message Passing ä la FLP
</sectionHeader>
<bodyText confidence="0.946366571428572">
Things get even more complicated when components may fail, in particular, in
asynchronous systems where no upper bound on message delays or inter-step times
of processes exist. The seminal work of Fischer, Lynch, and Paterson (1985) shows
that it is not possible in such systems for processes to even agree on a single value
(i.e., consensus is not possible).
The following sections introduce a number of popular models for distributed sys-
tems.
</bodyText>
<subsectionHeader confidence="0.978193">
2.2. Asynchronous Message Passing ä la FLP
</subsectionHeader>
<bodyText confidence="0.996908333333333">
Consider a system of N concurrent processes that communicate by means of point-to-
point links, i.e., every process can send messages to any other process. Asynchronous
message-passing deserves its name because
</bodyText>
<listItem confidence="0.847104">
(1) there is no upper bound on the transmission delay of messages and
(2) there is no upper bound on the inter-step time of processes, i.e., there is no Φ
</listItem>
<bodyText confidence="0.919269666666667">
such that a process that took a step at time t is guaranteed to have taken its
next step by time t + Φ.
The assumption coverage of this model, i.e., its ability to accurately describe real
systems, is quite broad since it does not limit the timing behavior in any way.
An algorithm in the asynchronous message-passing system model consists of a
state machine for each of the N processes. State changes occur when a process takes
a step and the transition function depends on the current internal state and received
messages. Apart from the internal state transition, a process may also send messages
to other processes. The structure of such a computing step is depicted in Figure 2.1.
</bodyText>
<figure confidence="0.788724">
receive msg
state transition
send msgs
</figure>
<figureCaption confidence="0.996929">
Figure 2.1.: Structure of a single computing step
</figureCaption>
<bodyText confidence="0.973096666666667">
Major problems arise when processes are allowed to crash, i.e., cease to take subse-
quent steps. The asynchronous nature of the system model prohibits distinguishing
processes which have crashed from processes whose messages are very slow.
</bodyText>
<subsectionHeader confidence="0.920272">
2.2.1. A Formal Description
</subsectionHeader>
<bodyText confidence="0.709801666666667">
In the asynchronous message-passing system model (Fischer, Lynch, and Paterson
1985), a system consists of N processes numbered 1, 2, ... , N which possess an inter-
nal state, a transition function δ and a sending function β. The transition function
</bodyText>
<page confidence="0.971764">
5
</page>
<sectionHeader confidence="0.372989" genericHeader="method">
2 Distributed Computing Models 2.3 Omission Failure Model
</sectionHeader>
<bodyText confidence="0.999112923076923">
δ maps pairs (s, m), consisting of the local state and a received message, to some
internal state. A message is a pair (p, m) where p is a process name and m is a mes-
sage content drawn from a pool of possible message contents M or the void value ⊥.
The sending function β maps pairs (s, m) as above to a finite set of (sent) messages.
Every process has a distinguished subset of its set of states — the set of initial states.
A configuration is a tuple (s1, s2, ... , sN) of internal states of the processes, together
with the set of in-transit messages — the message buffer.
An important point to understand is the relationship between the two notions of
event and step, which we will define now. An event in the classical asynchronous
message-passing model is a message. If in some configuration C, the message buffer
holds the message (event) e = (p, m), then we say that event e is applicable to
configuration C and we may apply e to C by the following means: We define the
successor configuration C� = e(C) by the following procedure.
</bodyText>
<listItem confidence="0.9966048">
(1) Remove e = (p, m) from the message buffer.
(2) Determine the internal successor state of process p by invoking the transition
function δ using message content m and p’s current state.
(3) Determine, and add to the message buffer, the messages (q, n) sent by process
p to processes q by invoking the sending function β.
</listItem>
<bodyText confidence="0.999355769230769">
The pair (C, C&apos;) where C� = e(C) for some event e is called a step. If we can apply
event e to configuration C, we say that e is applicable to C. An event has the ability
to trigger different steps, depending upon the configuration it is applied to.
An infinite sequence of events that are in turn applicable to C is called a sched-
ule starting from C. If (e1, e2,... ) is a schedule starting from configuration C,
we define the corresponding sequence of steps as follows: We set C0 = C and
Ck+1 = ek(Ck) for k &gt; 0; the corresponding sequence of steps is then defined to be
(C0, C1), (C1, C2), (C2, C3),... ). Such a corresponding sequence of steps is called a
run or an execution.
A process is called non-faulty or correct in some run or schedule if it takes steps
infinitely often. A process is called faulty if it is not non-faulty. A run or schedule is
called admissible (with respect to the model parameter f &gt; 0) if every message sent
to non-faulty processes is received and at most f processes are faulty.
</bodyText>
<subsectionHeader confidence="0.987386">
2.3. Omission Failure Model
</subsectionHeader>
<bodyText confidence="0.9982372">
In the synchronous message-passing model (Lynch 1996, Part I), all processes
p1, p2, . . . , pN take their steps at the same time, e.g., every process takes a step
at times t = 0, 1, 2, 3,... Furthermore, there does exist an upper bound on message
delays, namely every message sent at time t is delivered before time t + 1. That is,
processes execute in lock-step rounds: Every process is guaranteed to have received
</bodyText>
<page confidence="0.993541">
6
</page>
<sectionHeader confidence="0.297966" genericHeader="method">
2 Distributed Computing Models 2.3 Omission Failure Model
</sectionHeader>
<bodyText confidence="0.819876">
all messages that were sent to it before the current computing step. Figure 2.2 con-
tains a space-time diagram of a synchronous execution; the diagonal arrows indicate
messages.
</bodyText>
<equation confidence="0.94257">
t = 0 t = 1 t = 2 t = 3
p1
p2
p3
</equation>
<figureCaption confidence="0.983952">
Figure 2.2.: Synchronous message-passing
</figureCaption>
<bodyText confidence="0.980189">
In the synchronous omission failure model (Santoro and Widmayer 1989, Sec-
tion 4.1), in every round, i.e., in every time interval [t, t + 1), up to N − 1 messages
may be lost. These omissions create difficulties and yield a number of impossibility
results, because the adversary can completely silence a process by omitting all of its
outgoing messages.
</bodyText>
<subsectionHeader confidence="0.992412">
2.3.1. A Formal Description
</subsectionHeader>
<bodyText confidence="0.932705615384615">
In the synchronous omission failure system model, a system consists of N processes
numbered 1, 2, ... , N which possess an internal state, a transition function δ and a
sending function β. The transition function δ maps pairs (s, M), consisting of the
local state and a set of (received) messages, to some internal state. A message is a
pair (p, m) where p is a process and m is the message content taken from a set M
of possible message contents. The sending function β maps an internal state s to a
set M of messages such that every other process occurs in the first component of an
element in M. Every process has a distinguished subset of its set of states — the set
of initial states. A configuration is a tuple (s1, s2, ... , sN) of internal states of the
processes.1
An event in the model is a set O C f1, ... , N}2 \ f(1, 1), (2, 2), ... , (N, N)} with
|O |S N − 1, the set of omissions. We define the successor configuration C0 = O(C)
by the following procedure.
</bodyText>
<listItem confidence="0.8352155">
(1) Determine the sent messages of all processes by invoking the sending functions
β.
</listItem>
<footnote confidence="0.937865666666667">
1Contrary to the asynchronous message passing model, it is no longer necessary to remember the
state of the medium in a configuration. This is because every message is received in the same
step in which it was sent. See below for the exact step semantics.
</footnote>
<page confidence="0.993955">
7
</page>
<listItem confidence="0.9434705">
2 Distributed Computing Models 2.4 Asynchronous Shared Memory
(2) Ignore all messages over links in O.
(3) Determine the internal successor state of all processes by invoking the transition
functions δ using the newly received (non-ignored) messages.
</listItem>
<bodyText confidence="0.993337375">
The pair (C, C&apos;) where C� = O(C) for some event O is called a step.
An infinite sequence of events is called a schedule. If (O1, O2,... ) is a schedule
and C is a configuration, we define the corresponding sequence of steps as follows:
We set C0 = C and Ck+1 = Ok(Ck) for k &gt; 0; the corresponding sequence of steps is
then defined to be (C0, C1), (C1, C2), (C2, C3),... ). Such a corresponding sequence
of steps is called a run or an execution.
A process is called non-faulty or correct in some run or schedule if infinitely many
message sent by it get delivered. A process is called faulty if it is not non-faulty.
</bodyText>
<subsectionHeader confidence="0.999286">
2.4. Asynchronous Shared Memory
</subsectionHeader>
<bodyText confidence="0.999973846153846">
In this section, we consider a system of N processes communicating by means of M
shared read-write registers. These registers can hold an unbounded amount of infor-
mation and support two types of operations: read and write. Operation read(R)
returns the value of register R and operation write(R, v) writes value v to register
R. The fundamental limitation in this model is that processes can perform only
one of the operations read and write in a single computing step. Hence a process
performing a write does not know which value it overwrites.
As in asynchronous message-passing, there is no upper bound on inter-step times
of processes.2 Also, the possibility of processes crashing introduces difficulties.
A sometimes convenient simplification is to limit registers to be single-writer reg-
isters. That is, a shared register has a single process assigned to it which is the
only process that may write to the register. It is known (Attiya and Welch 2004,
Theorem 10.9) that this is not a serious restriction.
</bodyText>
<subsectionHeader confidence="0.995093">
2.4.1. A Formal Description
</subsectionHeader>
<bodyText confidence="0.9371791">
In the asynchronous shared memory system model (Attiya and Welch 2004, Sec-
tion 4.1), a system consists of (a) N processes numbered 1, 2, ... , N which possess
an internal state, a transition function δ and a shared memory operation function β
and (b) M shared read-write registers which possess a value. The shared memory
operation function β maps an internal state s to a shared memory operation, i.e.,
read(R) or write(R, v). The transition function δ maps pairs (s, v), consisting of
the local state and the return value of the shared memory operation β(s), to some
internal state. Every process has a distinguished subset of its set of states — the set
2However, there is no delay between performing a write and the time the written value becomes
visible to other processes. Thus, message delay δ = 0 in the language of message passing models.
</bodyText>
<page confidence="0.958948">
8
</page>
<sectionHeader confidence="0.505644" genericHeader="method">
2 Distributed Computing Models 2.5 Safety and Liveness
</sectionHeader>
<bodyText confidence="0.7012232">
of initial states. A configuration is a tuple (s1, s2, ... , sN) of internal states of the
processes, together with a tuple (v1, v2, ... , vM) of shared memory register values.
An event in the asynchronous shared memory model is a process number j ∈
{1, 2, ... , N}. We define the successor configuration C� = j(C) by the following
procedure.
</bodyText>
<listItem confidence="0.960420833333333">
(1) Determine the next shared memory operation by process pj by invoking the
shared memory operation function β.
(2) Perform the shared memory operation by process pj, i.e., change the register
value in case of a write operation.
(3) Determine the internal successor state of process pj by invoking the transition
function δ using the return value from (2).
</listItem>
<bodyText confidence="0.997175">
The pair (C, C&apos;) where C� = j(C) for some event j is called a step.
An infinite sequence of events that are in turn applicable to C is called a sched-
ule starting from C. If (j1, j2,... ) is a schedule starting from configuration C,
we define the corresponding sequence of steps as follows: We set C0 = C and
Ck+1 = jk(Ck) for k &gt; 0; the corresponding sequence of steps is then defined to be
(C0, C1), (C1, C2), (C2, C3),... ). Such a corresponding sequence of steps is called a
run or an execution.
A process is called non-faulty or correct in some infinite run or schedule if it takes
steps infinitely often. A process is called faulty if it is not non-faulty. A run or
schedule is called admissible (with respect to the model parameter f &gt; 0) if at most
f processes are faulty.
In case of single-writer registers, the set of allowed operations that may occur as
the image of functions β is restricted such that there do not exist two processes pi
and pj with operation functions βi and βj that can perform writes to a common
register R.
</bodyText>
<subsectionHeader confidence="0.992152">
2.4.2. Atomic Snapshots
</subsectionHeader>
<bodyText confidence="0.999719666666667">
A system with shared read-write registers supports atomic snapshots if there exists,
besides read and write, a third operation, namely scan() which returns all register
values at once, i.e., a tuple (v1, v2, ... , vM) of register values.
</bodyText>
<subsectionHeader confidence="0.998015">
2.5. Safety and Liveness
</subsectionHeader>
<bodyText confidence="0.99430025">
The notions of safety and liveness properties were introduced by Lamport (1977)
and have been well adopted in the distributed computing community. Lamport used
these notions to subdivide correctness proofs of programs into smaller and more
homogeneous pieces.
</bodyText>
<page confidence="0.926798">
9
</page>
<sectionHeader confidence="0.314602" genericHeader="method">
2 Distributed Computing Models 2.5 Safety and Liveness
</sectionHeader>
<bodyText confidence="0.969906111111111">
Intuitively, a safety property is the statement that “something will not happen”
(Lamport 1977). For instance, take the sentence “No message is ever sent.” The
“thing” that should not happen according to this statement is that a message is
sent. At any time in an execution, if already a message was sent, there is no way
that the execution fulfills the above safety property, no matter how the execution
continues. Hence if a “bad thing” happened in an execution prefix, any execution
that extends this prefix does not fulfill the safety property.
A liveness property is the statement that “something must happen” (Lamport
1977). An example would be the sentence “Every message that was sent is eventually
received.” The important point is that at any time in an execution, even if not all
sent messages were received yet, it is still possible that the execution fulfills the
above liveness property (because the message can be received later). Hence for any
finite execution prefix, there exists an execution extending this prefix that fulfills the
liveness property.
The immediate formalization of these two notions is contained in the following
definition.
Definition 2.1. Let SA be the set of admissible executions of some algorithm A. A
property of executions is a subset P ⊂ SA.
We call a property P a safety property if the following holds: For all E ∈ SA \ P
exists some n ∈ N such that every E&apos; ∈ SA that coincides with E in the first n
components holds E&apos; ∈6 P. We call a property P a liveness property if the following
holds: For all E ∈ SA and every n ∈ N there exists an E&apos; ∈ P that coincides with E
in the first n components. ❑
It should be noted that the intuitive meaning of these notions is sometimes in
conflict with Definition 2.1, in particular in the presence of failures. An investigation
of this problem and alternative definitions were given by Charron-Bost, Toueg, and
Basu (2000).
</bodyText>
<page confidence="0.996673">
10
</page>
<sectionHeader confidence="0.918799" genericHeader="method">
3. Problem Specifications
</sectionHeader>
<bodyText confidence="0.979471857142857">
In this chapter, we discuss two prominent problems in distributed computing: the
consensus problem and the k-set agreement problem which is a generalization of
consensus. By the term “problem” we mean a specification on the behavior of an
algorithm, which is said to “solve a problem” if all its executions satisfy the spec-
ification. The reason why we introduce exactly these two problems is firstly their
fundamentality and secondly that we will prove impossibility of their solution in
specific system models in later chapters.
</bodyText>
<subsectionHeader confidence="0.991892">
3.1. Consensus
</subsectionHeader>
<bodyText confidence="0.995805347826087">
Informally, consensus is the task of getting all processes in a distributed system to
agree on a single value. It is known (e.g., Fischer, Lynch, and Paterson 1985, Dolev,
Dwork, and Stockmeyer 1987, Fich and Ruppert 2003) that consensus, as easy as
the problem specification might seem, is in fact impossible to solve in a variety of
system models in the presence of faults.
Every process starts its execution with a prescribed input value and decides upon
termination on an output value. We will consider consensus only in system models
with model parameter f &gt; 1. Otherwise, consensus is trivially solvable. One simpli-
fication1 that we make is that the set of possible input and output values is equal to
{0, 1}. This special case of consensus is called binary consensus.
Formally, input and output values are modeled in the following way: First, we
impose the restriction that every process has to have at least two distinct initial
states. For every process pJ, let SJ denote its set of states and IJ ⊂ SJ its set
of initial states. We demand |IJ |&gt; 2. Input values are modeled by a mapping
ιJ : IJ → {0, 1} which we demand to be non-trivial. Output values are modeled by
a mapping δJ : SJ → {0, 1, ⊥}. We say that process pJ has decided on v ∈ {0, 1}
in state s ∈ SJ if δJ (s) = v. We demand that decisions are irrevocable, i.e., if s is
part of some configuration C, δJ(s) ∈ {0, 1}, and configuration C&apos; follows C in some
execution, then δJ (s&apos;) = δJ (s) where s&apos; is pJ’s state in C&apos;. Hence, we may extend δJ
to execution of the algorithm.
Of course, even with f crash failures, agreement on a value can be achieved trivially
by programming every process to decide on 0. Hence, we limit our attention to non-
trivial consensus. We say that an algorithm solves consensus if:
</bodyText>
<footnote confidence="0.9997475">
1In reality, this does not make the problem any simpler, just the notation. And since we are doing
impossibility results, it suffices to limit ourselves to this special case.
</footnote>
<page confidence="0.996446">
11
</page>
<listItem confidence="0.7796215">
3 Problem Specifications 3.2 k-Set Agreement
(T) For every admissible execution holds: Every process that is correct2 decides on
some value. (Termination)
(A) For every admissible execution holds: No two correct processes decide on dif-
fering values. (Agreement)
(V) For every admissible execution holds: If the execution starts from an initial
configuration in which all input values are equal to v, then all correct processes
decide on v. (Validity)
</listItem>
<subsectionHeader confidence="0.956471">
3.2. k-Set Agreement
</subsectionHeader>
<bodyText confidence="0.8631965">
Consensus is 1-set agreement. In k-set agreement with k ∈ N, we expand the set
of possible input (and output) values to {1, 2, ... , M} with M &gt; N and replace
condition (A) with
(k-A) For every admissible execution holds: No k + 1 correct processes decide to
pairwise differing values. (k-Agreement)
Definition 3.1. Let S be the set of admissible executions of a k-set agreement (or
consensus) algorithm and let C be a configuration in S. We say that C is α-valent
if all successor configurations of C if which a decision was reached have the decision
value α. In this case, we call C univalent, otherwise multivalent, or in the case M = 2
bivalent. ❑
</bodyText>
<footnote confidence="0.913088">
2See descriptions in 2.2.1, 2.3.1 and 2.4.1 for details when a process is considered correct.
</footnote>
<page confidence="0.993166">
12
</page>
<sectionHeader confidence="0.986303" genericHeader="method">
4. Point-Set Topology
</sectionHeader>
<bodyText confidence="0.997888333333333">
In this chapter, we treat techniques from elementary point-set topology (see Ap-
pendix A for an introduction to the subject) with respect to their applicability to
distributed computing. We show how to equip execution spaces with a natural topol-
ogy that can be used to derive impossibility results. In particular, we re-prove FLP
impossibility (Fischer, Lynch, and Paterson 1985) in this novel topological frame-
work.
</bodyText>
<subsectionHeader confidence="0.997605">
4.1. The Topology of Execution Spaces
</subsectionHeader>
<bodyText confidence="0.999594045454545">
This section introduces the necessary tools for formulating the main result of this
thesis in Section 4.2. We show how to equip a space of executions of some distributed
algorithm with a certain topology that helps us express executional properties in a
topological manner.
But before we talk about execution spaces, we have to fix the term “execution”
and explain what we mean by it.1 Common to all models of distributed computing
is the notion of a configuration, meaning a snapshot of the state of a system. That
is, a configuration encompasses information about the internal state of every process
and the state of the communication medium (e.g., messages in transit or contents
of shared memory). An execution is a sequence of configurations such that each
configuration in the sequence is a successor of the former ones. Notice that the
meaning of these two notions is heavily model-dependent. From the topological
viewpoint, we are not interested in the ontological question of what a configuration
really is; we only need to know which successor configurations are possible. Thus, we
“shift focus from the structure of protocols for a distributed system to the structure
of the set of possible schedules of a distributed system.” (Saks and Zaharoglou 2000)
We denote by CA the set of all configurations of algorithm A. Let SA denote
the set of admissible executions, which is a subset of the set CωA of sequences of
configurations.2 We will equip the latter space with a natural topology that induces
a topology on its subset SA.
When there is no danger of ambiguity, we will write C and S for CA and SA,
respectively.
</bodyText>
<footnote confidence="0.992205">
1The formal definition of these terms were given in Chapter 2.
2Executions, in models that we consider, are infinite per definitionem.
</footnote>
<page confidence="0.993739">
13
</page>
<bodyText confidence="0.737242666666667">
4 Point-Set Topology 4.1 The Topology of Execution Spaces
We endow C with the discrete topology, i.e., every subset of C is defined to be
open. This topology is induced by the metric
</bodyText>
<equation confidence="0.9947305">
(
0 if C = C0
dD : C × C → R+, dD(C, C0) = (4.1)
1 else.
</equation>
<bodyText confidence="0.8930583">
The natural topology to endow Cω = f ln∈ω C with is the product topology (see
Section A.2.5).
Lemma 4.1. The product topology on Cω is induced by the metric
j}
d(Ck), (C0 k)~ = 2− inf{j|Cj6=C0 (4.2)
Proof. We have to show that the sets that are open with respect to the product
topology (Definition A.14) are exactly those sets that are open with respect to the
metric (Example A.3).
Let A ⊂ Cω be open with respect to the metric d. The definition of openness with
respect to the metric asserts existence of ε(γ) &gt; 0 for every γ = (Ck) ∈ A such that
</bodyText>
<equation confidence="0.581874">
A =U Bε(γ)(γ). (4.3)
γ∈A
</equation>
<bodyText confidence="0.999750333333333">
From this equation we derive that it suffices to show that Bε(γ) is open with respect
to the product topology whenever ε &gt; 0. In this case, choose the integer K minimal
with the property 2−K S ε. This choice implies
</bodyText>
<equation confidence="0.7642585">
Bε(γ) = B2−K(γ) = {γ0  |γ and γ0 agree in the first K components}. (4.4)
If πm : Cω → C denotes the projection onto the mth component, then the inverse
image π−1 [{Cm}] of the open set {Cm} ⊂ C is exactly the set of elements in Cω
m
</equation>
<bodyText confidence="0.99190375">
whose mth component is equal to Cm. Also, by definition, these inverse images are
open with respect to the product topology. We thus conclude on the openness of
Bε(γ) with respect to the product topology, because the latter set in (4.4) is equal
to
</bodyText>
<equation confidence="0.584305">
[{Cm}]. (4.5)
</equation>
<bodyText confidence="0.997605">
To prove the converse direction, it suffices to show that all sets of the form π−1
</bodyText>
<equation confidence="0.8981881">
m [O]
where O is a subset3 of C are open with respect to the metric d. But we may write
π−1
m
nK
m=0
π−1 U B2−m (γ) (4.6)
m [O] = [O]
γ∈π−1
m
</equation>
<bodyText confidence="0.9826035">
because both sides are equal to the set of elements in Cω whose mth element is in O.
The openness of B2−m (γ) with respect to the metric d now concludes the proof. ■
</bodyText>
<footnote confidence="0.9864505">
3Note that all sets O ⊂ C are open, because we equipped C with the discrete topology (see Exam-
ple A.4(2)).
</footnote>
<page confidence="0.98713">
14
</page>
<subsubsectionHeader confidence="0.703932">
4 Point-Set Topology 4.1 The Topology of Execution Spaces
</subsubsectionHeader>
<bodyText confidence="0.991129">
Finally, we endow S ⊂ Cω with the subset topology (Example A.9), that is, the
topology induced by the same metric.
This topology on execution spaces was introduced by Alpern and Schneider (1985).
They characterized safety and liveness properties of executions in a topological way.
Namely, a property is a safety property if and only if the set of executions satisfying it
is closed (Definition A.8) with respect to the previously defined topology. Similarly, a
property is a liveness property if and only if the set of executions satisfying it is dense
(Definition A.11) with respect to this topology. They used this characterization to
prove that any property is an intersection of a safety and a liveness property. Also,
in non-pathological cases, every property is an intersection of two liveness properties.
We will now retrace these insights.
In the following, let C be the set of configurations of some algorithm.
</bodyText>
<construct confidence="0.703981666666667">
Lemma 4.2. A property P ⊂ Cω is a safety property if and only if P is closed in
Cω.
Proof. It is equivalent to prove that P is a safety property if and only if its comple-
ment Pc is open.
Let P be a safety property. Then, by definition, for every E ∈ Pc, there exists some
index k such that for every E&apos; ∈ Cω that agrees with E in the first k components,
we have E&apos; ∈ Pc. By setting ε = 2—k, we arrive at the insight that Bε(E) ⊂ Pc and
we are done.
Conversely, let Pc be an open set. Let E ∈ Pc. We have to show that there
exists some index k such that for any E&apos; ∈ Cω that coincides with E in the first k
components, we have E&apos; ∈ Pc. The set Pc being open, there exists some ε &gt; 0 such
that Bε(E) ⊂ Pc. Let k ∈ N such that 2—k &lt; ε. Then the set of all E&apos; that coincide
with E in the first k components is a subset of Bε(E), which concludes the proof. ■
Lemma 4.3. A property P ⊂ Cω is a liveness property if and only if P is dense in
Cω.
</construct>
<bodyText confidence="0.983924">
Proof. Let P be a liveness property and let E ∈ Cω and ε &gt; 0. We will show that
there exists some E&apos; ∈ P such that d(E, E&apos;) &lt; ε. Let k ∈ N such that 2—k &lt; ε. By
definition of liveness, there exists an extension E&apos; of the execution fragment formed
by taking the first k components of E such that E&apos; ∈ P. But then d(E, E&apos;) &lt; 2—k &lt; ε
and we are done.
Conversely, let P be a dense set. Let (C0, C1, ... , Ck) be an execution fragment.
We have to show that there exists some extension E&apos; ∈ P of the fragment. Let E
be any extension of the fragment. Because P is dense, there exists E&apos; ∈ P such that
d(E, E&apos;) &lt; 2—k—1, which shows that E&apos; is also an extension of (C0, C1, ... , Ck). ■
The following result was proved by Alpern and Schneider (1985).
Theorem 4.1. Let P ⊂ Cω be any property. Then there exists a safety property S
and a liveness property L such that P = S ∩ L.
</bodyText>
<page confidence="0.948917">
15
</page>
<subsubsectionHeader confidence="0.413149">
4 Point-Set Topology 4.1 The Topology of Execution Spaces
</subsubsectionHeader>
<bodyText confidence="0.4559335">
Proof. Define S = P to be the topological closure of P and L = Sc ∪ P. Then
of course S ∩ L = P. It is also clear that S is closed, hence a safety property by
Lemma 4.2. It remains to show that L is dense (Lemma 4.3).
By Lemma A.4(4), we have
</bodyText>
<equation confidence="0.804161">
L = Pc ∪ P ⊃ Pc ∪ P = C&apos; (4.7)
</equation>
<bodyText confidence="0.993563333333333">
which concludes the proof. ■
Notice that the above notions of closedness and density, but also of safety and
liveness, are dependent on the surrounding space C&apos;. We used these notions in a
“global” sense, meaning that they were understood with respect to the whole space
C&apos;. When considering a specific algorithm running in a specific model, however, we
may mean something different by “safety” and “liveness”.
For example, consider a consensus algorithm A with set S ⊂ C&apos; of admissible
executions. Then C0, the set of initial configurations of A, is not equal to C, because
there exist configurations in which processes have decided, but no process has decided
in an initial configuration. It follows that S is not dense in C&apos;, since every E ∈ S
starts with an initial configuration. Hence S, as a property in C&apos;, is not a liveness
property. But S itself is of course a liveness (and even a safety) property in S.
It follows that the notions of safety and liveness are relative notions. Of course,
statements analog to that of Lemma 4.2 and Lemma 4.3 hold relative to some set S
of executions.
</bodyText>
<subsectionHeader confidence="0.843716">
4.1.1. Motivation
</subsectionHeader>
<bodyText confidence="0.999620125">
In this subsection, we will demonstrate topological proof techniques for impossibility
results with the help of a simple example.
Consider a consensus algorithm A for N &gt; 3 processes communicating by means
of single-reader multiple-writer shared read-write registers.4 Of these processes, f =
N − 1 might fail by crashing. According to Section 2.4, a configuration C in this
model consists of a tuple (s1, s2, ... , sN) and a tuple (v1, v2,... , vM) where si is the
internal state of process pi and vi is the content of a shared memory register. An
event in this system model is a process number j ∈ {1, 2, ... , N}, which expresses
that process pj takes a step. An admissible schedule is a sequence of process numbers
in which at least one process occurs infinitely often (recall that f = N − 1). Hence
every sequence in {1, 2, ... , N}N is an admissible schedule.
We work with two sequence spaces: the space of schedules and the space of exe-
cutions. In this example, the set of schedules is equal to Σ = {1, ... , N}N and the
set S of admissible executions of some algorithm is a subset of C&apos; where C denotes
the set of all configurations. We equip both sets with the topology discussed at the
beginning of Section 4.1.
</bodyText>
<footnote confidence="0.9870325">
4This is very similar to the model of Dolev, Dwork, and Stockmeyer 1987, Theorem I1.1 and a
special case of the system model in Section 2.4.
</footnote>
<page confidence="0.991026">
16
</page>
<subsubsectionHeader confidence="0.319707">
4 Point-Set Topology 4.1 The Topology of Execution Spaces
</subsubsectionHeader>
<bodyText confidence="0.9733345">
Lemma 4.4. Let S be the set of admissible executions of some consensus algorithm
A. Define the map Δ : S → {0, 1} such that Δ(E) is the decision value of algorithm
A in execution E. Then Δ is continuous.
Proof. It suffices to show that Δ is locally constant, i.e., for all E ∈ S, there exists
some neighborhood N of E (Definition A.6) such that Δ is constant on N, that is,
Δ(E&apos;) = Δ(E) for all E&apos; ∈ N.
Let E ∈ S be some admissible execution of A. By the termination property of
consensus, there exists some configuration C in E such that some process has already
decided. Let k be an index such that the kth configuration in E is equal to C. We
claim that
N = JE&apos; ∈ S  |E&apos; coincides with E up to the kth configuration} (4.8)
is the desired neighborhood. It is clear that Δ is constant on N, because by the
agreement condition of consensus, no other consensus decision value is possible after
a process has decided.
It remains to show that N is indeed a neighborhood of E. Define ε = 2−k. With
the metric defined in (4.2), we conclude that N is the set of admissible executions
that have distance to E less than ε. Thus N is an ε-ball, hence open. ■
Let S denote the set of admissible executions. When we fix some initial configura-
tion I, by the semantics of the model, every admissible schedule determines exactly
one admissible execution. This induces a mapping fI : Σ → S, details of which are
depicted in Figure 4.1.
initial config. C0; schedule (j1, j2, j3, j4, . . . )
</bodyText>
<equation confidence="0.930067333333333">
f
j1 j2 j3 j4 j5
C0 C1 C2 C3 C4 ···
</equation>
<figureCaption confidence="0.878918">
Figure 4.1.: Mapping from schedules to executions
</figureCaption>
<bodyText confidence="0.978498833333333">
If C0 denotes the set of initial configurations, then I 7→ fI is a map with domain
C0. Hence f may be viewed5 as a function C0 × Σ → S.
Lemma 4.5. If we equip C0 with the discrete topology, then f : C0 × Σ → S as
defined above is continuous.
Proof. Let (I, σ) be an element of C0 × Σ and let (Ik, σk)k be a sequence converging
to (I, σ). Then Ik → I and σk → σ. We will show f (Ik, σk) → f (I, σ).
</bodyText>
<footnote confidence="0.960559">
5by uncurrying
</footnote>
<page confidence="0.983887">
17
</page>
<subsubsectionHeader confidence="0.701044">
4 Point-Set Topology 4.1 The Topology of Execution Spaces
</subsubsectionHeader>
<bodyText confidence="0.99480715625">
Since C0 carries the discrete topology, convergence of (Ik) means that it is eventu-
ally constant (and equal to I). Hence it is no loss of generality to assume Ik = I for
all k.
It remains to show that fI(σk) → fI(σ). Let ε &gt; 0. Choose n ∈ N such that
2_n &lt; ε. Because the nth component of (σk) must be eventually constant for every
n, there exists some K ∈ N such that the first n components of σk agree for all
k &gt; K. But then, by construction of fI(σ), also the first n components of fI(σk)
agree for all k &gt; K. Hence
d(fI(σ), fI(σk)~ &lt; 2_n &lt; ε for all k &gt; K (4.9)
and we are done. ■
By definition of the system model, f : C0 ×Σ → S is surjective. But by Tychonoff’s
theorem (Theorem A.3), Σ and also C0 × Σ are compact. Hence S is a continuous
image of a compact space, which implies that S itself is compact (Lemma A.10). Since
Cω is metrizable, hence Hausdorff, we conclude that S is closed in Cω (Lemma A.9).
Thus, S is a safety property in Cω (Lemma 4.2).
The established continuity (both Δ and fI are continuous) of Δ ◦ fI : Σ → {0, 1}
for I ∈ C0 has the following consequence: The sets Σα, α ∈ {0, 1}, of schedules σ
for which Δ(fI(σ)) = α, i.e., where the algorithm decides on α in execution fI(σ),
are closed in Σ, because they are inverse images of the closed sets {α} ⊂ {0, 1}
under a continuous mapping. Being closed in a compact space, the sets Σα are
compact (Lemma A.9). But since each of these two sets is the complement of the
other in Σ, they are also open. The following lemma now establishes a uniform
bound K such that every execution starting from I is univalent after the Kth step.
By passing to the maximum over all I ∈ C0, we get a uniform bound K not re-
stricted to a particular initial configuration. In other words, CK is univalent for
every (C0, C1, ... , CK, ... ) ∈ S.
Lemma 4.6 (Lebesgue). Let (X, d) be a compact metric space and let (Uλ)λ∈Λ be
an open covering of X, i.e., every Uλ is open and X = U Uλ. Then there exists some
ε &gt; 0 such that for any x ∈ X, the ball Bε(x) is contained in one of the Uλ.
Proof. For every x ∈ X let δx &gt; 0 such that Bδ. (x) ⊂ Uλ for some λ. The family
of balls Bδ./2(x) indexed by x ∈ X forms an open covering of X. By compactness
(Definition A.13), there exist x1, x2, ... , xm ∈ X such that
</bodyText>
<equation confidence="0.663042">
X= Um Bδi /2(xj ). (4.10)
j=1
</equation>
<bodyText confidence="0.97503875">
where δj = δxi. We set δ = min{δ1, δ2,. .. , δm} and ε = δ/2.
Let x ∈ X, then x ∈ Bδi /2(xj) for some j. Hence d(x, xj) &lt; δj /2. Let now
y ∈ Bε(x), then d(x, y) &lt; ε S δj/2. The triangle inequality implies d(y, xj) &lt; δj,
hence
</bodyText>
<equation confidence="0.955705">
Bε(x) ⊂ Bδi/2(x) ⊂ Bδi (xj) ⊂ Uλ (4.11)
</equation>
<page confidence="0.917822">
18
</page>
<figure confidence="0.40257825">
4 Point-Set Topology 4.1 The Topology of Execution Spaces
for some λ and we are done. ■
Corollary 4.1. There exists a K ∈ N such that for every execution (Co, Ci,... ) ∈ S,
the Kth configuration, CK, is univalent. ■
</figure>
<bodyText confidence="0.992522176470588">
On to the non-topological part of the impossibility proof: Together with the exis-
tence of a bivalent initial configuration,6 we have established the existence of a fork,
i.e., there exists a bivalent configuration C and direct successor configurations Do
and Di of C such that Dα is α-valent. We show that such a fork is impossible.7
Then, we have proved consensus impossibility.
Let p be the process taking the step C → Do and let q be the process taking the
step C → Di. The processes p and q are distinct.
Case 1: Both p and q perform read operations. Since f = N −1 &gt; 2, we can choose
a third process r and apply the schedule (r, r,... ) to both Do and Di. The resulting
decision value (the value that r decides on) is in both cases the same, because the
local state of r and all register values that r can read are the same in Do and Di.
But since Do is 0-valent and Di is 1-valent, this is a contradiction.
Case 2: p performs a read and q performs a write operation. The same trick as
in Case 1 works. Choose a process other than p and other than the reader of the
register that q writes to.
Case 3: Both p and q perform write operations. Silence the readers of both
registers that get written to by p and q.
</bodyText>
<subsectionHeader confidence="0.796836">
4.1.2. Execution Trees
</subsectionHeader>
<bodyText confidence="0.999884066666667">
Executions are sequences of configurations. At any point (configuration) in such a
sequence, it is often possible to choose from more than one successor configuration,
as governed by the system model and the algorithm. One can, in a natural way,
assign a decision tree to any set of executions that captures the decision of choosing
a successor. We will characterize in Section 4.1.3 certain sets of executions whose
decision trees capture all the information about the original set. This follows an idea
by Lubitch and Moran (1995).
Let C be the set of configurations of an algorithm A and let S ⊂ Cω. We will
construct a tree T(S) that reflects the local decisions of choosing a successor con-
figuration. We construct it inductively, of course. First of all, we insert a root ⊥.
We then connect to it nodes labeled with every configuration Co that occurs as an
initial configuration in S, see Figure 4.2. These are exactly the vertices at depth 1.
Suppose now that we already constructed the tree up to depth n. We describe how
to construct the vertices at depth n + 1. Let Cn_i be a vertex at depth n. There
exists a unique path (⊥, Co, Ci, ... , Cn_i) from ⊥ to Cn_i. We connect to Cn_i
</bodyText>
<footnote confidence="0.957746333333333">
6Existence of a bivalent initial configuration is established by a bit-flipping argument. This standard
proof technique can be examined in Attiya and Welch 2004, Lemma 5.16.
7cf. Dolev, Dwork, and Stockmeyer 1987, Lemma I1.1.1
</footnote>
<page confidence="0.992974">
19
</page>
<figure confidence="0.90356075">
4 Point-Set Topology 4.1 The Topology of Execution Spaces
⊥
C1 C2 C3 C4 C5
0 0 0 0 0
</figure>
<figureCaption confidence="0.999166">
Figure 4.2.: Constructed tree up to depth 1
</figureCaption>
<bodyText confidence="0.999859166666667">
Note that this procedure indeed does result in a tree since no single vertex is
connected twice to a predecessor node. In particular, vertices are not configurations,
but only labeled by configurations. Hence it is indeed possible that there exist two
different nodes in T(S) that are labeled with the same configuration. The labels of
nodes at depth n are exactly the configurations that occur in the (n−1)th component
of executions in S. Also, nodes in this tree may have infinite degree. But, as we
will see later, for any specific distributed system model and algorithm running on it,
the tree of the set of admissible executions will be locally finite, i.e., nodes will have
finite degree.
By construction, every execution in S corresponds to an infinite path in the tree
T(S). The converse, however, is not true in general. There exist sets S and infinite
paths in T(S) that do not correspond to an execution in S. For example, consider
a shared memory algorithm for N &gt; 3 processes and up to f = N − 2 crash faults.
The corresponding set S contains all sequences of process numbers with the property
that at least two processes occur infinitely often. In the tree T(S) every node has
exactly N children — one for every process. Hence the infinite path (1, 1,... ) exists
in T(S), but this sequence is not an element of S. In the following section, we will
explore for which sets S every path in the assigned tree describes an execution is S.
</bodyText>
<figure confidence="0.927584571428571">
nodes labeled with every configuration Cn such that (C0, C1, ... , Cn−1, Cn) occurs as
a prefix of some execution in S.
(C3 0, C3 1 , C3 2,...
S
T(S)
20
4 Point-Set Topology 4.1 The Topology of Execution Spaces
</figure>
<subsectionHeader confidence="0.550935">
4.1.3. Path–Sequence Duality
</subsectionHeader>
<bodyText confidence="0.97521625">
For a tree T(S) as constructed in 4.1.2, let P (T (S)) denote the set of executions
in Cω that correspond to infinite paths in T(S). The relation P (T (S)) ⊃ S always
holds. We are interested in those S for which P (T (S)) = S. These are the sets of
executions for which it suffices to make local decisions when constructing an admis-
sible execution. For all sets that do not have this property, we have to filter out some
executions constructed by virtue of paths in order to arrive at the set of admissible
executions. The following theorem solves the above question.
Theorem 4.2. Let S ⊂ Cω. The following are equivalent:
</bodyText>
<listItem confidence="0.6311325">
(1) P (T (S)) = S
(2) S is closed in Cω
</listItem>
<bodyText confidence="0.81319724">
In this case, S is compact if and only if T(S) is locally finite.
Proof. (1)⇒(2): Let E = (Co, Ci, ... ) ∈� S = P (T(S)). Then either Co is not an
initial configuration in S or there exists some n ∈ N such that Cn is not a child
of Cn−i in T(S). In the first case, no execution that starts with Co is an element
of S, i.e., Bi(E) ⊂ Cω \ S. In the second case, by definition of T(S), we have
B2−n (E) ⊂ Cω \ S. We conclude that Cω \ S is open, hence S is closed.
(2)⇒(1): Let E = (Co, Ci,... ) ∈ P (T(S)). We show E ∈ S. By definition
of T(S), for any n ∈ N there exists some execution En ∈ S that starts with
(Co, Ci, ... , Cn). Since En → E as n → ∞ and since S is closed, the claim fol-
lows from Lemma A.3.
Now, let T(S) be locally finite, i.e., every node has finite degree. Then, for every
n ∈ ω, there are only finitely many configurations possible to appear as the nth
component of an execution in S. Denote the set of possible configurations in the nth
component by Cn. Then, S ⊂ Hn∈ω Cn. The latter set being compact (Theorem A.3
and Example A.10), the compactness of S follows from Lemma A.9(1).
Finally, let S be compact. Let v be any vertex in T(S). We will show that v has
only finitely many children. Suppose that v =⊥ is the root and ⊥ has infinitely many
children, i.e., Co is infinite. Consider the following open covering of S:
Bi(Co, Ci, ... ) = {E&apos; ∈ S  |E&apos; starts with Co } where Co ∈ Co (4.12)
By compactness of S, there exists a finite subcovering, but this is impossible. The
case v 74=⊥ is completely analogous. ■
The advantage of closed sets of executions is now obvious: We can restrict ourselves
to local decisions when constructing an execution in the set. So, if we are considering
some closed subset of the set of admissible executions, we are guaranteed admissibility
of the execution constructed in a local fashion.
</bodyText>
<page confidence="0.982647">
21
</page>
<sectionHeader confidence="0.553409" genericHeader="method">
4 Point-Set Topology 4.2 Topological Impossibility
</sectionHeader>
<subsectionHeader confidence="0.955348">
4.2. Topological Impossibility
</subsectionHeader>
<bodyText confidence="0.981553027777778">
This section contains the core of our topological impossibility proofs. We begin with
the topological main theorem:
Theorem 4.3. Let (X, d) be a metric space, A ⊂ X closed in X and C ⊂ X
compact. If A ∩ C = ∅, then
d(A, C) = inf {d(a, c)  |a ∈ A, c ∈ C} &gt; 0. (4.13)
Proof. Suppose not, i.e., d(A, C) = 0. Define the map fA : C → [0, ∞) by fA(x) =
inf{d(x, a)  |a ∈ A}. If we are able to show that fA is continuous, then we are done.
Because then the continuous function fA attains its minimum in the compact set
C (Lemma A.11), i.e., there exists some c ∈ C with fA(c) = 0. But since c is an
element of the open set X \ A, there exists some ε &gt; 0 such that Bε(c) ⊂ X\ A.
This implies fA(c) = inf{d(c, a)  |a ∈ A} &gt; ε &gt; 0, a contradiction.
It remains to show that f is continuous. Let ε &gt; 0 and c ∈ C. We choose δ = ε.
For c&apos; ∈ C with d(c, c&apos;) &lt; ε, we have
~~fA(c) − fA(c&apos;) ~~ S d(c, c&apos;) + fA(c&apos;) − fA(c&apos;) &lt; ε (4.14)
where we assumed without loss of generality that fA(c) &gt; fA(c&apos;) and used that
fA(c) &lt;, d(c, c&apos;) + fA(c&apos;) by the triangle inequality and that taking the infimum
preserves weak inequalities. ■
If we are able to find a compact (hence closed, Lemma A.9(2)) set K ⊂ S for which
d(K0, K1) = 0 where Kα denotes the set of α-deciding executions, we are done. We
then know that the Kα are compact, because the decision function Δ is continuous.
But this is a direct contradiction to Theorem 4.3.
We will, however, use a slightly different argument to derive a contradiction. Most
often, we will not directly reason with sequences of configurations. What we will
rather do is follow an idea which was introduced by Lubitch and Moran (1995)
and generalized by Moses and Rajsbaum (2002): We use schedulers to construct
executions.
Definition 4.1. Let S be the set of admissible executions of some algorithm. A
scheduler for S is a metric space X together with a continuous map f : X → S. A
scheduler is called closed if X is compact. ❑
We will use schedulers to describe the construction of executions in a (closed)
subset of S (namely the image of f). An example of a scheduler is the above mapping
f of Section 4.1.1. We prominently used the fact that f and in particular that Δ ◦ f
was a continuous mapping. The general result about transportation of properties in
Theorem 4.3 is the following lemma.
Lemma 4.7. Let f : X → S be a closed scheduler. The following assertions are
true:
</bodyText>
<page confidence="0.822014">
22
</page>
<listItem confidence="0.850580222222222">
4 Point-Set Topology 4.2 Topological Impossibility
(1) If A C X is closed then f [A] C S is closed and compact.
(2) d(A, B) = 0 implies d(f [A], f [B]) = 0 for all A, B C X.
Proof. (1): Every closed set A C X is compact since X is compact (Lemma A.9(1)).
Since f is continuous, we may deduce that f [A] is compact (Lemma A.10). But S
is Hausdorff and hence every compact set is closed by Lemma A.9(2); in particular
f [A].
(2): Let d(A, B) = 0. If we set εk = 2−k we get by the uniform continuity of f
(similar to Theorem A.2) the existence of δk &gt; 0 such that
</listItem>
<equation confidence="0.611502">
d(x, y) &lt; δk =&gt; d(f (x), f (y)) &lt; 2−k (4.15)
</equation>
<bodyText confidence="0.99809645">
By hypothesis there exist sequences (ak) in A and (bk) in B such that d(ak, bk) &lt; δk
for all k E N. The implied relation d (f (ak), f (bk)) , 0 as k , oo now concludes
the proof. ■
Any closed scheduler we will construct in the subsequent will, like S, itself be a
sequence space, i.e., X C LN for some set L. Hence a closed scheduler X can be
viewed as the set of paths in the locally finite tree T (X); see Theorem 4.2. Often,
the set L will be a set of layers (Moses and Rajsbaum 2002), i.e., each E E L will
correspond to a finite sequence of events. For example, a layer in the shared memory
model will be every process taking one step in some fixed order. The fact that
each layer is a fixed finite sequence of events will immediately establish continuity
of f. Hence the continuity of Δ o f where Δ is the decision function will establish
the compactness of both X0 and X1 where Xα is the set of schedules in which
the algorithm decides on α. It remains to show d(X0, X1) = 0 to complete the
impossibility proof by virtue of Theorem 4.3 — see Section 4.2.1.
In a way, a scheduler f : X , S defines a sub-model of S. This is particular
apparent if we consider schedulers that consist of sequences of layers: In S, it is
defined which configurations may follow which. The layering limits these possibilities
and takes “shortcuts” from one configuration to another. Thus, the tree T (X) can
be seen as a sub-tree of T(S) in some sense with the additional convenient property
that P(T(X)~ = X (if we are considering a closed scheduler).
</bodyText>
<subsectionHeader confidence="0.885586">
4.2.1. Additional Structure — Configuration Similarity
</subsectionHeader>
<bodyText confidence="0.971312875">
Up to now, we solely considered a single structural entity regarding the set of execu-
tions: In which order configurations may occur in an execution. But there is more
information to configurations than their order. To be precise, we now introduce
two similarity relations on the set of configurations; one model-dependent (process
similarity) and one model-independent (valence similarity).
Definition 4.2. Let C and C0 be configurations. We write C ∼v C0 if it is not the
case that one is 0-valent and the other is 1-valent. Then C and C0 are called valence
similar. ❑
</bodyText>
<page confidence="0.932764">
23
</page>
<subsubsectionHeader confidence="0.5018">
4 Point-Set Topology 4.2 Topological Impossibility
</subsubsectionHeader>
<bodyText confidence="0.871958307692308">
Definition 4.3. Let C and C&apos; be configurations of a message-passing algorithm, i.e.,
an algorithm in either of the models of Sections 2.2 or 2.3. We write C —p C&apos; and
call C and C&apos; process similar if C and C&apos; differ in the state of at most one process.
We denote the transitive closure of this relation by the same name and symbol. ❑
Definition 4.4. Let C and C&apos; be configurations of a single-writer shared-memory
algorithm (Section 2.4). We write C —p C&apos; and call C and C&apos; process similar if
C and C&apos; differ in the state and registers8 of at most one process. We denote the
transitive closure of this relation by the same name and symbol. ❑
The following lemmata provide a relation between these two similarity notions and
an argument why d(X0, X1) &gt; 0, i.e., a 0-1-fork, is often not possible in closed sets.
Lemma 4.8. Consider either a message-passing or a single-writer shared memory
model with at most f &gt; 1 crash faults. Let S be a closed set of admissible executions
that
</bodyText>
<listItem confidence="0.995573166666667">
(1) has the possibility to silence a process, i.e., from every configuration C and for
every process p exists an infinite path in T (S) starting from C in which p does
not take steps.
(2) is locally uniform, i.e., if a sequence of events that does not involve process q is
applicable to a configuration C in S, then it is applicable to all configurations
in S that differ from C at most in the state (and registers) of q.
</listItem>
<bodyText confidence="0.888283">
Let C and C&apos; be configurations in S. If there exist successors D and D&apos; of C and C&apos;
respectively such that D —p D&apos;, then C —, C&apos;
Proof. Suppose not, i.e., without loss of generality C is 0-valent and C&apos; is 1-valent.
Since C is 0-valent, so is its successor D. By the same token, D&apos; is 1-valent. The
relation D —p D&apos; implies the existence of processes q1, q2, ... , qt and configurations
D0, D1, ... , Dt such that D0 = D, Dt = D&apos;, and configurations Dj_1 and Dj differ
exactly in the state of process qj. By transitivity of valence similarity, it suffices to
show that if D and D&apos; differ only in the state of a single process q, then D —, D&apos;.
Because we assumed that we can silence process q, there exists a sequence of events
starting from both D and D&apos; that does not include steps taken by q. By the event
semantics of the particular models, the processes other than q decide on the same
values in both executions, hence the valency of D and D&apos; is the same. This is a
contradiction. ■
Lemma 4.9. Let C be a bivalent configuration. Then not all successor configurations
of C are valency similar. ■
</bodyText>
<footnote confidence="0.97366">
8We say that register R belongs to process P if P is the sole writer of R.
</footnote>
<page confidence="0.991817">
24
</page>
<sectionHeader confidence="0.331454" genericHeader="method">
4 Point-Set Topology 4.3 Impossibility Results
</sectionHeader>
<subsectionHeader confidence="0.984139">
4.3. Impossibility Results
</subsectionHeader>
<bodyText confidence="0.991199666666667">
We will list a number of impossibility proofs in this section that utilize our topological
framework. In particular, we give a closed scheduler for each of the models. We will
use arguments from Moses and Rajsbaum 2002, Sections 3, 7 and 8.
</bodyText>
<subsectionHeader confidence="0.919539">
4.3.1. Asynchronous Message Passing
</subsectionHeader>
<bodyText confidence="0.998901">
We now present a topological proof of the consensus impossibility result (Fischer,
Lynch, and Paterson 1985) in the model introduced in Section 2.2.
We fix some enumeration p1, p2, ... , pN of the processes. The scheduler we will use
is the following. We choose
</bodyText>
<equation confidence="0.681755">
L, = {aok,, except,} ∪ {delayed,(i)  |1 S i S N} (4.16)
</equation>
<bodyText confidence="0.990543384615385">
for any permutation9 7r ∈ SN, L = U,∈SN L, as the set of layers, and X = LN.
The mapping f : X → S is defined to be the application of a sequence of layers
to these initial configurations. More precisely, every layer in L is defined to be a
finite sequence of events (see below for the exact definition) and the application
of a sequence (£1, £2, £3,... ) of layers to an initial configuration C0 is defined by
concatenating all layers to a single schedule σ and taking the corresponding sequence
of steps.
It remains to describe the layers aok,, except, and delayed,(i). In layer aok,,
every process takes steps in the order governed by the permutation 7r, i.e., in the
order p,(1), p,(2),..., p,(N), each process receives all messages sent to it thus far.
Layer except, is the same as aok, except that process p,(N) does not take steps. In
layer delayed,(i), processes take steps in the order of 7r and all messages are received
except for messages sent from p,(i) to p,(i)+1 mod N in this very layer. (They are
likely to be received in the next layer — namely if and only if the recipient takes a
step in the next layer.)
We equip the finite set L with the discrete topology and X = LN with the product
topology. Finite sets are always compact and by Tychonoff’s theorem (Theorem A.3),
also X is compact. The mapping f is continuous, because the nth component of f (x)
only depends on the first n components of x ∈ X.10 Hence we are dealing with a
closed scheduler.
Let C be a configuration. For any layer £ ∈ L, let C·£ denote the configuration that
arises when applying £ to C. We want to show that the precondition of Lemma 4.8
is fulfilled. The set f [X] of executions is closed and has the ability to silence and
is locally uniform. Let D = C· £ and D&apos; = C · £&apos; be children of C in the tree
T (X). We want to show that D ∼v D&apos; with Lemma 4.8. In a first step, we restrict
ourselves to the case £, £&apos; ∈ L, for some 7r ∈ SN. This sub-claim will follow if we
</bodyText>
<footnote confidence="0.9991015">
9We denote the set of all permutations of {1, 2, ... , N} by SN.
10cf. Lemma 4.5
</footnote>
<page confidence="0.990187">
25
</page>
<sectionHeader confidence="0.368046" genericHeader="method">
4 Point-Set Topology 4.3 Impossibility Results
</sectionHeader>
<bodyText confidence="0.988892923076923">
show C • E —v C • aokπ for all E E Lπ. The non-trivial cases are E = exceptπ and
E = delayedπ(i). In the first case, we note that C •exceptπ •aok(πoσ) = C •aokπ •exceptπ
where σ is the permutation with σ(j) - j —1 mod N. This is because in both cases
the order in which processes take steps is equal to
7r(1), ... , 7r(N — 1), 7r(N), 7r(1), ... , 7r(N — 1) (4.17)
with the same sequence of events (receive all messages). The second case is
E = delayedπ(i). There, we have C • delayedπ(i) —p C • aokπ because these two
configurations only differ in the state of a single process (the process to which not
all messages were delivered — namely 7r(i) + 1 mod N). This concludes the proof of
the precondition of Lemma 4.8 if we restrict our choices to a single Lπ.
Let now 7r, σ E SN. We want to show C • aokπ —v C • aokσ. For this, write
7r-1 o σ = 7&apos;1 o 7&apos;2 o • • • o 7&apos;k where every 7&apos;j is a transposition, i.e., every 7&apos;j flips the
positions of two neighboring elements of {1, 2, ... , N}.11 An elementary result of
group theory is the possibility to write a permutation as a product of transpositions.
We see that it suffices to show C • aokπ —v C • aok(πoτ) for transpositions 7&apos; E SN.
But this follows from
C • aokπ —v C • delayedπ(j) = C • delayed(πoτ)(j) —v C • aok(πoτ) (4.18)
if 7&apos; flips j and j + 1 mod N.
The rest of the proof is as follows: Prove the existence of a bivalent initial configu-
ration by classical means (e.g., a bit-flipping argument; note that we can completely
silence a process from an execution using our layers), use Theorem 4.3 to arrive at
d(X0, X1) &gt; 0, deduce the existence of a 0-1-fork and finally use Lemmata 4.8 and
4.9 to derive a contradiction.
Notice that we proved the following result:
Theorem 4.4. There is no consensus algorithm in the asynchronous message-passing
model with at most one crash failure. ■
</bodyText>
<subsectionHeader confidence="0.98998">
4.3.2. Asynchronous Shared Memory
</subsectionHeader>
<bodyText confidence="0.998669125">
In this section, we will prove impossibility of consensus in asynchronous system
models of Section 2.4 with shared single-writer read-write registers where one process
may fail by crashing (e.g., Fich and Ruppert 2003, Section 5.2).
We again fix some enumeration p1, p2, . . . , pN of the processes. Again, we choose
for every permutation 7r E SN a set Lπ = {aokπ, exceptπ} of layers and set L =
UπESN Lπ. The so-defined scheduler f : LN --&gt; S is closed (see previous section for
details). In layer aokπ, all processes take a step in the order 7r(1), 7r(2), ... , 7r(N). In
layer exceptπ, all processes except for pπ(N) take a step in order 7r(1), 7r(2), ... , 7r(N —
</bodyText>
<footnote confidence="0.521441">
11To be more precise, a permutation τ ∈ SN is called a transposition if there exist 1 S i, j S N such
that i + 1 ≡ j mod N, π|({1, ... , N} \ {i, j}) is the identity and π|{i, j} is not the identity.
</footnote>
<page confidence="0.929666">
26
</page>
<table confidence="0.424344166666667">
4 Point-Set Topology 4.3 Impossibility Results
1). Let C be any configuration. It is C · aok, · except, = C · except, · aok(,◦Q) where
σ(j) - j − 1 mod N which shows that the hypothesis of Lemma 4.8 holds if we
restrict our choices to a single L,. As above, we are done if we show C · aok, ∼,
C · aok(,◦,) for every transposition τ. But this follows from the fact that we consider
single-writer registers by the following case distinction. Let τ flip indices i and i + 1.
</table>
<tableCaption confidence="0.988840333333333">
Case 1: Processes p,(z) and p,(z+1) both perform a read operation or both perform
a Write operation. Then the resulting configurations are equal.
Case 2: Process p,(z) performs a read and p,(z+1) performs a Write. Then the
resulting configurations differ in at most the state of p,(z).
Case 3: Process p,(z) performs a Write and p,(z+1) performs a read. Then the
resulting configurations differ in at most the state of p,(z+1).
The rest of the impossibility proof follows as above: Existence of a bivalent initial
configuration by bit-flipping (since we can completely silence a process), existence of
a fork by Theorem 4.3 and contradiction by Lemma 4.8.
</tableCaption>
<bodyText confidence="0.6981205">
Theorem 4.5. There is no consensus algorithm in the asynchronous single-writer
shared memory model with at most one crash failure. ■
</bodyText>
<subsectionHeader confidence="0.903571">
4.3.3. Transient Message Loss
</subsectionHeader>
<bodyText confidence="0.883111">
We will prove the impossibility result of Santoro and Widmayer 1989, Section 4.1 in
the model of Section 2.3.
Let p1, p2, ... , pN be an enumeration of the set of processes. We define the set of
layers to be
</bodyText>
<equation confidence="0.987457">
L = {loss(i, j)  |1 S i S N, 0 S j S N} (4.19)
</equation>
<bodyText confidence="0.937417">
and again describe the scheduler f : LN → S by describing each of the layers. As
above, this scheduler is closed. The layer loss(i, j) is equal to the single event (set of
omissions)
</bodyText>
<equation confidence="0.994544">
O = {(i, k)  |k S j and k =74 i} . (4.20)
</equation>
<bodyText confidence="0.990183666666667">
For every configuration, we have C · loss(i, j) ∼p C · loss(i, j − 1) and loss(i, 0) =
loss(i&apos;, 0) which implies that the precondition of Lemma 4.8 holds. Note that we can
silence any process pz from any time on by repeatedly issuing loss(i, N). By the usual
method, this concludes the impossibility proof.
Theorem 4.6. There is no consensus algorithm in the synchronous message-passing
model with at most N − 1 per-round message omissions. ■
</bodyText>
<page confidence="0.994113">
27
</page>
<sectionHeader confidence="0.992333" genericHeader="method">
5. Algebraic Topology
</sectionHeader>
<bodyText confidence="0.995444">
This chapter deals with a different view on topology than that we took in Chapter 4.
We will consider algebraic topology (Hatcher 2002). In this discipline, we assign to
topological spaces certain algebraic objects, reason about relations between these
algebraic objects and then translate back these insights to statements about topo-
logical spaces. These techniques will enable us to prove the impossibility of k-set
agreement.
</bodyText>
<subsectionHeader confidence="0.51141">
5.1. Introduction
</subsectionHeader>
<bodyText confidence="0.99161775">
Algebraic topology splits up into two major threads: homotopy and homology. An
example of a construction used in homotopy is the fundamental group of a (path-
connected) topological space X. It is defined as the quotient of the group of all loops,
i.e., continuous maps [0, 1] → X starting from and ending at the same point x0 ∈ X
where the group operation is defined as the juxtaposition of two loops, with respect
to the equivalence relation of homotopy, i.e., continuous deformability of one loop
to another. A very natural question to ask is which topological spaces have trivial
fundamental groups, i.e., in which spaces are all loops continuously deformable into
each other. The class of these spaces is called the class of simply connected spaces.
The other major branch of algebraic topology is homology. Similar to homotopy, it
deals with spaces of continuous mappings [0, 1]q → X, but unlike homotopy, it does
not directly define a group operation on this set, but rather factors the free Abelian
group generated by these mappings with respect to a certain equivalence relation.
We will need a few techniques from homology in the course of this chapter and we
provide a brief introduction to this topic in Section 5.2.
Turning to the world of distributed computing again, what we will do in this
chapter is proving impossibility of k-set agreement in asynchronous systems commu-
nicating by read-write registers in the presence of up to k crash failures. The proof
that we present here was developed by Herlihy and Shavit (1993). Its strategy is
to introduce a structure on the set of local processor states of an algorithm, namely
that of a simplicial complex and reason that the subcomplex of final configurations
(configurations in which enough processes have decided) is incompatible with the so-
called output complex, i.e., a simplical complex describing decisions that are allowed
by the problem statement.
</bodyText>
<page confidence="0.991449">
28
</page>
<figure confidence="0.529556">
5 Algebraic Topology 5.2 Homology
5.2. Homology
This section introduces basic notions of homology theory.
</figure>
<subsectionHeader confidence="0.721718">
5.2.1. Chain Complexes
</subsectionHeader>
<bodyText confidence="0.974598375">
In this section, we will discuss the basic algebraic objects we will encounter along
the way. These are chain complexes and more generally graded Abelian groups.
Let A. = (Ak)kEZ be a sequence of Abelian groups. Then we call A. a graded
Abelian group. A morphism ϕ of degree m ∈ Z from A. to B. is a sequence ϕk :
Ak → Bk+m of Abelian group morphisms. We denote a morphism of degree m = 0
plainly by the name morphism. That is, a graded Abelian group is just an enumerable
collection of Abelian groups and a morphism is just an enumerable collection of
Abelian group morphisms.
A chain complex (A., ∂) is a graded Abelian group A. together with a morphism
∂ of degree −1 from A. to itself, i.e., for every k ∈ Z we have that ∂k : Ak→ Ak-1
is an Abelian group morphism, with the additional property that ∂k ◦ ∂k+1 = 0 for
all k ∈ Z. This restriction is the same as saying that the image im ∂k+1 is a subset
of the kernel1 ker ∂k. We call ∂ the boundary operator of the chain complex.
A morphism ϕ : C → D of graded Abelian groups between chain complexes is a
morphism of chain complexes if and only if for all k ∈ Z it holds that ϕk-1 ◦ ∂Ck =
∂Dk ◦ ϕk. In other words, the diagram in Figure 5.1 commutes.
</bodyText>
<equation confidence="0.997502523809524">
∂C ∂C ∂C ∂C ∂C
k-1 k k+1 k+2
Ck-2 ←−−−− Ck-1 ←−−−− Ck ←−−−− Ck+1 ←−−−− Ck+2 ←−−−− ···
k+3
(Pk-2 y (Pk-1   y (Pk   y (Pk+1 y (Pk+2 y
∂Ck-2
···
∂D
←−−−− Dk
k
∂D
←−−−− Dk+1
k+1
∂D
−−−− Dk+2
+2 ←−−−− ·· ·
k+3
··· ∂D Dk-2 ∂D Dk-1
k-2 k-1
∂D
k
</equation>
<figureCaption confidence="0.963264">
Figure 5.1.: Commutative diagram for chain complex morphisms
</figureCaption>
<subsectionHeader confidence="0.747449">
5.2.2. The Homology Functor
</subsectionHeader>
<bodyText confidence="0.9902866">
To every chain complex C, we may assign a special graded Abelian group H.(C)
called the homology of C. It has very interesting properties and is especially inter-
esting when putting topological spaces into the mix as is done in Section 5.4.1.
Let C be a chain complex. We have already noted that im ∂q+1 is contained in
ker ∂q for every q ∈ Z. These two sets being Abelian groups, we may form the
</bodyText>
<footnote confidence="0.90926">
1The kernel of an Abelian group morphism f : A → B is defined to be the set of all a ∈ A with
f (a) = 0 and is denoted by ker f. It is ker f an Abelian subgroup of A.
</footnote>
<page confidence="0.996335">
29
</page>
<figure confidence="0.807737">
5 Algebraic Topology 5.3 Simplicial Complexes
quotient Hq = ker ∂q/ im ∂q+1 and Hq is again an Abelian group. Hence, H(C) =
(Hq)qEZ is a graded Abelian group which we call the homology of C.
Note that if Hq = 0 for all q E Z, then ker ∂q = im ∂q+1. Hence the homology of a
chain complex measures how far the following diagram is from being exact2 at Cq:
· · · ∂q−1 ∂q ∂q+1 ∂q+2
←___ Cq-1 ←_ Cq ←___ Cq+1 ←___ ··· (5.1)
</figure>
<bodyText confidence="0.428077166666667">
Let ϕ : C → D be a chain complex morphism. Because of the defining rela-
tion for chain complex morphisms, we may deduce that ϕq[im ∂Cq+1] ⊂ im ∂Dq+1 and
ϕq[ker ∂Cq ] ⊂ ker ∂Dq .But this implies that ϕq factors to an Abelian group mor-
phism ker ∂C q / im ∂C q+1 → ker ∂D q / im ∂D q+1. We write ϕ* for the resulting morphism
H(C) → H(D). This construction has the property that (ψ o ϕ)* = ψ* o ϕ* and
(idC)* = idH(C) which indeed qualifies it for the name functor.
</bodyText>
<equation confidence="0.995613666666667">
Letψ : C → D be another chain complex morphism. A chain homotopy from ϕ
to ψ is a graded Abelian group morphism h : C → D of degree 1 such that
ψ _ ϕ = ∂D o h + h o ∂C. (5.2)
</equation>
<bodyText confidence="0.876768">
In this case, we write ϕ -- ψ and it is ϕ* = ψ* : H(C) → H(D).
</bodyText>
<subsectionHeader confidence="0.970328">
5.3. Simplicial Complexes
</subsectionHeader>
<bodyText confidence="0.9984678">
A simplicial complex C is a set of sets with the following property:
(LC) If A E C and B ⊂ A, then B E C.
In other words, a simplicial complex is left-closed with respect to the set inclusion
relation. The elements of C are called simplices and the elements of the set U C are
called vertices. For a simplex S E C, we define its dimension dim S = |S |_ 1. We
set dim C = supSEC dim S.
A vertex map between two simplicial complexes C and D is a map f : U C → U D.
It is called simplicial if for every S E C, f [S] E D, i.e., every simplex in C gets mapped
to a simplex in D. Simplicial complexes together with simplicial vertex maps form a
category.
</bodyText>
<subsectionHeader confidence="0.796252">
5.3.1. Simplicial Homology
</subsectionHeader>
<bodyText confidence="0.802606">
In this section, we will assign a chain complex C(C) and also its homology H(C) to
any simplicial complex C.
</bodyText>
<footnote confidence="0.9438455">
2A sequence A f−--+ B g−--+ C where A, B, C are Abelian groups and f : A --+ B, g : B --+ C are
Abelian group morphisms is called exact if im f = ker g.
</footnote>
<page confidence="0.989469">
30
</page>
<figure confidence="0.413878333333333">
5 Algebraic Topology 5.3 Simplicial Complexes
Definition 5.1. Let S be a set. We define the free Abelian group generated by S to
be the group ZS. ❑
</figure>
<bodyText confidence="0.9988165">
Let C be a simplicial complex and fix any total order on its set of vertices. For
any q &gt; 0 let Cq denote the set of q-dimensional simplices in C and let Cq be the free
Abelian group generated by Cq. The family (Cq)q∈Z is a graded Abelian group. We
will now define a boundary operator ∂q : Cq → Cq−1. Let S = {v0, v1,... , vq} ∈ Cq
with vi &lt; vj for i &lt; j. It suffices to define ∂q for such elements by the universal
property of free Abelian groups.3 Set
</bodyText>
<equation confidence="0.998705384615385">
∂q(S) = Xq (−1)k {v0, v1, ... , vk−1, vk+1, ... , vq} . (5.3)
k=0
Lemma 5.1. With the above definition, ∂q ◦ ∂q+1 = 0.
Proof. Let S = {v0, v1, ... , vq+1} ∈ Cq+1 with vi &lt; vj for i &lt; j. Then
∂q(∂q+1(S)) = ∂q Xq+1 ! j:q+1
k=0 (−1)k(S \ {vk}) = (−1)k∂q(S\ {vk})
k=0
Xq+1 (−1)k k−1X (−1)&apos;(S \ {vg, vk }) + Xq !(−1)�(S \ {vk, vP+1})
k=0 P=0 P=k
Xq+1 (−1)k k−1X (−1)&apos;(S \ {vg, vk }) + Xq+1 !(−1)B−1(S \ {vk, vg}) (5.4)
k=0 P=0 £=k+1
X= X(−1)k+P(S \ {vP, vk}) − (−1)k+P(S \ {vk, vP})
0&lt;,$&lt;k&lt;,q+1 0&lt;,k&lt;P&lt;,q+1
</equation>
<bodyText confidence="0.963711333333333">
= 0
as claimed. ■
It is clear that a different choice of the total order on U C yields an isomorphic
chain complex. This concludes the definition of the chain complex C(C) = (C∗, ∂).
We set H(C) = H(C(C)).
Let f : U C → U D be a simplicial vertex map. Define for every q &gt; 0 the map
</bodyText>
<equation confidence="0.991411">
f# : Cq(C) → Cq(D) for S ∈ Cq, by
(
f[S] if dim f[S] = q
f#(S) = (5.5)
0 else.
</equation>
<bodyText confidence="0.9806335">
The so-defined map f# : C(C) → C(D) is a chain map and we have (g ◦f )# = g# ◦f#
and (idS C) # = idC(C).
</bodyText>
<footnote confidence="0.857864">
3Let G be the free Abelian group generated by some set S, let H be an Abelian group and let
f : S --+ H be a map. Then there exists a unique morphism W : G --+ H such that WAS = f.
</footnote>
<page confidence="0.994081">
31
</page>
<figure confidence="0.300679">
5 Algebraic Topology 5.4 Algebraic vs. Combinatorial Topology
Definition 5.2. Let C be a simplicial complex and let k &gt; 0. We say that C is
k-acyclic if H0(C) ∼= Z and Hq(C) = 0 for 1 S q S k. ❑
</figure>
<bodyText confidence="0.9929415">
Let C and D be simplicial complexes and let Σ : C → P(D) be a mapping with the
following properties:
</bodyText>
<listItem confidence="0.932883">
(1) Σ(S) is a simplicial complex for every S E S.
(2) Σ(S) ⊂ Σ(S&apos;) if S ⊂ S&apos;.
(3) Σ(S) is (q − 1)-acyclic for every S E S with dim S = q.
</listItem>
<bodyText confidence="0.9486325">
Then we call Σ an acyclic carrier. Let ϕ : C(C) → C(D) be a chain map. We say
that ϕ is carried by Σ if T E Σ(S) for all S E C and T E D with cT =74 0 where
ϕ(S) = ZT∈D cTT. The following is Herlihy and Rajsbaum 2000, Theorem 3.3:
Theorem 5.1. Let Σ : C → P(D) be an acyclic carrier.
</bodyText>
<listItem confidence="0.9961835">
(1) There exists a chain map C(C) → C(D) that is carried by Σ.
(2) If ϕ, ψ : C(C) → C(D) are both carried by Σ and dim S = dim Σ(S) for all
</listItem>
<bodyText confidence="0.866332">
SEC, then ϕ = ψ. ❑
</bodyText>
<subsectionHeader confidence="0.975127">
5.4. Algebraic vs. Combinatorial Topology
</subsectionHeader>
<bodyText confidence="0.999952142857143">
This section explains the commonalities of pure algebraic topology, i.e., the investiga-
tion of topological spaces with help of assigned algebraic structures, and combinato-
rial topology, i.e., the investigation of combinatorial structures with help of assigned
algebraic structures. To be more precise, we introduce the homology of a topological
space and the geometric realization of a simplicial complex and show that these two
constructions are compatible. Results from this section are not needed later on and
are presented to deepen the reader’s understanding of these interconnections.
</bodyText>
<subsectionHeader confidence="0.890918">
5.4.1. Singular Homology
</subsectionHeader>
<bodyText confidence="0.89079025">
We will now show how to relate the algebraic construction of homology to topological
spaces. More precisely, we will assign to every topological space X a chain complex
C(X) and a graded Abelian group H(X) called its singular homology.
Definition 5.3. Let q &gt;, 0. The topological space
</bodyText>
<equation confidence="0.988144">
� � �
Δq = x E Rq+1  |xj = 1 and xj � 0 for all j (5.6)
</equation>
<bodyText confidence="0.794024">
is called the q-dimensional standard simplex. ❑
</bodyText>
<page confidence="0.986053">
32
</page>
<subsubsectionHeader confidence="0.340194">
5 Algebraic Topology 5.4 Algebraic vs. Combinatorial Topology
</subsubsectionHeader>
<bodyText confidence="0.9999466">
The qth component of the graded Abelian group of C(X) is defined to be the free
Abelian group generated by the set of continuous mappings Δq — X. It remains
to define the boundary operator ∂q : Cq(X) — Cq−1(X). It suffices to define this
map on the generators of Cq(X). So let σ : Δq — X be continuous. Consider the
following continuous functions δiq : Δq−1 — Δq for 1 S i S q + 1:
</bodyText>
<equation confidence="0.573901">
δiq(x1, ... , xq) = (x1, ... , xi−1, 0, xi, xi+1, ... , xq) (5.7)
</equation>
<bodyText confidence="0.938491">
It is easy to see that this function really has values in Δq. We now define ∂q(σ) by
the equation
</bodyText>
<equation confidence="0.997431">
∂q(σ) = Xq+1 (−1)i−1 (σ o δi ) . (5.8)
i=1 q
</equation>
<bodyText confidence="0.9151712">
Lemma 5.2. For any topological space X and any q e Z, with the above definition
of C(X), it holds that ∂q o ∂q+1 = 0. ❑
Hence C(X) is really a chain complex. We may thus form its homology H(C(X))
or just H(X) in short.
Let f : X — Y be a continuous mapping. We define the mapping f# : C(X) —
C(Y ) by setting f#(σ) = f o σ for continuous σ : Δq — X. It holds that (g o f)# =
g# o f# and (idX)# = idC(X). We denote by f∗ the mapping H(X) — H(Y ) induced
by the chain complex morphism f#.
Definition 5.4. Let X be a topological space and let k &gt; 0. We say that X is
k-acyclic if H0(X) ∼= Z and Hq(X) = 0 for 1 S q S k. ❑
</bodyText>
<subsectionHeader confidence="0.462882">
5.4.2. Geometric Realization of Simplicial Complexes
</subsectionHeader>
<bodyText confidence="0.994214">
In this section, we assign a topological space |C |to every simplicial complex C, called
its geometric realization.
</bodyText>
<equation confidence="0.95021475">
Let C be a simplicial complex. As a set, we define |C |by
|C |= ⎧ � ~~~~~~ v∈S C α(v) = 1 and {v  |α(v) =74 0} e C ⎫ (5.9)
⎨ α : C — [0, 1] ⎬
⎩ ⎭
</equation>
<bodyText confidence="0.989192">
and we define the topology on |C |by the metric
</bodyText>
<equation confidence="0.892599">
s X
d(α, β) = (α(v) − β(v))2.
(5.10)
v∈S C
For a simplicial vertex map f : U C — UD, we define |f |: |C |— |D |by
|f |(α)(w) = X α(v). (5.11)
f (v)=w
</equation>
<bodyText confidence="0.782106">
Consequences of these definitions are (Spanier 1966, Sec. 3.1):
</bodyText>
<page confidence="0.966644">
33
</page>
<figure confidence="0.8505375">
5 Algebraic Topology 5.5 Configuration Complexes
(1) |f  |is continuous.
~~ = id|C|
(2) |g ◦ f |= |g |◦ |f |and ~~idS C
(3) If C is finite then |C |is a compact Hausdorff space.
5.4.3. Equivalence
</figure>
<bodyText confidence="0.905018666666667">
The following theorem relates the homologies of C and |C |(Spanier 1966, Sec. 4.6,
Theorem 8).
Theorem 5.2. Let C be a simplicial complex. Then H(C) ∼= H(|C|). ❑
</bodyText>
<subsectionHeader confidence="0.929216">
5.5. Configuration Complexes
</subsectionHeader>
<bodyText confidence="0.9999392">
This section introduces simplicial complexes that we will assign to algorithms in order
to reason about the topological structure of these algorithms. In these complexes,
vertices will represent a state of a single process and a simplex consisting of vertices
s1, s2, ... , sN will represent a reachable configuration in which the ith process has
local state si.
</bodyText>
<subsubsectionHeader confidence="0.598054">
5.5.1. Input Complexes
</subsubsectionHeader>
<bodyText confidence="0.999824777777778">
k-set agreement is a decision task, i.e., every process has an input value and computes
an output value. Simplicial complexes provide a convenient way to describe the
structure of possible combinations of input and output values.
For example, consider the complex of initial configurations of the t-resilient binary
consensus problem. Here, every process pj starts with a private input value xj ∈
{0, 1}. For simplicity, we assume that every process has only two distinct initial
states: one with input value xj = 0 and one with input value xj = 1. Denote by
(j, α) the initial state of process pj with input value xj = α. Then the set of vertices
is equal to
</bodyText>
<equation confidence="0.696467333333333">
{(1, 0), (1, 1), (2, 0), (2, 1), ... , (N, 0), (N, 1)} . (5.12)
Basic simplices are sets of the form
S = {(1, α1), (2, α2), ... , (N, αN)} (5.13)
</equation>
<bodyText confidence="0.999986166666667">
where αj ∈ {0, 1}. The input complex for the binary consensus problem is defined by
the set of these basic simplices and its subsets. A geometric realization of the input
complex for N = 2 and N = 3 is depicted in Figure 5.2.
The input complex of k-set agreement is similar to that of consensus except that
the set in which the input values xj may vary is changed from {0, 1} to {1, 2, ... , M}
where M &gt; N.
</bodyText>
<page confidence="0.985517">
34
</page>
<figure confidence="0.99976">
5 Algebraic Topology 5.5 Configuration Complexes
(q,1)
(p,0)
(a) N = 2 (b) N = 3
</figure>
<figureCaption confidence="0.995444">
Figure 5.2.: Input Complexes
</figureCaption>
<subsubsectionHeader confidence="0.482071">
5.5.2. Output Complexes
</subsubsectionHeader>
<bodyText confidence="0.99423675">
We may also look at the output complex of the t-resilient binary consensus problem,
i.e., the complex that describes the possible output values yj. Vertices here are also
of the form (j, α) which reflects the fact that process pj has decided to output value
yj = α. Basic simplices are either of the form
</bodyText>
<equation confidence="0.897545">
S = {(j1, 0), (j2, 0), (j3, 0), ... , (jr, 0)} (5.14)
or of the form
S = {(j1, 1), (j2, 1), (j3, 1), ... , (jr, 1)} (5.15)
</equation>
<bodyText confidence="0.99834">
where all jg are distinct and r &gt; N − t, that is, at least N − t processes have decided
and they all decided to the same value. The output complex for the t-resilient binary
consensus problem is defined by the set of these basic simplices and its subsets.
Examples for N = 2 and N = 3 are depicted in Figure 5.3.
</bodyText>
<equation confidence="0.767926333333333">
(p,1) (q,1) (r,0) (q,1) (r,1)
(q,0) (p,0) (p,0) (q,0) (p,1)
(a) N = 2 (b) N = 3
</equation>
<figureCaption confidence="0.964028">
Figure 5.3.: Output Complexes
</figureCaption>
<bodyText confidence="0.9980245">
The output complex of the t-resilient k-set agreement problem is defined by the
set of simplices of the following form
</bodyText>
<equation confidence="0.811601">
S = {(j1, y1), (j2, y2), . . . , (jr, yr)} (5.16)
</equation>
<bodyText confidence="0.9997015">
where |{j1, ... , jr} |&gt; N − t and |{y1,..., yr} |S k and all of its subsets.
The problem specification of a decision task is a mapping Δ that maps a basic
input simplex Sn−1 to the set of basic output simplices that are allowed as decision
values given the specified initial configuration (input simplex).
</bodyText>
<page confidence="0.985403">
35
</page>
<figure confidence="0.97910775">
(p,1)
(q,0)
5 Algebraic Topology 5.6 Impossibility of k-Set Agreement
5.5.3. Protocol Complexes
</figure>
<tableCaption confidence="0.942423454545455">
When considering an initial configuration (° an input simplex) of a decision task,
one may ask which final configurations, i.e., configurations in which all processes
have halted (decided or crashed), are reachable from this initial configuration.
The answer to this question defines a mapping from input simplices to sets of
final configurations. For an input simplex S E Z with dim S &gt; n − t − 1, i.e.,
|S |&gt; n − t, we define the complex P(S) to be the reachable subcomplex of P where
only processes take steps that appear in S with initial states as specified in S. The
set of configurations (viewed as simplices) that occur in the image of this mapping
define a complex, the protocol complex. It encompasses the information which final
configurations may occur when running the protocol (algorithm). To be more precise,
a simplex
</tableCaption>
<equation confidence="0.745501">
S = fCj1, Cj2, Cj3,..., Cjr} (5.17)
</equation>
<bodyText confidence="0.783417">
is in the protocol complex if and only if
</bodyText>
<listItem confidence="0.995217285714286">
(1) Cjk is an internal state of process with number jk in which this process has
decided
(2) all jk are distinct
(3) there exists an execution of the protocol in which exactly the processes with
numbers j1, j2, ... , jr decide and all other processes crash (and do not reach a
decision value)
(4) in the above execution, process pjk halts with internal state equal to Cjk.
</listItem>
<bodyText confidence="0.993999571428572">
Consider the protocol complex P of some protocol that solves a decision task with
input complex Z, output complex O and decision map Δ. Then, we may assign to
every final state of a process (vertex in P) its decision value (vertex in O). More
precisely, a final state Cj gets mapped to α E f1, 2, ... , M} if and only if process pj
has decided to α in state Cj. This mapping can be extended in a natural manner to
a map from simplices in P to simplices in O. Denote this simplicial vertex map by
δ : S P → S O.
</bodyText>
<subsectionHeader confidence="0.997118">
5.6. Impossibility of k-Set Agreement
</subsectionHeader>
<bodyText confidence="0.980083571428571">
In this section, we prove the impossibility of wait-free k-set agreement in asyn-
chronous shared-memory environments, as presented in Herlihy and Shavit 1993.
Of course, we will heavily rely on methods from algebraic topology. In particular, we
will define a class of protocols (“full information protocols”) that has stronger system
assumption than the asynchronous shared-memory model and analyze its protocol
complex. This will help us derive a contradiction. A fortiori, this will establish the
impossibility result for usual asynchronous shared-memory systems.
</bodyText>
<page confidence="0.989973">
36
</page>
<figure confidence="0.453367">
5 Algebraic Topology 5.6 Impossibility of k-Set Agreement
5.6.1. Full Information Protocols
</figure>
<bodyText confidence="0.996959666666667">
Full information protocols communicate using a set of single-writer shared-memory
variables which allows for taking atomic snapshots, i.e., the contents of all variables
are read in a single step. Denote by RWnk the asynchronous shared-memory model
with read-write registers where at most k processes may fail by crashing and denote
by FInk the model of full information protocols where at most k processes may fail
by crashing.
The set of algorithms in FInk is quite restricted: The set S0 I of initial states of
processes are arbitrary, but the rest of the algorithm is defined by a single decision
vertex map δ : F → U O [ f?g where O is an output complex and the set F is the
set of full information states. The set F consists of tuples of the form (v1, v2,... , vn)
where every vj is either contained in U I [ f?g or again such a tuple. In a full
information protocol each process
</bodyText>
<listItem confidence="0.923017">
(1) has a single unbounded shared register it can write.
(2) writes its input value to its shared register in its first step.
(3) after the first step, repeatedly reads the values vj from all registers Rj, puts
them together into a tuple v = (v1, ... , vn) and writes this tuple v into its own
register.
(4) if δ(v) 74=? after such an iteration, the process halts with output value equal to
δ(v).
</listItem>
<bodyText confidence="0.947406166666667">
Theorem 5.3. If there exists a k-set agreement protocol in RWnk, then there exists
a k-set agreement protocol in FInk .
Proof. The non-trivial part of this proof is to simulate multiple-writer registers with
single-writer registers. This is part of Attiya and Welch 2004, Theorem 10.9. —
Attiya and Welch 2004, Theorem 10.15 shows that the converse of Theorem 5.3
also holds.
</bodyText>
<subsectionHeader confidence="0.919138">
5.6.2. Properties of Full Information Protocols
</subsectionHeader>
<bodyText confidence="0.977646666666667">
The most important property of full information protocols to us is the following
(Herlihy and Shavit 1993, Corollary 4.9):
Theorem 5.4. Let P be a protocol in FInn−1 and let S E I with dim S = q. Then
</bodyText>
<equation confidence="0.802071">
P(S) is (q − 1)-acyclic. ❑
</equation>
<page confidence="0.987671">
37
</page>
<figure confidence="0.411985">
5 Algebraic Topology 5.6 Impossibility of k-Set Agreement
</figure>
<subsectionHeader confidence="0.678412">
5.6.3. This Implies Impossibility
</subsectionHeader>
<bodyText confidence="0.958223956521739">
This section contains the proof of Herlihy and Rajsbaum 2000, Corollary 5.3.
Lemma 5.3. Let P be a protocol in FInn-1. Then S 7→ P(S) is an acyclic carrier.
Proof. Property (1) of an acyclic carrier is fulfilled by definition of P(S). Property (3)
is Theorem 5.4. We will show property (2). So let S ⊂ S&apos; in I. Let T ∈ P(S), we
have to show T ∈ P(S&apos;). By definition, T is a final configuration of the protocol
where only processes in S take steps with initial states as in S. Since S ⊂ S&apos;, the
initial states of processes in S are equal in S and S&apos;. Also, since it is admissible
to crash processes initially, every execution contributing to P(S) also contributes to
P(S&apos;). Hence T ∈ P(S&apos;) as claimed. ■
Theorem 5.5. Let P be a protocol in FInn-1 that solves k-set agreement. Then
k &gt; n.
Proof. Suppose by contradiction that k &lt; n.
Let Sn-1 = {(1, 1), (2, 2), (3, 3),... (n, n)} ∈ I and set A = P(Sn-1) ⊂ I which is
a simplicial subcomplex of I. Let B ⊂ O be defined to contain sets of the form
{(j1, y1), (j2, y2), ... , (jr, yr)} ∈ O (5.18)
where 1 S yg S n for all 1 S E S r.
Define 7r : U B → U A by 7r(j, y) = (y, y). Let σ : C(I)→ C(P) be a chain map
that is carried by S 7→ P(S) (Theorem 5.1(1)). Now set 0 = 7r# ◦ δ# ◦ σ : C(A) →
C(A) and Σ : A → P(A), Σ(S) = P(S). Σ is an acyclic carrier. It is obvious that Σ
carries 0.
Theorem 5.1(2) now implies that 0 = idC(A). But since the simplex Sn-1 =
{(1, 1), (2, 2), ... , (n, n)} does not occur in the image of 0 because k &lt; n, we derive
a contradiction. ■
</bodyText>
<page confidence="0.993924">
38
</page>
<sectionHeader confidence="0.994829" genericHeader="method">
6. Summary
</sectionHeader>
<bodyText confidence="0.999957263157895">
We investigated two applications of topology to problems in distributed computing.
These were impossibility proofs of (a) consensus in a number of 1-resilient systems
and (b) k-set agreement in asynchronous k-resilient systems. For this, we used meth-
ods from (a) point-set topology and (b) algebraic topology.
Point-set topology helped us in providing a way of reasoning about execution trees
in a unified way to prove impossibility of consensus. We regarded an execution as a
sequence of configurations and equipped the sequence space of all possible executions
with a metric which had the property that those executions are close together which
share a long common prefix. We then used schedulers to pass to a closed (hence
compact) subspace of the space of all executions. This subspace satisfied the precon-
dition of Lebesgue’s lemma which provided a uniform step bound after which every
configuration is univalent. A model-dependent analysis of configuration similarity
then concluded the impossibility proofs.
Algebraic topology, in particular homology, was introduced to examine simplicial
complexes. To utilize this, we considered input and output complexes of decision
tasks and configuration complexes of protocols (algorithms). The function that maps
input simplices to the complex of possible final configurations starting from it turned
out to be an acyclic carrier. This was then used to derive the impossibility of wait-free
k-set consensus, following Herlihy and Shavit (1993).
</bodyText>
<page confidence="0.993926">
39
</page>
<sectionHeader confidence="0.776541" genericHeader="method">
A. Topological Prerequisites
</sectionHeader>
<subsectionHeader confidence="0.909672">
A.1. Motivation and Examples
</subsectionHeader>
<bodyText confidence="0.999699">
Topology (Bourbaki 1989) is the mathematical discipline that explores the concept
of “closeness” and emerging notions. Fundamental is the notion of “neighborhood”.
Informally speaking, a topological space is a set together with a structure on this set
that specifies which points (elements of the set) are close to each other.
</bodyText>
<subsectionHeader confidence="0.848963">
A.1.1. Distances
</subsectionHeader>
<bodyText confidence="0.993536285714286">
Topological spaces (though in disguise) are actually encountered in every beginning
calculus class. More specifically, the real line R is a topological space and many of
its famous properties are in fact of topological nature. The following example shall
exemplify how specific topological concepts might look like.
Example A.1 (The real line). The dominant and natural notion of closeness depends
on the definition of distance between two real numbers. For real numbers x and y,
their distance is defined as
</bodyText>
<equation confidence="0.886332">
d(x, y) = |x − y |(A.1)
</equation>
<bodyText confidence="0.992093666666667">
(see Figure A.1), where |z |denotes the absolute value of z. Starting from this
definition, we may now state what it means for real numbers to be close to each
other. We may call x and y to be ε-close if their distance satisfies
</bodyText>
<equation confidence="0.922242">
d(x, y) &lt; ε (A.2)
</equation>
<bodyText confidence="0.982948">
where ε is some positive number. So, for every ε, we get a different notion of closeness.
Of course, these notions are not independent of each other. The most important
dependencies are:
</bodyText>
<listItem confidence="0.997151666666667">
(1) The only point that is ε-close to x for all ε, is x itself.
(2) If x is ε-close to y, then y is also ε-close to x.
(3) If x and z are ε-close and z and y are ε-close, then x and y are 2ε-close.
</listItem>
<bodyText confidence="0.923627333333333">
We will later see how these properties generalize to the formal definition of a topology.
We have already discussed an easy but important (topological) property of the
real line; above property (1): For any two distinct real numbers x and y, there exists
</bodyText>
<page confidence="0.98777">
40
</page>
<figure confidence="0.940004">
A Topological Prerequisites A.1 Motivation and Examples
</figure>
<figureCaption confidence="0.999304">
Figure A.1.: Distances on the real line
</figureCaption>
<bodyText confidence="0.987265857142857">
some positive ε such that x and y are not ε-close, for we may choose ε = d(x, y).
This property characterizes the real line as a topological T1 space. (The properties
Tι for ι E f0, 1, 2, 3, 321, 4} are the so-called separation axioms for topological spaces.)
But lR, satisfies even more: it is a T2 or Hausdorff space. In subsequent sections, we
will define for any topological space what it means to be of this important class of
spaces, i.e., to be Hausdorff and show some of their convenient properties. ❑
We observe that we may define the notion of ε-closeness on any set that, as in
the previous example, has a distance function d defined on it. This generalization
leads to the definition of metric spaces which lie in the class of topological spaces.
But before we formally define this, we look at a slight generalization of Example A.1,
namely the Euclidean spaces lR,n, and discuss in more detail the topological structure
and properties that these spaces carry.
Example A.2 (Euclidean spaces). As an analogue of the real absolute value, we
have the norm of a vector x E lR,n:
</bodyText>
<equation confidence="0.912710571428571">
⎛ ⎞ �
x1 = x2 1 + x22 + ··· + x2 (A.3)
⎜ . ⎟ n
I IxI I = ⎝ .. ⎠
xn
Thus, the distance of two vectors x and y in lR,n is defined as
d(x, y) = I Ix − yI I . (A.4)
</equation>
<bodyText confidence="0.996173222222222">
The three properties of Example A.1 still hold. Property (3), also known as the
triangle inequality, is depicted in Figure A.2. Its name comes from the fact that in
a triangle, the length of any edge is less than the sum of lengths of the other two.
The ε-neighborhood of a point x is the set of all points that are ε-close to x. It is
also called a ball with center x and radius ε and is denoted by Bε(x). Now, an open
set is a set X C lR,n such that, for every x E X, there exists an ε-neighborhood of
x that is contained in X. Intuitively, an open set is a set that has “a little room”
around every of its points, i.e., it does not have a “sharp boundary”. The situation
is sketched below in Figure A.3.
</bodyText>
<subsectionHeader confidence="0.462144">
Examples of open sets include:
</subsectionHeader>
<page confidence="0.994799">
41
</page>
<figure confidence="0.988766714285714">
x y lR,
|x − y|
A Topological Prerequisites A.1 Motivation and Examples
z
&lt; ε &lt; ε
x y
&lt; 2ε
</figure>
<figureCaption confidence="0.9840985">
Figure A.2.: Triangle inequality in lR,2
Figure A.3.: Point x has an ε-neighborhood that is contained in X
</figureCaption>
<equation confidence="0.5549665">
(1) In lR,1, the so-called “open intervals”
(a, b) = fx E lR, l a &lt; x &lt; b} (A.5)
</equation>
<bodyText confidence="0.769636">
are in fact open. For if x E (a, b), then, by definition, x — a &gt; 0 and b — x &gt; 0.
Hence with ε = minfx — a, b — x}, we get Bε(x) C (a, b): We may assume
without loss of generality that ε = x — a, i.e., x — a &lt; b — x. But then,
</bodyText>
<equation confidence="0.972822">
Bε(x) = (x — (x — a), x + (x — a)) C (a, x + (b — x)) = (a, b). (A.6)
</equation>
<bodyText confidence="0.99987675">
We have just proved that every set of the form (a, b) for real numbers a and
b is open. Note that this result still holds if the interval (a, b) is the empty
interval, i.e., if b &lt; a. The empty set is always trivially open since there are
no elements in it to be checked by the defining condition for open sets. The
result even holds if a = —oo or b = +oo. More generally, every open interval
in a totally ordered set is indeed open in the induced order topology.
We note that every ε-ball in lR,1 is of the form (x — ε, x + ε), hence an open
interval, hence open. This is part of a more general principle.
</bodyText>
<listItem confidence="0.87393">
(2) In lR,n, we may also define “open intervals” by setting
</listItem>
<bodyText confidence="0.5701055">
(a, b) = Ynι=1 (aι, bι) = fx E lR,n l aι &lt; xι &lt; bι for every 1 &lt; ι &lt; n}. (A.7)
Similar to the above case, we may choose
</bodyText>
<equation confidence="0.868345">
ε = minflx1 — a1l, lb1 — x1l,...,lxn — anl, lbn — xnl} (A.8)
</equation>
<page confidence="0.626161">
42
</page>
<figure confidence="0.55644775">
ε
x
X
A Topological Prerequisites A.1 Motivation and Examples
</figure>
<bodyText confidence="0.974903888888889">
and arrive at the insight that these open intervals are also open sets in the
topological sense. Again, we may allow for the a, and b, to be infinity (positive
or negative).
Contrary to the above, however, it is not the case that every ε-ball in 1R,&apos; is
an open interval, i.e., of the form (a, b) for some a, b ∈ 1R,&apos;. But nonetheless,
ε-balls are always open as we will see next.
(3) ε-neighborhoods in 1R,&apos; are open. This fact is due to the triangle inequality
which we already discussed above. Let x ∈ 1R,&apos; be any point and r &gt; 0 any
radius. We will show that the ball
</bodyText>
<equation confidence="0.948832666666667">
Br(x) = {y ∈ 1R,&apos;  |ky − xk &lt; r} (A.9)
is open in 1R,&apos;: Let y ∈ Br(x). Choose ε = r − ky − xk. It remains to show
that Bε(y) is a subset of Br(x). So, let z ∈ Bε(y), i.e.,
</equation>
<bodyText confidence="0.941523">
kz − yk &lt; r − ky − xk . (A.10)
Then, by the triangle inequality and (A.10),
kz − xk &lt;, kz − yk + ky − xk &lt; (r − ky − xk) + ky − xk = r (A.11)
</bodyText>
<figureCaption confidence="0.699688333333333">
and we are done, because this implies z ∈ Br(x). The proof is pictured in
Figure A.4.
Figure A.4.: ε-balls are open
</figureCaption>
<bodyText confidence="0.998713833333333">
We have defined the notion of an open set in Euclidean spaces and identified some
important classes of sets to be open. In the following, we will generalize the ideas
of this example to spaces that are equipped with some way of measuring distances.
These spaces are known as metric spaces. ❑
Metric spaces are an immediate generalization of Euclidean spaces. As with any
generalization, the idea is to purposely ignore certain aspects and properties of the
</bodyText>
<figure confidence="0.4683378">
Ily-xIl
y
r-Ily-xIl
x
r
</figure>
<page confidence="0.983353">
43
</page>
<bodyText confidence="0.980777133333333">
A Topological Prerequisites A.1 Motivation and Examples
object in question and focus on just a very limited number of properties that these
objects have in common. In our case, the important notion that generalizes Euclidean
spaces to metric spaces is that of distance. The idea is to forget everything we know
about the Euclidean norm 11.11 except that we may use it to define the distance of
two points x and y by taking the norm of their difference. Thus, we take the entity
“norm” and build a new machine out of it: A machine that takes two points as input
and outputs a number — their distance d(x, y).
After identifying a notion that lends itself to generalization, it is crucial to work
out which basic properties have to be attributed to it such that one can define the
notion by means of these properties. We already have listed these properties for our
case: Properties (1), (2), (3) from Example A.1 which we will use in the following
definition.
Definition A.1. Let X be a non-empty set and d : X x X --&gt; [0, oa) a function with
the following properties.
</bodyText>
<equation confidence="0.988859333333333">
(M1) d(x, y) = 0 holds if and only if x = y
(M2) d(x, y) = d(y, x) for all x, y E X
(M3) d(x, z) &lt; d(x, y) + d(y, z) for all x, y, z E X
</equation>
<bodyText confidence="0.997287">
Then we call d a metric on X and X a metric space. ❑
It will be the purpose of the next example to explore some properties of such
spaces. Note that metric spaces are an important special case of topological spaces.
In particular, execution spaces which will deliver our main results are in fact metric
spaces.
Example A.3 (Metric spaces). Let X denote a metric space throughout this exam-
ple. An ε-ball around x E X is again defined as
</bodyText>
<equation confidence="0.928017">
BE(x) = fy E X 1 d(x, y) &lt; ε}. (A.12)
</equation>
<bodyText confidence="0.994275272727273">
We also repeat the definition of an open set: A set A C X is called open if for
every x E A, there exists some ε &gt; 0 such that BE(x) C A. We could now repeat
the proof of the fact that every ε-ball is open from the previous example basically
word-by-word. But instead, we will explore properties that are a bit more advanced.
Let us begin by proving that every union of open sets is again open: Let Ap be
open sets for every ι in some non-empty index set I and denote their set-theoretic
union by A. We will show that A is open. For every x E A, by the definition of
union, there exists some ι0 such that x E Ap0. Now, because Ap0 is open, there exists
some ε &gt; 0 such that BE(x) C Ap0. But Ap0 C A means that we are done.
In particular, every union of balls is open. What is interesting now, is that the
converse also holds true: Every open set is a union of balls. To prove this, let A be an
</bodyText>
<page confidence="0.986676">
44
</page>
<bodyText confidence="0.646344333333333">
A Topological Prerequisites A.1 Motivation and Examples
open set. For any x ∈ A, denote by εx some positive number such that BE. (x) ⊂ A.
By definition of openness of A, these numbers do exist. We claim that
</bodyText>
<equation confidence="0.937577">
A = � BE. (x). (A.13)
x∈A
</equation>
<bodyText confidence="0.9498278">
It is clear that A is contained in the right-hand side of (A.13), because x is contained
in any ball around itself that has positive radius. For the opposing direction, note
that any ball that appears in the union is a subset of A by construction. Hence the
union itself is a subset of A, which concludes the proof. We have just glanced at
a very important notion: that of a basis of a topology. With this notion, we can
express the last result as: The balls form a basis of the topology that is induced by
the metric.
We may now ask, of course, if intersections of open sets are again open. Unfortu-
nately, this is not true in general as the following example shows: Let X = 1R, and
d(x, y) = |y − x|. The sets Ak = (−∞, 1/k) are all open. However, their intersection
</bodyText>
<equation confidence="0.649668285714286">
n∞ � �
k=1 (−∞, 1/k) = x ∈ 1R, |x &lt; 1 k for all k ∈ N = (−∞, 0] (A.14)
is not. The fact that (−∞, 0] is not open can be seen in the following way: Of course,
0 ∈ (−∞, 0]. But for every ε &gt; 0, we have ε/2 ∈ BE(0), while ε/2 ∈6 (−∞, 0], hence
the first is not a subset of the latter. A picture clarifying the situation is drawn in
−∞ E ε
0 2
</equation>
<figureCaption confidence="0.999037">
Figure A.5.: The set (−∞, 0] is not open
Figure A.5.
</figureCaption>
<bodyText confidence="0.906232615384616">
A finite intersection of open sets, however, is indeed again open as the following
reasoning shows: Let A1, A2, ... , Ak be open sets and let A denote their set-theoretic
intersection. We will show that A is open. So, as always, let x ∈ A. Since the Aj are
all open, there exist ε1, ε2, ... , εk such that BEB (x) ⊂ Aj for all 1 &lt; j &lt; k. We set
ε = min{ε1, ε2, ... , εk}. But then BE(x) ⊂ BEB (x) for every j and hence BE(x) ⊂ A
by definition of A.
By inspection of the preceding proof, we find the reason why it does not work in
the case of infinitely many sets: The infimum of infinitely many positive numbers
need not be positive. And this is exactly what happened in our counterexample:
If we choose x = 0, then the maximal possible εk such that BEk (0) is contained in
(−∞, 1/k) is equal to 1/k. If we now try to set ε as in the proof above, we get
ε = inf{εk  |k ∈ N} = inf{1/k  |k ∈ N} = 0 (A.15)
which is not an admissible radius in the definition of openness. ❑
</bodyText>
<page confidence="0.996811">
45
</page>
<figure confidence="0.8668495">
A Topological Prerequisites A.1 Motivation and Examples
A.1.2. Compactness in Rn
</figure>
<figureCaption confidence="0.959305375">
This subsection introduces the concept of compactness in the special case of the
Euclidean spaces lR,n and tries to communicate a bit of its importance in topology.
Compactness is a property of a subset of a topological space that can “make local
things global”. An example for this would be the well-known theorem “A continuous
real function defined on the interval [a, b] is uniformly continuous”. Here, the set
[a, b] is compact, continuity is a local property and uniform continuity is a global
property. We start with the
Definition A.2. A set C C lR,n is compact if it is bounded (i.e., there some ball
</figureCaption>
<bodyText confidence="0.857869">
with radius R &gt; 0 that contains C) and its complement is an open set. ❑
The most important property of compact sets is the following Theorem whose
proof’s insight-length ratio is too low to demonstrate it here.
Theorem A.1 (Heine-Borel). Let C C lR,n be compact. Further, let A, be a family
of open sets, indexed by some set I, that covers C, i.e.,
</bodyText>
<equation confidence="0.346899666666667">
C C � A, (A.16)
,∈I
Then there exists some finite subfamily A,1, A,2, ... , A,k that covers C, i.e.,
C C Uk A,j (A.17)
j=1
~
</equation>
<bodyText confidence="0.832845307692308">
This theorem can also hold as a definition of compactness: A subset of lR,n is
compact if and only if it satisfies the condition of Theorem A.1. The opposing
direction is not too hard to prove and is demonstrated in order to get some feeling
with the condition of Theorem A.1.
Lemma A.1. Let C C lR,n satisfy the condition of Theorem A.1, i.e., for every family
of open sets that covers C, there exists a finite subfamily that covers C. Then C is
compact.
Proof. We have to show that (1) C is bounded (i.e., there exists some real R &gt; 0
such that C C BR(0)) and (2) its complement lR,n \ C is open.
To prove (1), we choose the following family of open sets: The family of all balls
Br(0) where r &gt; 0 is a real number. We already know that these are open. Of
course, C is covered by this family of sets, because every x E C is contained in the
ball B211x11(0) for obvious reasons. By hypothesis now, there exists a finite subfamily
</bodyText>
<page confidence="0.99708">
46
</page>
<figure confidence="0.8106308">
A Topological Prerequisites A.1 Motivation and Examples
Br1 (0), Br2 (0), ... , Brk (0) that covers C. But these balls are subsets of the ball BR(0)
where R = max{r1, r2, ... , rk}. Hence
C C Uk BrS (0) C BR(0). (A.18)
j=1
</figure>
<bodyText confidence="0.640948">
For (2), we have to show that 1R,n \ C is an open set. So let x E 1R,n \ C. We define
for every ε &gt; 0 the following set
</bodyText>
<equation confidence="0.619124">
DE = {y E 1R,n  |d(x, y) &gt; ε} . (A.19)
</equation>
<bodyText confidence="0.9803768">
In order to use the condition of Theorem A.1, we have to prove that (a) all DE are
open and (b) C is covered by the DE.
Part (a) follows from the triangle inequality: Let y E DE, i.e., d(x, y) &gt; ε. We
have to find some δ &gt; 0 such that d(x, z) &gt; ε for all z with d(y, z) &lt; δ. We claim
that this is satisfied by δ = d(x, y) − ε. Let d(y, z) &lt; d(x, y) − ε, then
</bodyText>
<equation confidence="0.9367602">
d(x, z) &gt; d(x, y) − d(y, z) &gt; d(x, y) − (d(x, y) − ε) = ε, (A.20)
hence DE is open. Part (b) is obvious.
By hypothesis, there exist ε1, ε2, ... , εk such that C C Ukj=1 DES. By setting
ε = min{ε1, ε2, ... , εk} &gt; 0, we have C C DE and thus
BE(x) C 1R,n \ DE C 1R,n \ C (A.21)
</equation>
<bodyText confidence="0.9668371">
which shows that 1R,n \ C is open. ■
It is hoped that this proof has created some insight on the nature of the condition
of Theorem A.1. Most important and a major source of misunderstandings is the
following triviality: The condition does not claim that there has to exist some finite
family of open sets that covers C. This would be trivially fulfilled by any set since
1R,n as a subset of itself is an open set and covers any other. The condition reads that
any open covering of C, no matter how ugly it might look like, has to have a finite
subcovering. This observation is of utmost importance.
We will now proceed by showing the result announced in the introduction to this
subsection whose proof exemplifies the routinely used reasoning known as “compact-
ness argument”. For this, we recall some basic definitions from calculus.
Definition A.3 (Continuity). Let U be a subset of 1R, and f : U → 1R, a function.
The function f is called continuous at a point x E U if the following condition is
satisfied: For every ε &gt; 0 there exists some δ &gt; 0 such that x&apos; E U and |x − x&apos; |&lt; δ
implies |f (x) − f (x&apos;) |&lt; ε.
The function f is called continuous if f is continuous at every point x E U. ❑
Definition A.4 (Uniform continuity). Let U be a subset of 1R, and f : U → 1R, a
function. The function f is called uniformly continuous if the following condition is
satisfied: For every ε &gt; 0 exists some δ &gt; 0 such that x, x&apos; E U and |x − x&apos; |&lt; δ
implies |f (x) − f (x&apos;) |&lt; ε. ❑
</bodyText>
<page confidence="0.983068">
47
</page>
<bodyText confidence="0.952704461538462">
A Topological Prerequisites A.2 Topologies
Of course, uniform continuity implies continuity, but the converse is not true in
general as the example U = R and f (x) = x2 shows. Our goal for now, however,
will be to show that the converse does hold in a special case, namely that of compact
intervals. The set of compact real intervals is quite easy to determine: It is exactly
the set of bounded closed intervals [a, b]. The following proof is a most prototypical
compactness argument.
Theorem A.2 (Heine-Cantor). Let f : [a, b] → R be a function. If f is continuous,
then f is uniformly continuous.
Proof. We will use Theorem A.1. Let ε &gt; 0. Since f is continuous, there exists a
δx &gt; 0 for every x ∈ [a, b] such that |x − x&apos; |&lt; δx implies |f (x) − f (x&apos;) |&lt; ε/2. The
condition |x − x&apos; |&lt; δx can be reformulated as x&apos; ∈ Bδ. (x). Since every δx is greater
than zero, we have
</bodyText>
<equation confidence="0.575214833333333">
[a, b] ⊂ U Bδ./2(x) (A.22)
xE[a,b]
which means that the family Bδ. (x) is an open covering of the interval [a, b]. By
Theorem A.1, there exist x1, x2, ... , xk such that
[a, b] ⊂ Uk Bδ.i /2(xj ). (A.23)
j=1
</equation>
<bodyText confidence="0.982484">
Let δj = δxi. If we now set δ = min{δ1, δ2, ... , δk}/2, we are done:
Let x, x&apos; ∈ [a, b] and |x − x&apos; |&lt; δ. There exists some j such that x ∈ Bδi/2(xj). By
the triangle inequality, x, x&apos; ∈ Bδ(x) ⊂ Bδi/2(x) ⊂ Bδi (xj). We can hence use the
definition of δj and conclude
</bodyText>
<equation confidence="0.877741333333333">
~ ~~ &lt; ε
~f(x) − f(x&apos;) ~~ � |f(x) − f(xj) |+ ~~f(xj) − f(x&apos;) 2 + ε2 = ε. (A.24)
■
</equation>
<sectionHeader confidence="0.891638" genericHeader="method">
A.2. Topologies
</sectionHeader>
<bodyText confidence="0.966166">
This section formally defines the notion “topology” resp. “topological space” and
introduces basic properties.
</bodyText>
<subsectionHeader confidence="0.845927">
A.2.1. Open Sets and Neighborhoods
</subsectionHeader>
<bodyText confidence="0.855973">
Without further ado, finally, the fundamental
Definition A.5 (Topological space). Let X be a non-empty set. A set T ⊂ P(X)
is called a topology on X if it satisfies the following properties.
</bodyText>
<footnote confidence="0.442108">
(O1) Every union of sets in T is an element of T .
</footnote>
<page confidence="0.990264">
48
</page>
<figure confidence="0.671943333333333">
A Topological Prerequisites A.2 Topologies
(O2) Every finite intersection of sets in J is an element of J .
(O3) 0 E J and X E J
</figure>
<bodyText confidence="0.991089363636364">
In this case, X is called a topological space. The sets O E J are called open sets. ❑
To be precise, property (O3) could be omitted from the definition since U 0 = 0
and n 0 = X by convention.
This definition is indeed a generalization of the notion of openness as defined in
Section A.1. We have defined the notion of openness two times now: One time in
the language of metric spaces and one time in the language of topological spaces.
We also mentioned that every metric space is also a topological space. This can be
done, given a metric d on the space X, by the following definition:
J = fO C X for every x E O there is some ε &gt; 0 such that Bε(x) C O} (A.25)
We proved in the language of metric spaces (O1) that arbitrary unions of open sets
are again open and (O2) that finite intersections of open sets are open.
</bodyText>
<figure confidence="0.493307666666667">
Example A.4. We will now give some examples of topologies in simple settings.
(1) The trivial topology exists on any non-empty set X. It is defined as J = f0, X}.
(2) The discrete topology also exists on any non-empty set X. It is defined as
J = P(X), i.e., the power set of X.
(3) On a two-element set X = fa, b}, there are four different topologies, namely
f0, fa, b}}, f0, fa}, fa, b}}, f0, fb}, fa, b}}, f0, fa}, fb}, fa, b}}. (A.26)
</figure>
<figureCaption confidence="0.7821688">
(4) There are 29 different topologies on a three-element set X = fa, b, c}, see
Figure A.6. From there on, it gets complicated: 355 topologies on four-element
sets, 6942 on five-element sets, 209527 on six-element sets, 9535241 on seven-
element sets, 642779354 on eight-element sets and so on.
(5) Any topology in which all singleton sets fx} are open, is the discrete topology
</figureCaption>
<bodyText confidence="0.616421">
by (O1). ❑
In Section A.1, we gave a number of examples of open sets, in particular we showed
that specific sets that we called “neighborhoods” or “balls” are open. We will now
generalize the notion of neighborhood and show some fundamental properties.
Definition A.6 (Neighborhood). Let X be a topological space and x E X. A set
N C X is called a neighborhood of x if there exists an open set O C X such that x E O
and O is contained in N, i.e., O C N. We will denote the set of all neighborhoods
of x by -4&apos; (x). ❑
</bodyText>
<page confidence="0.996341">
49
</page>
<figure confidence="0.405822">
A Topological Prerequisites A.2 Topologies
</figure>
<tableCaption confidence="0.938351166666667">
f0, X}, f0, fa}, X}, f0, fb}, X}, f0, fc}, X},
f0, fa, b}, X}, f0, fa, c}, X}, f0, fb, c}, X},
f0, fa}, fb, c}, X}, f0, fb}, fa, c}, X}, f0, fc}, fa, b}, X},
f0, fa}, fa, b}, X}, f0, fb}, fa, b}, X}, f0, fa}, fa, c}, X},
f0, fc}, fa, c}, X}, f0, fb}, fb, c}, X}, f0, fc}, fb, c}, X},
f0, fa}, fb}, fa, b}, X}, f0, fb}, fc}, fb, c}, X},
f0, fa}, fc}, fa, c}, X}, f0, fa}, fa, b}, fa, c}, X},
f0, fb}, fa, b}, fb, c}, X}, f0, fc}, fa, c}, fb, c}, X},
f0, fa}, fb}, fa, b}, fb, c}, X}, f0, fb}, fc}, fa, b}, fb, c}, X},
f0, fa}, fc}, fa, c}, fb, c}, X}, f0, fb}, fc}, fa, c}, fb, c}, X},
f0, fa}, fb}, fa, b}, fa, c}, X}, f0, fa}, fc}, fa, b}, fa, c}, X},
f0, fa}, fb}, fc}, fa, b}, fb, c}, fa, c}, X}
</tableCaption>
<figureCaption confidence="0.981398">
Figure A.6.: The 29 topologies on the set X = fa, b, c}
</figureCaption>
<bodyText confidence="0.9996715">
We note that, in particular, every open set is neighborhood of any of its points.
Simple consequences of the definition are:
</bodyText>
<listItem confidence="0.92650225">
(1) If N E ✓&apos; (x) and M D N, then M E ✓&apos; (x). In particular, every union of
neighborhoods of x is a neighborhood of x.
(2) Every finite intersection of neighborhoods of x is a neighborhood of x.
(3) x E N for all N E ✓&apos; (x).
Properties (1) and (2) justify the name neighborhood filter for the set ✓&apos; (x). A less
trivial result is the following.
(4) For every N E ✓&apos; (x) there exists some M E ✓&apos; (x) such that N E ✓&apos; (y) for
all y E M, i.e., N is is a neighborhood of all points in M.
</listItem>
<bodyText confidence="0.999531875">
Of course, any such M has to be a subset of N. It is sufficient to take M to be
the open set containing x as demanded in the definition of a neighborhood. In
fact, it is possible to take the notion of neighborhood as the primary notion in the
definition of a topology, as opposed to taking the notion of openness as we did in
Definition A.5. More precisely, open sets are characterized as being those sets that
are neighborhoods of all their points. This allows to define the notion of an open set
in terms of neighborhoods. Now, given a family ✓&apos; (x) indexed by x E X with the
above properties (1) to (4), we may define the family
</bodyText>
<equation confidence="0.689635">
J = fO C X  |O E ✓&apos; (x) for all x E X} (A.27)
</equation>
<bodyText confidence="0.904615">
which, because the ✓&apos; (x) satisfy properties (1) to (4), is a topology on X such that
✓&apos; (x) is exactly the set of neighborhoods of x with respect to this topology J .
</bodyText>
<page confidence="0.893393">
50
</page>
<figure confidence="0.405675">
A Topological Prerequisites A.2 Topologies
Example A.5 (Neighborhoods in metric spaces). Let X be a metric space and
</figure>
<equation confidence="0.7097825">
x E X. We will characterize the set N (x) C P(X), more precisely we show
N (x) = fN E P(X) 1 there exists some ε &gt; 0 such that Bε(x) C N} . (A.28)
</equation>
<bodyText confidence="0.945425393939394">
Let N be a neighborhood of x. We want to show that N is an element of the
right-hand side of (A.28). By definition, there exists some open set O C N that
contains the point x. Recalling what it means for a set to open in a metric space,
we conclude the existence of some ε &gt; 0 such that Bε(x) C O C N. Conversely, if
N is an element of the right-hand side of (A.28), then we may set O = Bε(x) in the
definition of neighborhood since Bε(x) is open. ❑
We will now define what it means for a sequence in X to converge to a point.
Definition A.7 (Convergence). Let X be a topological space and (xk)k∈N E XN a
sequence in X. We say that (xk) converges to the point x E X if for every neighbor-
hood N of x, there exists some integer K E N such that for every k &gt; K, xk E N.
In this case, x is called limit point of (xn) and (xn) is called convergent. ❑
Compare this definition to the definition of convergence in metric spaces: The
sequence (xk) converges to x if “for all ε &gt; 0 there exists some integer K E N such
that for every k &gt; K, xk E Bε(x)”. The generalization of Definition A.7 is that the
prototypical neighborhoods Bε(x) were replaced by arbitrary neighborhoods of x.
One fact we recall from Example A.3 is that in the case of a metric space X, every
open set is the union of ε-balls. In such a case, we call the set of ε-balls a basis of
the topology. More specifically, a basis B of a topology T on X is a set of subsets
of X such that every open set O E T is a union of elements of B. Trivially, the
topology itself is always a basis. A special case occurs when there exists a countable
basis B of a topology. These spaces are called second countable or AA2 spaces.
Euclidean spaces 1R,n have a basis consisting of the ε-balls. But they even are AA2
spaces since the set of balls with rational radius and rational center also form a basis
of the Euclidean topology, i.e.,
B = fBε(x) C 1R,n 1 x E Qn and ε E Q fl (0, oo)} . (A.29)
This set B is countable by Cantor diagonalization.
AA2 spaces are spaces in which it suffices to use the term “sequence”, i.e., a
mapping N --&gt; X, when talking about convergence. In other spaces it might be too
restrictive for its notion of convergence that the domain N of the sequence is just
countable. We would have to generalize sequences to either nets or filters, the former
being mappings Λ --&gt; X where Λ is not necessarily countable, but has to carry an
additional structure; that of a directed set1. If this is not done, popular theorems
such as “A map F : X --&gt; Y is continuous if and only if for each sequence xk in
</bodyText>
<footnote confidence="0.827587">
1A directed set is a set Λ together with a preorder (reflexive and transitive relation) -&lt; on Λ such
that for every λ and µ in Λ, there exists a ν such that λ -&lt; ν and µ -&lt; ν.
</footnote>
<page confidence="0.99257">
51
</page>
<subsubsectionHeader confidence="0.312691">
A Topological Prerequisites A.2 Topologies
</subsubsectionHeader>
<bodyText confidence="0.9880623">
X converging to x, the sequence f (xk) converges to f (x)” would be plainly false.
It is true in any topological space, however, if the word “sequence” is replaced by
“net”. But the introduction of this generalization has a few complications attached
to it. For example, it need not be the case that a net has only one limit, but it
may have multiple. There even exist nets that converge to every point in the space.
Nevertheless, we will not take on the endeavor to explore the theory in this direction
since the spaces we will look at do not have this inconvenience.
We call a topological space Hausdorff if for every two distinct points x and y,
there exist neighborhoods Nx and Ny of x and y, respectively, such that Nx n Ny = 0.
Metric spaces are Hausdorff.
</bodyText>
<sectionHeader confidence="0.232454" genericHeader="method">
A.2.2. Closure, Interior, Boundary, Density
</sectionHeader>
<bodyText confidence="0.832065545454545">
This subsection introduces accompanying notions for talking about topological
spaces.
Definition A.8 (Closure). Let X be a topological space. A set A C X is called
closed if it is the complement of an open set, i.e., if X \ A is open.
The closure of a set B C X, denoted by B, is the least (with respect to set inclusion)
closed set that contains B as a subset. ❑
The first question that arises here is, of course, whether the notion of closure is
indeed well-defined. To be more precise, the question is whether there does exist a
least closed set that contains B for every B C X. Before we answer this question in
the affirmative, we collect some simple facts:
Lemma A.2. Let X be a topological space. The following assertions are true.
</bodyText>
<listItem confidence="0.949153333333333">
(1) Every finite union of closed sets is closed.
(2) Every intersection of closed sets is closed.
(3) 0 and X are both closed.
</listItem>
<bodyText confidence="0.995496">
Proof. We show (1): Let A1, A2, ... , An be closed sets, i.e., the X \ Aj are open.
With use of De Morgans law,
</bodyText>
<equation confidence="0.337845714285714">
X \ Aj (A.30)
which is open by defining property (O2).
Part (2) is proved just as easy. Let Ai be an arbitrary family of closed set indexed
by i E I. Again, De Morgans law yields
� �Ai = X \ Ai (A.31)
X \ i∈I
i∈I
</equation>
<bodyText confidence="0.8677585">
and property (O1) tells that we are done.
The sets 0 and X are closed since they are open and each other’s complement. ■
</bodyText>
<page confidence="0.981782">
52
</page>
<figure confidence="0.988112714285714">
Un
j=1
X \
nn
j=1
Aj =
A Topological Prerequisites A.2 Topologies
</figure>
<bodyText confidence="0.9833815">
Note the duality of these assertions and the condition on open sets in the definition
of a topology. It is possible to define the notion of a topology by defining what sets
should be closed, as opposed to defining what sets should be open as in Definition A.5.
The properties that a family of sets has to fulfill such that it appears as the family
of closed sets of some topology are exactly the assertions of Lemma A.2.
The question whether the notion of closure is actually well-defined for any set
</bodyText>
<figure confidence="0.7062275">
B C X follows from the fact every intersection of closed sets is again closed. More
precisely,
�
B = fA C X 1 A is closed and B C Al , (A.32)
</figure>
<bodyText confidence="0.748265888888889">
i.e., the closure of B is equal to the intersection of all closed sets A that contain
B. The set on right-hand side of (A.32) is closed by (2) of Lemma A.2 and is of
course contained in every other closed set by definition of intersection. Hence we
constructed B for every B C X.
For spaces in which sequences suffice to build a proper notion of convergence, in
particular in AA2 spaces (see Section A.2.1), the following important characterization
of closure holds:
Lemma A.3. Let X be an AA2 space and B C X. Then the closure of B is equal
to the set of limit points that sequences in B have, i.e.,
</bodyText>
<equation confidence="0.649931">
B = Ix E X 1 there exists a sequence (xk)k∈IN E BIN with xk --&gt; x} . (A.33)
</equation>
<bodyText confidence="0.92205815">
Proof. We first prove that B is contained in the right-hand side R. It suffices to show
that the right-hand side is closed and contains B as a subset. The latter claim is
clear since every x E B is limit of the constant sequence (x)k∈IN. We show closedness
by contradiction. Suppose that X \ R is not open. Then, by definition, there exists
some x E X \ R such that for every neighborhood N of x, we have N n R =74 0. We
will construct a sequence of points in B that converges to x, deriving the desired
contradiction.
In a first step, we will show that there exists a sequence of points in R that
converges to x and then show how this implies the claim. By hypothesis, there exists
some countable basis B of the topology. Let (Nk)k∈IN denote the family of basis sets
that contain x. It is easy to show that for every neighborhood N of x, there exists
a k E N such that Nk C N. Now, for every k E N, let xk be an arbitrary point
in R n nki=1 Ni (which is non-empty, see above). This is a sequence of points in R
that converges to x. For let N E N (x), then there exists some K E N such that
NK C N. Hence for any k &gt; K, we have xk E nki=1 Ni C NK C N which shows
xk --&gt; x.
To show that the existence of a sequence in R converging to x implies the existence
of a sequence in B converging to x, we take for every point xk E R from the above
construction a sequence (ξk,j)j∈IN E BIN converging to xk. These sequences exist by
the definition of R. We claim that the following sequence yk converges to x. The set
</bodyText>
<page confidence="0.991627">
53
</page>
<bodyText confidence="0.724511666666667">
A Topological Prerequisites A.2 Topologies
nk i=1 Ni containing xk and being open, there exists some index jk E N such that for
all j &gt; jk, ξk,j E nki=1 Ni. We define
</bodyText>
<equation confidence="0.825422">
yk = ξk,jk E B n nk Ni (A.34)
i=1
</equation>
<bodyText confidence="0.9808855">
which obviously converges to x. This is a contradiction and we have shown B C R.
The converse direction R C B is much easier. Suppose that there exists some
x E R \ B. Because x lies in the open set X \ B, there exists some neighborhood N
of x such that
</bodyText>
<equation confidence="0.944087">
N C X \ B C X \ B. (A.35)
</equation>
<bodyText confidence="0.993079111111111">
But this relation denies the existence of a sequence in B converging to x, which
contradicts the assumption. ■
It is also possible to define a topological space in terms of its closure operator,
i.e., the map P(X) → P(X) that takes a set A C X to its closure. We can retain
the topology from the closure operator, because a set A C X is closed if and only if
A = A. The axioms needed to define the family of closed sets of a topology by the
above procedure are the following:
Lemma A.4. Let X be a topological space and let C : P(X) → P(X) be its closure
operator. The following assertions are true for any A, B C X:
</bodyText>
<listItem confidence="0.9333695">
(1) C(0) = 0
(2) A C C(A)
(3) C(C(A)) = C(A)
(4) C(A U B) = C(A) U C(B)
</listItem>
<bodyText confidence="0.916724888888889">
Proof. (1) is clear since 0 is a closed set. (2) and (3) are immediate consequences
of the definition of closure. We will now prove (4). The inclusion C(A U B) C
C(A)UC(B) is a consequence of the fact that C(A)UC(B) is closed by Lemma A.2(1)
and of course contains both A and B as subsets. For the other inclusion, we note
that it is sufficient to show C(A) C C(A U B) which is clear since A C A U B. ■
Dual to the notion of closure is that of interior, as defined next.
Definition A.9 (Interior). Let X be a topological space and A C X. We call the
(with respect to set inclusion) greatest open set that is contained in A the interior
of A, denoted by A◦. ❑
</bodyText>
<page confidence="0.948635">
54
</page>
<bodyText confidence="0.807535">
A Topological Prerequisites A.2 Topologies
As with closure, we have to check that this is a well-defined notion, i.e., that A°
exists for all A C X. This follows from the formula
</bodyText>
<equation confidence="0.840611">
�
A° = fB C X 1 B is open and B C A} . (A.36)
</equation>
<bodyText confidence="0.9229425">
A set A C X is open if and only if A° = A. The important properties of the interior
operator P(X) --&gt; P(X), A 7--&gt; A° are:
Lemma A.5. Let X be a topological space and let I : P(X) --&gt; P(X) be its interior
operator. The following assertions are true for any A, B C X:
</bodyText>
<listItem confidence="0.9902145">
(1) I(X) = X
(2) I(A) C A
(3) I(I(A)) = I(A)
(4) I(A n B) = I(A) n I(B)
</listItem>
<bodyText confidence="0.997091823529412">
Proof. (1) holds because the set X is open by definition, (2) and (3) are obvious. To
prove (4), we show both set inclusions. The inclusion from I(A n B) C I(A) n I(B)
is true, because A n B C A and A n B C B. We now show I(A) n I(B) C I(A n B).
The set I(A) n I(B) is open and contained in both A and B, hence contained in
A n B. The claim now follows from the definition of interior. ■
The notions of closure and interior are connected by the following formula
A° = (Ac)c , A = ((Ac)°)c (A.37)
where Bc = X \ B denotes the complement of B C X.
Example A.6 (Intervals). We will demonstrate the use of the notions interior and
closure with real intervals. The interior and the closure of an interval do not depend
on whether the boundary points belong to the interval or not. More precisely, the
interiors of (a, b), (a, b], [a, b) and [a, b] are all equal to (a, b) and their closures are all
equal to [a, b]. It follows from the fact that (a, b) is open, [a, b] is closed and neither
(a, b] nor [a, b) are open or closed. ❑
We may generalize this situation and identify for any set A C X a set of points
for which it does not matter whether they are added or removed when considering
interior and closure.
</bodyText>
<equation confidence="0.7394135">
Definition A.10 (Boundary). Let X be a topological space and A C X. We call
∂A = A \ A° the boundary of A. ❑
</equation>
<bodyText confidence="0.968224666666667">
We state the following observations.
Lemma A.6. Let X be a topological space and let A C X. The following statements
are true.
</bodyText>
<page confidence="0.968854">
55
</page>
<figure confidence="0.825520607142857">
A Topological Prerequisites A.2 Topologies
(1) ∂A = {x ∈ X  |for all N ∈ ✓V (x) it is N ∩ A =6 ∅ and N ∩ AC =6 ∅}
(2) ∂A = ∂(AC)
(3) (A \ ∂A)° = A°
(4) A ∪ ∂A = A
(5) ∂A is closed
(6) A = A ∪ ∂A. In particular, A is closed if and only if ∂A ⊂ A.
(7) A° = A \ ∂A. In particular, A is open if and only if ∂A ∩ A = ∅.
Proof. (1): From the definition and equation (A.37), we deduce ∂A = AC°C \ A° =
AC°C ∩ A°C. It hence suffices to show
A°C = {x ∈ X  |for all N ∈ ✓V (x) it is N ∩ AC =6 ∅} . (A.38)
But this is trivially equivalent (by taking complements) to
A° = {x ∈ X  |there exists some N ∈ ✓V (x) such that N ∩ AC = ∅} . (A.39)
which is true, because the relation N ∩ AC = ∅ is the same as the relation N ⊂ A.
(2) is a trivial consequence of (1).
(3): After a simple calculation involving De Morgan’s law and R \ S = R ∩ SC, we
arrive at the equation
(A \ ∂A)° = (A ∩ (AC ∪ A°))° (A.40)
which by Lemma A.5(4) is equal to
A° ∩ (AC ∪ A°)° (A.41)
Since A° ⊂ AC ∪ A° and A°° = A°, we get
(A \ ∂A)° ⊃ A° ∩ A° = A° (A.42)
and we are done, the other inclusion being trivial.
(4) follows from (2), (3) and (A.37) as the following calculation shows:
A ∪ ∂A = (A ∪ ∂A)C°C = (AC ∩ (∂A)C)°C (A.43)
= (AC \ ∂ (AC))°C = AC°°C = AC°C = A (A.44)
(5) is clear since ∂A = A ∩ A°C is an intersection of two closed sets.
(6) and (7) are simple calculations. ■
</figure>
<footnote confidence="0.638058333333333">
We now turn to a different notion that is derived from the notion of closure, namely
density. Informally, we will call a set dense if every point in the space is arbitrarily
close to a point of the dense set. The formal definition follows now.
</footnote>
<page confidence="0.983616">
56
</page>
<figure confidence="0.74194575">
A Topological Prerequisites A.2 Topologies
Definition A.11 (Density). Let X be a topological space and A C X. We call A
Bense in X if the closure of A in X is equal to X, i.e., A = X. ❑
Equivalent statements are summarized in the next
</figure>
<reference confidence="0.664136625">
Lemma A.7. Let X be a topological space and A C X. The following statements
are equivalent:
(1) A is dense in X.
(2) For every non-empty open set O C X it follows that A n O =74 0.
(3) For every neighborhood N of a point x E X it follows that A n N =74 0.
Proof. The equivalence (2)q(3) is trivial. Let A be dense and suppose that (2) does
not hold. Then there exists a non-empty open set O with A C Oc where Oc denotes
X \O. But since Oc =74 X and Oc is closed, we deduce A =74 X which is a contradiction.
Conversely, let (2) hold and suppose that A = C =74 X. But then the complement of
C is non-empty, open, and has trivial intersection with A. Contradiction. ■
Example A.7. The set Q C R is dense: Let N C R be a neighborhood of some
x E R. Then, by definition, there exists some ε &gt; 0 such that Bε(x) C N. The
decimal expansion of x yields a sequence (qk) that converges to x. This implies that
there exists some K E N such that qK E Bε(x) C N. The claim follows because, by
construction, qK E Q. ❑
A.2.3. Continuity
</reference>
<bodyText confidence="0.953046266666667">
In the previous sections, we studied the objects “topological spaces”. It is the purpose
of this section to deal with “morphisms” of such objects, i.e., functions between
topological spaces that preserve the topological structure. We will then have laid the
ground to study the category of topological spaces (Herrlich and Strecker 1973).
Definition A.12 (Continuity). Let X and Y be topological spaces. Furthermore,
let f : X --&gt; Y be a function. We call f continuous if for every open set O C Y , it
follows that its inverse image f —1[O] is open in X. ❑
By taking complements and recalling f —1[Y \ A] = X \ f —1[A] for all A C Y , we
arrive at the insight that f is continuous if and only if f —1[C] is closed in X for every
set C that is closed in Y .
Example A.8. Let X be a set equipped with the discrete topology. Then every
map f : X --&gt; Y is continuous, because every subset of X is open. Conversely, if Y
is equipped with the trivial topology, i.e., only 0 and Y are open, then again every
map f : X --&gt; Y is continuous, because f —1[0] = 0 and f —1[Y ] = X which are in any
case open in X. ❑
</bodyText>
<page confidence="0.987465">
57
</page>
<figure confidence="0.362313">
A Topological Prerequisites A.2 Topologies
</figure>
<bodyText confidence="0.991360217391304">
If Y a topological space and X is any non-empty set, we may ask ourselves with
which topology we must equip X such that a given mapping f : X → Y becomes
continuous. Of course, we want to do this in the most general fashion, i.e., we do
not want to add too many open sets to the to be defined topology on X, just enough
to make f continuous. We are obliged to have sets of the form f —1[O] where O ⊂ Y
is open as open sets in X. But by recalling all those useful properties of the inverse
image, it also turns out that these sets are enough: The sets of the above form f —1[O]
form a topology on X with respect to which f is continuous. We call this topology
on X the initial topology with respect to f : X → Y .
Example A.9 (Subspace topology). If X ⊂ Y and Y is equipped with a topology,
we may consider the inclusion map ι : X ,→ Y , i.e., ι(x) = x for all x ∈ X, and
equip X with the initial topology with respect to ι. We call this topology on X the
subspace topology inherited from Y . The open sets of X are exactly the sets X ∩ O
where O ⊂ Y is open. ❑
We may well go the opposite direction and ask, given a mapping f : X → Y where
X is a topological space and Y is an arbitrary non-empty set, which topology on Y
makes f continuous and has the least number of open sets. This time, it turns out
that indeed the sets A ⊂ Y such that f—1[A] ⊂ X is open form a topology on Y .
This topology on Y is called the final topology with respect to f : X → Y .
We have already seen a notion called “continuity” in Definition A.3 where we
defined it for maps U → R where U ⊂ R. It would be embarrassing if those notions
would not agree for maps U → R. Luckily, the following lemma holds.
Lemma A.8. Let U ⊂ R and f : U → R. The following are equivalent:
</bodyText>
<listItem confidence="0.763219166666667">
(1) f is continuous with respect to Definition A.3.
(2) f is continuous with respect to Definition A.12 (where U is equipped with the
subspace topology inherited from R).
Proof. (1)⇒(2): Let O ⊂ R be non-empty and open. Let x ∈ f—1[O]. Then there
exists some ε &gt; 0 such that BE(f(x)) ⊂ O since O is open. But now, by (1), there
exists some δ &gt; 0 such that y ∈ Bö(x) implies f (y) ∈ BE(f (x)), i.e.,
</listItem>
<equation confidence="0.78344">
Bö(x) ⊂ f—1[BE(f(x))] ⊂ f—1[O]. (A.45)
(2)⇒(1): Let x ∈ U and ε &gt; 0. The set BE(f (x)) is open in R. Hence also
f —1[BE(f (x))] is open. Hence there exists some δ &gt; 0 such that
Bö(x) ⊂ f—1[BE(f(x)). (A.46)
</equation>
<bodyText confidence="0.967859">
But this implies the condition of (1). ■
</bodyText>
<page confidence="0.973066">
58
</page>
<figure confidence="0.5097185">
A Topological Prerequisites A.2 Topologies
A.2.4. Compactness
</figure>
<bodyText confidence="0.9710415">
We briefly discussed compactness in Section A.1.2 for the case of subsets of Rn. Since
we do not have the notion of distance and hence boundedness in general topolog-
ical spaces, the idea is to take the conclusion of Theorem A.1 as the definition of
compactness. Below, we collect the most important facts about compact sets.
</bodyText>
<reference confidence="0.548952666666667">
Definition A.13 (Compactness). Let X be a topological space. We call X compact
if for any collection (Aι)ι∈I of open sets for which X = U Aι, there exists some n E N
and ι1, ... , ιn such that X = Unk=1 Aιk. We call a subset A of a topological space
compact if A is compact with respect to the subspace topology inherited from X. ❑
Example A.10. A space equipped with the discrete topology is compact if and only
if it is finite. This follows easily because all singleton sets fx} are open in discrete
spaces. ❑
Lemma A.9. Let X be a topological space and A C X. The following assertions
are true:
</reference>
<listItem confidence="0.945136">
(1) If X is compact and A is closed, then A is compact.
(2) If X is Hausdorff and A is compact, then A is closed.
Proof. (1): For any open cover (Aι) of A, the family (Aι) together with the open set
X \ A is an open cover of X. Since X is compact, there exist finitely many indicesι1,..., ιn such that X = Unk=1 Aιk U (X \ A). By intersecting both sides with A, we
arrive at A = Unk=1 Aιk which shows that A is compact.
</listItem>
<bodyText confidence="0.999144666666667">
(2): We show that the complement of A is open. Let x E X \ A. By the Hausdorff
property, for every y E A, there exist disjoint open sets U(y) and V (y) such that
y E U(y) and x E V (y). The family U(y) where y E A is an open covering of
A. Because A is compact, there exist y1, ... , yn such that A = Uni=1 U(yi). Setting
V = nni=1 V (yi) reveals that V is an open neighborhood of x ((O2) in Definition A.5)
which is disjoint to A, hence V C X \ A. This proves that X \ A is open, i.e., A is
</bodyText>
<sectionHeader confidence="0.370768" genericHeader="method">
closed. ■
</sectionHeader>
<reference confidence="0.803986125">
Lemma A.10. Let f : X → Y be continuous and let X be compact. Then f [X] is
compact.
Proof. Follows immediately from the definitions. ■
Lemma A.11. Let X be a compact space and f : X → R continuous. Then f
attains its minimum, i.e., there exists some x E X such that
f (x) = infff (y)  |y E X}. (A.47)
Proof. By Lemma A.10, the image f [X] is a compact set in R. By Lemma A.9, this
set is closed. We may deduce the result from order completeness of R.2 ■
</reference>
<footnote confidence="0.792996">
2For every set B ⊂ R which is bounded from below, the infimum of B exists in R.
</footnote>
<page confidence="0.940139">
59
</page>
<figure confidence="0.524729">
A Topological Prerequisites A.2 Topologies
</figure>
<reference confidence="0.798250555555556">
A.2.5. Product Spaces
In this section, we will answer the question, which topology is “natural” to equip a
product space X = fl X, with when all X, are topological spaces. We do this by
considering the projection mappings 7r, : X -* X, and equipping X with a slight
generalization of the initial topology. Namely, we will have to make all projection
mapping continuous, not only one. This is done with the following
Definition A.14. Let (X,) be a family of topological spaces and let X = X, be
the set-theoretic product. We call the topology induced by sets of the form 7r−1
, [O]
</reference>
<bodyText confidence="0.9245218">
where O ⊂ X, is open the product topology on X. ❑
A most important result that we do not prove here for space limitations is the
following (Bourbaki 1989, Chapter I, §9, no. 5, Theorem 3).
Theorem A.3 (Tychonoff). Let X = X, be equipped with the product topology.
The following are equivalent:
</bodyText>
<equation confidence="0.807347">
(1) X is compact.
</equation>
<reference confidence="0.43303">
(2) All X, are compact. ❑
</reference>
<page confidence="0.982048">
60
</page>
<sectionHeader confidence="0.954487" genericHeader="method">
Bibliography
</sectionHeader>
<reference confidence="0.999841931034483">
Alpern, Bowen and Fred B. Schneider. Defining liveness. Technical Report TR85-650,
Cornell University, 1985.
Attiya, Hagit and Jennifer Welch. Distributed Computing: Fundamentals, Simula-
tions, and Advanced Topics. John Wiley &amp; Sons, second edition, 2004.
Bourbaki, Nicolas (pseudonym). General Topology, Chapters 1–4. Elements of Math-
ematics. Springer, 1989.
Charron-Bost, Bernadette, Sam Toueg, and Anindya Basu. Revisiting safety and
liveness in the context of failures. In Proceedings of CONCUR 2000—Concurrency
Theory, pages 552–565. Springer, 2000.
Dolev, Danny, Cynthia Dwork, and Larry Stockmeyer. On the minimal synchronism
needed for distributed consensus. Journal of the ACM 34(1):77–97, 1987.
Fich, Faith and Eric Ruppert. Hundreds of impossibility results for distributed
computing. Distributed Computing 16(2):121–163, 2003.
Fischer, Michael J., Nancy A. Lynch, and Michael S. Paterson. Impossibility of
distributed consensus with one faulty process. Journal of the ACM 32(2):374–
382, 1985.
Hatcher, Allan. Algebraic Topology. Cambridge University Press, 2002.
Herlihy, Maurice and Sergio Rajsbaum. Algebraic spans. Mathematical Structures
in Computer Science 10(4):549–573, 2000.
Herlihy, Maurice and Nir Shavit. The asynchronous computability theorem for t-
resilient tasks. In Proceedings of the 25th Annual ACM Symposium on Theory of
Computing, pages 111–120. 1993.
Herrlich, Horst and George E. Strecker. Category Theory: An Introduction. Allyn
and Bacon, 1973.
Lamport, Leslie. Proving the correctness of multiprocess programs. IEEE Transac-
tions on Software Engineering SE-3(2):125–143, 1977.
Lubitch, Ronit and Shlomo Moran. Closed schedulers: A novel technique for ana-
lyzing asynchronous protocols. Distributed Computing 8(4):203–210, 1995.
Lynch, Nancy A. Distributed Algorithms. Morgan Kaufmann, 1996.
</reference>
<page confidence="0.744213">
61
</page>
<reference confidence="0.9881734">
Bibliography Bibliography
Moses, Yoram and Sergio Rajsbaum. A layered analysis of consensus. SIAM Journal
on Computing 31(4):989–1021, 2002.
Saks, Michael and Fotios Zaharoglou. Wait-free k-set agreement is impossible: The
topology of public knowledge. SIAM Journal on Computing 29(5):1449–1483,
2000.
Santoro, Nicola and Peter Widmayer. Time is not a healer. In Proceedings of the 6th
Annual Symposium on Theoretical Aspects of Computer Science, pages 304–313.
Springer, 1989.
Spanier, Edwin H. Algebraic Topology. McGraw-Hill, 1966.
</reference>
<page confidence="0.99025">
62
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.010427">
<title confidence="0.934432375">Topology in Distributed Computing DIPLOMARBEIT zur Erlangung des akademischen Grades Diplom-Ingenieur im Rahmen des Studiums Technische Informatik ausgeführt von</title>
<author confidence="0.998629">Thomas Nowak</author>
<address confidence="0.626427">Matrikelnummer 0425201</address>
<author confidence="0.762828">an der</author>
<affiliation confidence="0.655206">Fakultät für Informatik der Technischen Universität Wien</affiliation>
<address confidence="0.679288">Betreuer: Univ.Prof. Dr. Ulrich Schmid Wien, 18.03.2010</address>
<affiliation confidence="0.715125">(Unterschrift Verfasser) (Unterschrift Betreuer) Technische Universität Wien</affiliation>
<address confidence="0.624929">Wien 13 +43/(0)1/58801-0 http://www.tuwien.ac.at</address>
<title confidence="0.868727">Erklärung</title>
<author confidence="0.998116">Thomas Nowak</author>
<address confidence="0.910971">Rechte Wienzeile 73/23 1050 Wien</address>
<abstract confidence="0.992259166666667">Hiermit erkläre ich, dass ich diese Arbeit selbstständig verfasst habe, dass ich die verwendeten Quellen und Hilfsmittel vollständig angegeben habe und dass ich die Stellen der Arbeit – einschließlich Tabellen, Karten und Abbildungen –, die anderen Werken oder dem Internet im Wortlaut oder dem Sinn nach entnommen sind, auf jeden Fall unter Angabe der Quelle als Entlehnung kenntlich gemacht habe.</abstract>
<address confidence="0.687486">Wien, 18.03.2010</address>
<note confidence="0.587248">(Unterschrift)</note>
<abstract confidence="0.981624675675675">Topology is the general mathematical theory of convergence. Distributed computing is the formal investigation of communicating concurrent processes. We explore applications of topology to distributed computing in two directions: (1) Point-set topology and (2) algebraic topology. We use the former to study the topological structure of infinite execution trees. This enables us to unify a number of impossibility proofs, in particular, impossibility of consensus the task of all processes in a system agreeing on a single value — in various (close to) asynchronous systems with crash failures. latter is used to look into the combinatorial structure of i.e., the collection of current process states in the system. Configurations are regarded as simplices in a simplicial complex, and topological incompatibility of such complexes is utilized to prove the impossibility of a generalization of distributed consensus in certain systems. The particular problem considered is which is the task of letting all processes agree to values within set of at most Kurzfassung Topologie ist die mathematisch adäquate Art, um über Konvergenz zu sprechen. Distributed Computing ist das formale Studium von verteilten Systemen. Die Arbeit beschäftigt sich mit zwei Anwendungen der Topologie im Bereich des Distributed Computing: (1) Mengentheoretische Topologie und (2) algebraische Topologie. Erstere wird verwendet, um die topologische Struktur von unendlichen Bäumen, die die Information über mögliche Ausführungen der Algorithmen subsumieren, zu untersuchen. Dieses Wissen wird verwendet, um einen einheitlichen der Unmöglichkeit von Consensus mehreren Systemmodellen zu geben. Consensus ist das Einigen aller Prozesse des Systems auf einen einzigen Wert. wird verwendet, um die kombinatorische Struktur von Konfiguratioalso der Zusammenfassung aller lokaler Zustände der Prozesse, zu untersuchen. Hierbei wird eine Konfiguration als Simplex in einem Simplizialkomplex aufgefasst. Die topologische Unvereinbarkeit solcher Komplexe ermöglicht einen der Unmöglichkeit von Agreement gewissen Systemen. Das ist eine Verallgemeinerung des Consensus-Problems: Es wird nicht mehr verlangt, dass sich die Prozesse auf nur einen Wert einigen, sondern es wird erlaubt, dass zu Werte auftreten.</abstract>
<intro confidence="0.959708">Contents</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>A 7 Lemma</author>
</authors>
<title>Let X be a topological space and A C X. The following statements are equivalent: (1) A is dense in X. (2) For every non-empty open set</title>
<journal>O C X it follows that A n O</journal>
<volume>74</volume>
<pages>0</pages>
<marker>Lemma, </marker>
<rawString>Lemma A.7. Let X be a topological space and A C X. The following statements are equivalent: (1) A is dense in X. (2) For every non-empty open set O C X it follows that A n O =74 0.</rawString>
</citation>
<citation valid="false">
<title>(3) For every neighborhood N of a point x E X it follows that A n N =74 0. Proof. The equivalence (2)q(3) is trivial. Let A be dense and suppose that (2) does not hold. Then there exists a non-empty open set O with A C Oc where Oc denotes X \O. But since Oc =74 X and Oc is closed, we deduce A =74 X which is a contradiction. Conversely, let (2) hold and suppose that A = C =74 X. But then the complement of C is non-empty, open, and has trivial intersection with A. Contradiction. ■ Example A.7. The set Q C R is dense: Let N C R be a neighborhood of some x E R. Then, by definition, there exists some ε &gt; 0 such that Bε(x) C N. The decimal expansion of x yields a sequence (qk) that converges to x. This implies that there exists some</title>
<journal>K E N such that qK E Bε(x) C N. The</journal>
<booktitle>qK E Q. ❑ A.2.3. Continuity Definition A.13 (Compactness). Let X be</booktitle>
<marker></marker>
<rawString>(3) For every neighborhood N of a point x E X it follows that A n N =74 0. Proof. The equivalence (2)q(3) is trivial. Let A be dense and suppose that (2) does not hold. Then there exists a non-empty open set O with A C Oc where Oc denotes X \O. But since Oc =74 X and Oc is closed, we deduce A =74 X which is a contradiction. Conversely, let (2) hold and suppose that A = C =74 X. But then the complement of C is non-empty, open, and has trivial intersection with A. Contradiction. ■ Example A.7. The set Q C R is dense: Let N C R be a neighborhood of some x E R. Then, by definition, there exists some ε &gt; 0 such that Bε(x) C N. The decimal expansion of x yields a sequence (qk) that converges to x. This implies that there exists some K E N such that qK E Bε(x) C N. The claim follows because, by construction, qK E Q. ❑ A.2.3. Continuity Definition A.13 (Compactness). Let X be a topological space. We call X compact if for any collection (Aι)ι∈I of open sets for which X = U Aι, there exists some n E N and ι1, ... , ιn such that X = Unk=1 Aιk. We call a subset A of a topological space compact if A is compact with respect to the subspace topology inherited from X. ❑ Example A.10. A space equipped with the discrete topology is compact if and only if it is finite. This follows easily because all singleton sets fx} are open in discrete spaces. ❑ Lemma A.9. Let X be a topological space and A C X. The following assertions are true:</rawString>
</citation>
<citation valid="false">
<authors>
<author>Lemma A 10</author>
</authors>
<title>Let f : X → Y be continuous and let X be compact. Then f [X] is compact.</title>
<marker>10, </marker>
<rawString>Lemma A.10. Let f : X → Y be continuous and let X be compact. Then f [X] is compact.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Proof</author>
</authors>
<title>Follows immediately from the definitions. ■ Lemma A.11. Let X be a compact space and f : X → R continuous. Then f attains its minimum, i.e., there exists some x E X such that f (x) = infff (y) |y E X}. (A.47) Proof. By Lemma A.10, the image f [X] is a compact set in R. By Lemma A.9, this set is closed. We may deduce the result from order completeness of R.2 ■ A.2.5. Product Spaces In this section, we will answer the question, which topology is “natural” to equip a product space X = fl X, with when all X, are topological spaces. We do this by considering the projection mappings 7r, : X -* X, and equipping X with a slight generalization of the initial topology. Namely, we will have to make all projection mapping continuous, not only one. This is done with the following Definition A.14. Let (X,) be a family of topological spaces and let X = X, be the set-theoretic product. We call the topology induced by sets of the form 7r−1</title>
<marker>Proof, </marker>
<rawString>Proof. Follows immediately from the definitions. ■ Lemma A.11. Let X be a compact space and f : X → R continuous. Then f attains its minimum, i.e., there exists some x E X such that f (x) = infff (y)  |y E X}. (A.47) Proof. By Lemma A.10, the image f [X] is a compact set in R. By Lemma A.9, this set is closed. We may deduce the result from order completeness of R.2 ■ A.2.5. Product Spaces In this section, we will answer the question, which topology is “natural” to equip a product space X = fl X, with when all X, are topological spaces. We do this by considering the projection mappings 7r, : X -* X, and equipping X with a slight generalization of the initial topology. Namely, we will have to make all projection mapping continuous, not only one. This is done with the following Definition A.14. Let (X,) be a family of topological spaces and let X = X, be the set-theoretic product. We call the topology induced by sets of the form 7r−1</rawString>
</citation>
<citation valid="false">
<title>(2) All X, are compact.</title>
<publisher></publisher>
<marker></marker>
<rawString>, [O] (2) All X, are compact. ❑</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bowen Alpern</author>
<author>Fred B Schneider</author>
</authors>
<title>Defining liveness.</title>
<date>1985</date>
<tech>Technical Report TR85-650,</tech>
<institution>Cornell University,</institution>
<contexts>
<context position="34923" citStr="Alpern and Schneider (1985)" startWordPosition="5987" endWordPosition="5990">The Topology of Execution Spaces Finally, we endow S ⊂ Cω with the subset topology (Example A.9), that is, the topology induced by the same metric. This topology on execution spaces was introduced by Alpern and Schneider (1985). They characterized safety and liveness properties of executions in a topological way. Namely, a property is a safety property if and only if the set of executions satisfying it is closed (Definition</context>
<context position="37329" citStr="Alpern and Schneider (1985)" startWordPosition="6476" endWordPosition="6479">any extension of the fragment. Because P is dense, there exists E&apos; ∈ P such that d(E, E&apos;) &lt; 2—k—1, which shows that E&apos; is also an extension of (C0, C1, ... , Ck). ■ The following result was proved by Alpern and Schneider (1985). Theorem 4.1. Let P ⊂ Cω be any property. Then there exists a safety property S and a liveness property L such that P = S ∩ L. 15 4 Point-Set Topology 4.1 The Topology of Execution Spaces Proof. Defi</context>
</contexts>
<marker>Alpern, Schneider, 1985</marker>
<rawString>Alpern, Bowen and Fred B. Schneider. Defining liveness. Technical Report TR85-650, Cornell University, 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hagit Attiya</author>
<author>Jennifer Welch</author>
</authors>
<title>Distributed Computing: Fundamentals, Simulations, and Advanced Topics.</title>
<date>2004</date>
<publisher>John Wiley &amp; Sons,</publisher>
<note>second edition,</note>
<contexts>
<context position="10421" citStr="Attiya and Welch 2004" startWordPosition="1676" endWordPosition="1679">ent chapters. We start by examining some questions that are tackled and then introduce a number of mathematical models that are used in distributed computing. 2.1. Introduction Distributed computing (Attiya and Welch 2004, Lynch 1996) is the investigation of concurrent processes that communicate by means of some communication medium. Commonly, processes are modeled as deterministic state machines taking steps (perform</context>
<context position="21410" citStr="Attiya and Welch 2004" startWordPosition="3591" endWordPosition="3594">mplification is to limit registers to be single-writer registers. That is, a shared register has a single process assigned to it which is the only process that may write to the register. It is known (Attiya and Welch 2004, Theorem 10.9) that this is not a serious restriction. 2.4.1. A Formal Description In the asynchronous shared memory system model (Attiya and Welch 2004, Section 4.1), a system consists of (a) N proc</context>
<context position="47726" citStr="Attiya and Welch 2004" startWordPosition="8515" endWordPosition="8518">h (⊥, Co, Ci, ... , Cn_i) from ⊥ to Cn_i. We connect to Cn_i 6Existence of a bivalent initial configuration is established by a bit-flipping argument. This standard proof technique can be examined in Attiya and Welch 2004, Lemma 5.16. 7cf. Dolev, Dwork, and Stockmeyer 1987, Lemma I1.1.1 19 4 Point-Set Topology 4.1 The Topology of Execution Spaces ⊥ C1 C2 C3 C4 C5 0 0 0 0 0 Figure 4.2.: Constructed tree up to depth 1 N</context>
<context position="87575" citStr="Attiya and Welch 2004" startWordPosition="16191" endWordPosition="16194">otocol in RWnk, then there exists a k-set agreement protocol in FInk . Proof. The non-trivial part of this proof is to simulate multiple-writer registers with single-writer registers. This is part of Attiya and Welch 2004, Theorem 10.9. — Attiya and Welch 2004, Theorem 10.15 shows that the converse of Theorem 5.3 also holds. 5.6.2. Properties of Full Information Protocols The most important property of full informatio</context>
</contexts>
<marker>Attiya, Welch, 2004</marker>
<rawString>Attiya, Hagit and Jennifer Welch. Distributed Computing: Fundamentals, Simulations, and Advanced Topics. John Wiley &amp; Sons, second edition, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nicolas Bourbaki</author>
</authors>
<title>General Topology, Chapters 1–4. Elements of Mathematics.</title>
<date>1989</date>
<publisher>Springer,</publisher>
<contexts>
<context position="91155" citStr="Bourbaki 1989" startWordPosition="16841" endWordPosition="16842">yclic carrier. This was then used to derive the impossibility of wait-free k-set consensus, following Herlihy and Shavit (1993). 39 A. Topological Prerequisites A.1. Motivation and Examples Topology (Bourbaki 1989) is the mathematical discipline that explores the concept of “closeness” and emerging notions. Fundamental is the notion of “neighborhood”. Informally speaking, a topological space is a set together w</context>
</contexts>
<marker>Bourbaki, 1989</marker>
<rawString>Bourbaki, Nicolas (pseudonym). General Topology, Chapters 1–4. Elements of Mathematics. Springer, 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bernadette Charron-Bost</author>
<author>Sam Toueg</author>
<author>Anindya Basu</author>
</authors>
<title>Revisiting safety and liveness in the context of failures.</title>
<date>2000</date>
<booktitle>In Proceedings of CONCUR 2000—Concurrency Theory,</booktitle>
<pages>552--565</pages>
<publisher>Springer,</publisher>
<marker>Charron-Bost, Toueg, Basu, 2000</marker>
<rawString>Charron-Bost, Bernadette, Sam Toueg, and Anindya Basu. Revisiting safety and liveness in the context of failures. In Proceedings of CONCUR 2000—Concurrency Theory, pages 552–565. Springer, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Danny Dolev</author>
<author>Cynthia Dwork</author>
<author>Larry Stockmeyer</author>
</authors>
<title>On the minimal synchronism needed for distributed consensus.</title>
<date>1987</date>
<journal>Journal of the ACM</journal>
<volume>34</volume>
<issue>1</issue>
<marker>Dolev, Dwork, Stockmeyer, 1987</marker>
<rawString>Dolev, Danny, Cynthia Dwork, and Larry Stockmeyer. On the minimal synchronism needed for distributed consensus. Journal of the ACM 34(1):77–97, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Faith Fich</author>
<author>Eric Ruppert</author>
</authors>
<title>Hundreds of impossibility results for distributed computing.</title>
<date>2003</date>
<journal>Distributed Computing</journal>
<volume>16</volume>
<issue>2</issue>
<contexts>
<context position="27447" citStr="Fich and Ruppert 2003" startWordPosition="4636" endWordPosition="4639">Informally, consensus is the task of getting all processes in a distributed system to agree on a single value. It is known (e.g., Fischer, Lynch, and Paterson 1985, Dolev, Dwork, and Stockmeyer 1987, Fich and Ruppert 2003) that consensus, as easy as the problem specification might seem, is in fact impossible to solve in a variety of system models in the presence of faults. Every process starts its execution with a pres</context>
<context position="64864" citStr="Fich and Ruppert 2003" startWordPosition="11799" endWordPosition="11802">ory In this section, we will prove impossibility of consensus in asynchronous system models of Section 2.4 with shared single-writer read-write registers where one process may fail by crashing (e.g., Fich and Ruppert 2003, Section 5.2). We again fix some enumeration p1, p2, . . . , pN of the processes. Again, we choose for every permutation 7r E SN a set Lπ = {aokπ, exceptπ} of layers and set L = UπESN Lπ. The so-defi</context>
</contexts>
<marker>Fich, Ruppert, 2003</marker>
<rawString>Fich, Faith and Eric Ruppert. Hundreds of impossibility results for distributed computing. Distributed Computing 16(2):121–163, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael J Fischer</author>
<author>Nancy A Lynch</author>
<author>Michael S Paterson</author>
</authors>
<title>Impossibility of distributed consensus with one faulty process.</title>
<date>1985</date>
<journal>Journal of the ACM</journal>
<volume>32</volume>
<issue>2</issue>
<pages>382</pages>
<marker>Fischer, Lynch, Paterson, 1985</marker>
<rawString>Fischer, Michael J., Nancy A. Lynch, and Michael S. Paterson. Impossibility of distributed consensus with one faulty process. Journal of the ACM 32(2):374– 382, 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Allan Hatcher</author>
</authors>
<title>Algebraic Topology.</title>
<date>2002</date>
<publisher>Cambridge University Press,</publisher>
<contexts>
<context position="67890" citStr="Hatcher 2002" startWordPosition="12377" endWordPosition="12378">el with at most N − 1 per-round message omissions. ■ 27 5. Algebraic Topology This chapter deals with a different view on topology than that we took in Chapter 4. We will consider algebraic topology (Hatcher 2002). In this discipline, we assign to topological spaces certain algebraic objects, reason about relations between these algebraic objects and then translate back these insights to statements about topol</context>
</contexts>
<marker>Hatcher, 2002</marker>
<rawString>Hatcher, Allan. Algebraic Topology. Cambridge University Press, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Maurice Herlihy</author>
<author>Sergio Rajsbaum</author>
</authors>
<title>Algebraic spans.</title>
<date>2000</date>
<journal>Mathematical Structures in Computer Science</journal>
<volume>10</volume>
<issue>4</issue>
<contexts>
<context position="76850" citStr="Herlihy and Rajsbaum 2000" startWordPosition="14185" endWordPosition="14188">m S = q. Then we call Σ an acyclic carrier. Let ϕ : C(C) → C(D) be a chain map. We say that ϕ is carried by Σ if T E Σ(S) for all S E C and T E D with cT =74 0 where ϕ(S) = ZT∈D cTT. The following is Herlihy and Rajsbaum 2000, Theorem 3.3: Theorem 5.1. Let Σ : C → P(D) be an acyclic carrier. (1) There exists a chain map C(C) → C(D) that is carried by Σ. (2) If ϕ, ψ : C(C) → C(D) are both carried by Σ and dim S = dim Σ(S) </context>
<context position="88112" citStr="Herlihy and Rajsbaum 2000" startWordPosition="16283" endWordPosition="16286"> FInn−1 and let S E I with dim S = q. Then P(S) is (q − 1)-acyclic. ❑ 37 5 Algebraic Topology 5.6 Impossibility of k-Set Agreement 5.6.3. This Implies Impossibility This section contains the proof of Herlihy and Rajsbaum 2000, Corollary 5.3. Lemma 5.3. Let P be a protocol in FInn-1. Then S 7→ P(S) is an acyclic carrier. Proof. Property (1) of an acyclic carrier is fulfilled by definition of P(S). Property (3) is Theorem 5</context>
</contexts>
<marker>Herlihy, Rajsbaum, 2000</marker>
<rawString>Herlihy, Maurice and Sergio Rajsbaum. Algebraic spans. Mathematical Structures in Computer Science 10(4):549–573, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Maurice Herlihy</author>
<author>Nir Shavit</author>
</authors>
<title>The asynchronous computability theorem for tresilient tasks.</title>
<date>1993</date>
<booktitle>In Proceedings of the 25th Annual ACM Symposium on Theory of Computing,</booktitle>
<pages>111--120</pages>
<contexts>
<context position="5511" citStr="Herlihy and Shavit (1993)" startWordPosition="780" endWordPosition="783">hese are twofold: Firstly, we use point-set topology to provide a unifying topological framework for consensus impossibility proofs. Secondly, we present the impossibility proof of k-set agreement by Herlihy and Shavit (1993) which uses algebraic topology. 1.1. Distributed Computing Consider a system of N processes that communicate by means of passing messages. All processes take steps simultaneously at times t = 0, 1, 2,</context>
<context position="8704" citStr="Herlihy and Shavit (1993)" startWordPosition="1314" endWordPosition="1317">intset topology and provides a unified proof of the impossibility of consensus in some important system models. Chapter 5 deals with methods from algebraic topology. It explains the approach taken by Herlihy and Shavit (1993) to prove the impossibility of k-set agreement in the presence of up to k crash failures. A summary of the thesis is given in Chapter 6. Appendix A gives a self-contained introduction to point-set top</context>
<context position="69736" citStr="Herlihy and Shavit (1993)" startWordPosition="12678" endWordPosition="12681">er is proving impossibility of k-set agreement in asynchronous systems communicating by read-write registers in the presence of up to k crash failures. The proof that we present here was developed by Herlihy and Shavit (1993). Its strategy is to introduce a structure on the set of local processor states of an algorithm, namely that of a simplicial complex and reason that the subcomplex of final configurations (configurati</context>
<context position="85518" citStr="Herlihy and Shavit 1993" startWordPosition="15839" endWordPosition="15842">vertex map by δ : S P → S O. 5.6. Impossibility of k-Set Agreement In this section, we prove the impossibility of wait-free k-set agreement in asynchronous shared-memory environments, as presented in Herlihy and Shavit 1993. Of course, we will heavily rely on methods from algebraic topology. In particular, we will define a class of protocols (“full information protocols”) that has stronger system assumption than the asy</context>
<context position="87834" citStr="Herlihy and Shavit 1993" startWordPosition="16232" endWordPosition="16235">004, Theorem 10.15 shows that the converse of Theorem 5.3 also holds. 5.6.2. Properties of Full Information Protocols The most important property of full information protocols to us is the following (Herlihy and Shavit 1993, Corollary 4.9): Theorem 5.4. Let P be a protocol in FInn−1 and let S E I with dim S = q. Then P(S) is (q − 1)-acyclic. ❑ 37 5 Algebraic Topology 5.6 Impossibility of k-Set Agreement 5.6.3. This Impl</context>
</contexts>
<marker>Herlihy, Shavit, 1993</marker>
<rawString>Herlihy, Maurice and Nir Shavit. The asynchronous computability theorem for tresilient tasks. In Proceedings of the 25th Annual ACM Symposium on Theory of Computing, pages 111–120. 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Horst Herrlich</author>
<author>George E Strecker</author>
</authors>
<title>Category Theory: An Introduction. Allyn and Bacon,</title>
<date>1973</date>
<marker>Herrlich, Strecker, 1973</marker>
<rawString>Herrlich, Horst and George E. Strecker. Category Theory: An Introduction. Allyn and Bacon, 1973.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Leslie Lamport</author>
</authors>
<title>Proving the correctness of multiprocess programs.</title>
<date>1977</date>
<journal>IEEE Transactions on Software Engineering</journal>
<volume>3</volume>
<issue>2</issue>
<contexts>
<context position="24505" citStr="Lamport (1977)" startWordPosition="4142" endWordPosition="4143">namely scan() which returns all register values at once, i.e., a tuple (v1, v2, ... , vM) of register values. 2.5. Safety and Liveness The notions of safety and liveness properties were introduced by Lamport (1977) and have been well adopted in the distributed computing community. Lamport used these notions to subdivide correctness proofs of programs into smaller and more homogeneous pieces. 9 2 Distributed Com</context>
<context position="25372" citStr="Lamport 1977" startWordPosition="4281" endWordPosition="4282">Hence if a “bad thing” happened in an execution prefix, any execution that extends this prefix does not fulfill the safety property. A liveness property is the statement that “something must happen” (Lamport 1977). An example would be the sentence “Every message that was sent is eventually received.” The important point is that at any time in an execution, even if not all sent messages were received yet, it is</context>
</contexts>
<marker>Lamport, 1977</marker>
<rawString>Lamport, Leslie. Proving the correctness of multiprocess programs. IEEE Transactions on Software Engineering SE-3(2):125–143, 1977.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronit Lubitch</author>
<author>Shlomo Moran</author>
</authors>
<title>Closed schedulers: A novel technique for analyzing asynchronous protocols.</title>
<date>1995</date>
<journal>Distributed Computing</journal>
<volume>8</volume>
<issue>4</issue>
<contexts>
<context position="46908" citStr="Lubitch and Moran (1995)" startWordPosition="8363" endWordPosition="8366">the decision of choosing a successor. We will characterize in Section 4.1.3 certain sets of executions whose decision trees capture all the information about the original set. This follows an idea by Lubitch and Moran (1995). Let C be the set of configurations of an algorithm A and let S ⊂ Cω. We will construct a tree T(S) that reflects the local decisions of choosing a successor configuration. We construct it inductivel</context>
<context position="53851" citStr="Lubitch and Moran (1995)" startWordPosition="9705" endWordPosition="9708">use a slightly different argument to derive a contradiction. Most often, we will not directly reason with sequences of configurations. What we will rather do is follow an idea which was introduced by Lubitch and Moran (1995) and generalized by Moses and Rajsbaum (2002): We use schedulers to construct executions. Definition 4.1. Let S be the set of admissible executions of some algorithm. A scheduler for S is a metric spa</context>
</contexts>
<marker>Lubitch, Moran, 1995</marker>
<rawString>Lubitch, Ronit and Shlomo Moran. Closed schedulers: A novel technique for analyzing asynchronous protocols. Distributed Computing 8(4):203–210, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nancy A Lynch</author>
</authors>
<title>Distributed Algorithms.</title>
<date>1996</date>
<publisher>Morgan Kaufmann,</publisher>
<note>Bibliography Bibliography</note>
<contexts>
<context position="10434" citStr="Lynch 1996" startWordPosition="1680" endWordPosition="1681">by examining some questions that are tackled and then introduce a number of mathematical models that are used in distributed computing. 2.1. Introduction Distributed computing (Attiya and Welch 2004, Lynch 1996) is the investigation of concurrent processes that communicate by means of some communication medium. Commonly, processes are modeled as deterministic state machines taking steps (performing state tra</context>
<context position="17182" citStr="Lynch 1996" startWordPosition="2834" endWordPosition="2835">spect to the model parameter f &gt; 0) if every message sent to non-faulty processes is received and at most f processes are faulty. 2.3. Omission Failure Model In the synchronous message-passing model (Lynch 1996, Part I), all processes p1, p2, . . . , pN take their steps at the same time, e.g., every process takes a step at times t = 0, 1, 2, 3,... Furthermore, there does exist an upper bound on message dela</context>
</contexts>
<marker>Lynch, 1996</marker>
<rawString>Lynch, Nancy A. Distributed Algorithms. Morgan Kaufmann, 1996. Bibliography Bibliography</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yoram Moses</author>
<author>Sergio Rajsbaum</author>
</authors>
<title>A layered analysis of consensus.</title>
<date>2002</date>
<journal>SIAM Journal on Computing</journal>
<volume>31</volume>
<issue>4</issue>
<contexts>
<context position="53896" citStr="Moses and Rajsbaum (2002)" startWordPosition="9712" endWordPosition="9715">a contradiction. Most often, we will not directly reason with sequences of configurations. What we will rather do is follow an idea which was introduced by Lubitch and Moran (1995) and generalized by Moses and Rajsbaum (2002): We use schedulers to construct executions. Definition 4.1. Let S be the set of admissible executions of some algorithm. A scheduler for S is a metric space X together with a continuous map f : X → S</context>
<context position="55693" citStr="Moses and Rajsbaum 2002" startWordPosition="10080" endWordPosition="10083"> sequence space, i.e., X C LN for some set L. Hence a closed scheduler X can be viewed as the set of paths in the locally finite tree T (X); see Theorem 4.2. Often, the set L will be a set of layers (Moses and Rajsbaum 2002), i.e., each E E L will correspond to a finite sequence of events. For example, a layer in the shared memory model will be every process taking one step in some fixed order. The fact that each layer i</context>
<context position="60295" citStr="Moses and Rajsbaum 2002" startWordPosition="10922" endWordPosition="10925">ults We will list a number of impossibility proofs in this section that utilize our topological framework. In particular, we give a closed scheduler for each of the models. We will use arguments from Moses and Rajsbaum 2002, Sections 3, 7 and 8. 4.3.1. Asynchronous Message Passing We now present a topological proof of the consensus impossibility result (Fischer, Lynch, and Paterson 1985) in the model introduced in Secti</context>
</contexts>
<marker>Moses, Rajsbaum, 2002</marker>
<rawString>Moses, Yoram and Sergio Rajsbaum. A layered analysis of consensus. SIAM Journal on Computing 31(4):989–1021, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Saks</author>
<author>Fotios Zaharoglou</author>
</authors>
<title>Wait-free k-set agreement is impossible: The topology of public knowledge.</title>
<date>2000</date>
<journal>SIAM Journal on Computing</journal>
<volume>29</volume>
<issue>5</issue>
<contexts>
<context position="32143" citStr="Saks and Zaharoglou 2000" startWordPosition="5446" endWordPosition="5449">hich successor configurations are possible. Thus, we “shift focus from the structure of protocols for a distributed system to the structure of the set of possible schedules of a distributed system.” (Saks and Zaharoglou 2000) We denote by CA the set of all configurations of algorithm A. Let SA denote the set of admissible executions, which is a subset of the set CωA of sequences of configurations.2 We will equip the latte</context>
</contexts>
<marker>Saks, Zaharoglou, 2000</marker>
<rawString>Saks, Michael and Fotios Zaharoglou. Wait-free k-set agreement is impossible: The topology of public knowledge. SIAM Journal on Computing 29(5):1449–1483, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nicola Santoro</author>
<author>Peter Widmayer</author>
</authors>
<title>Time is not a healer.</title>
<date>1989</date>
<booktitle>In Proceedings of the 6th Annual Symposium on Theoretical Aspects of Computer Science,</booktitle>
<pages>304--313</pages>
<publisher>Springer,</publisher>
<contexts>
<context position="7021" citStr="Santoro and Widmayer 1989" startWordPosition="1038" endWordPosition="1041"> 1/2, suppose that in every time frame [t, t + 1), up to N − 1 message may be lost. That is, these messages do not get delivered although all other messages are delivered timely. A surprising result (Santoro and Widmayer 1989) is that even in such a system with relatively few faults (there exist up to N2 − N point-to-point links; at most N − 1 are lossy each round) it is impossible for any deterministic algorithm to solve </context>
<context position="17926" citStr="Santoro and Widmayer 1989" startWordPosition="2968" endWordPosition="2971">ce-time diagram of a synchronous execution; the diagonal arrows indicate messages. t = 0 t = 1 t = 2 t = 3 p1 p2 p3 Figure 2.2.: Synchronous message-passing In the synchronous omission failure model (Santoro and Widmayer 1989, Section 4.1), in every round, i.e., in every time interval [t, t + 1), up to N − 1 messages may be lost. These omissions create difficulties and yield a number of impossibility results, because the </context>
<context position="66876" citStr="Santoro and Widmayer 1989" startWordPosition="12176" endWordPosition="12179">em 4.5. There is no consensus algorithm in the asynchronous single-writer shared memory model with at most one crash failure. ■ 4.3.3. Transient Message Loss We will prove the impossibility result of Santoro and Widmayer 1989, Section 4.1 in the model of Section 2.3. Let p1, p2, ... , pN be an enumeration of the set of processes. We define the set of layers to be L = {loss(i, j) |1 S i S N, 0 S j S N} (4.19) and again des</context>
</contexts>
<marker>Santoro, Widmayer, 1989</marker>
<rawString>Santoro, Nicola and Peter Widmayer. Time is not a healer. In Proceedings of the 6th Annual Symposium on Theoretical Aspects of Computer Science, pages 304–313. Springer, 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Edwin H Spanier</author>
</authors>
<title>Algebraic Topology.</title>
<date>1966</date>
<publisher>McGraw-Hill,</publisher>
<contexts>
<context position="79962" citStr="Spanier 1966" startWordPosition="14811" endWordPosition="14812">the metric s X d(α, β) = (α(v) − β(v))2. (5.10) v∈S C For a simplicial vertex map f : U C — UD, we define |f |: |C |— |D |by |f |(α)(w) = X α(v). (5.11) f (v)=w Consequences of these definitions are (Spanier 1966, Sec. 3.1): 33 5 Algebraic Topology 5.5 Configuration Complexes (1) |f |is continuous. ~~ = id|C| (2) |g ◦ f |= |g |◦ |f |and ~~idS C (3) If C is finite then |C |is a compact Hausdorff space. 5.4.3. </context>
</contexts>
<marker>Spanier, 1966</marker>
<rawString>Spanier, Edwin H. Algebraic Topology. McGraw-Hill, 1966.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>