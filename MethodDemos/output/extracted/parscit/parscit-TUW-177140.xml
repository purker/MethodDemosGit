<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.013357">
<title confidence="0.9989645">
Testing Relativised Uniform Equivalence under
Answer-Set Projection in the System cc⊤⋆
</title>
<author confidence="0.966416">
Johannes Oetsch1, Martina Seidl2, Hans Tompits1, and Stefan Woltran1
</author>
<address confidence="0.4587935">
1 Institut für Informationssysteme, Technische Universität Wien,
Favoritenstraße 9-11, A-1040 Vienna, Austria
</address>
<email confidence="0.793652">
loetsch,tompitsl@kr.tuwien.ac.at
woltran@dbai.tuwien.ac.at
</email>
<address confidence="0.3424355">
2 Institut für Softwaretechnik, Technische Universität Wien,
Favoritenstraße 9-11, A-1040 Vienna, Austria
</address>
<email confidence="0.692528">
seidl@big.tuwien.ac.at
</email>
<bodyText confidence="0.993912846153846">
Abstract. The system ccT is a tool for testing correspondence between propo-
sitional logic programs under the answer-set semantics with respect to differ-
ent refined notions of program correspondence. The underlying methodology of
ccT is to reduce a given correspondence problem to the satisfiability problem of
quantified propositional logic and to employ extant solvers for the latter language
as back-end inference engines. In a previous version of ccT, the system was
designed to test correspondence between programs based on relativised strong
equivalence under answer-set projection. Such a setting generalises the standard
notion of strong equivalence by taking the alphabet of the context programs as
well as the projection of the compared answer sets to a set of designated out-
put atoms into account. This paper outlines a newly added component of ccT
for testing similarly parameterised correspondence problems based on uniform
equivalence.
</bodyText>
<sectionHeader confidence="0.914402" genericHeader="abstract">
1 Motivation and General Information
</sectionHeader>
<bodyText confidence="0.99956235483871">
An important issue in software development is to determine whether two encodings of a
given problem are equivalent, i.e., whether they yield the same result on a given problem
instance. Depending on the context of problem representations, different definitions of
“equivalence” are useful and desirable. The system cc⊤ [1] (short for “correspondence-
checking tool”) is devised as a checker for a broad range of different such comparison
relations defined between disjunctive logic programs (DLPs) under the answer-set se-
mantics [2]. In a previous version of cc⊤, the system was designed to test correspon-
dence between logic programs based on relativised strong equivalence under answer-
set projection. Such a setting generalises the standard notion of strong equivalence [3]
by taking the alphabet of the context programs as well as the projection of the com-
pared answer sets to a set of designated output atoms into account [4]. The latter feature
⋆ This work was partially supported by the Austrian Science Fund (FWF) under grant P18019.
The second author was also supported by the Austrian Federal Ministry of Transport, Inno-
vation, and Technology (BMVIT) and the Austrian Research Promotion Agency (FFG) under
grant FIT-IT-810806.
reflects the common use of local (hidden) variables which may be used in submodules
but which are ignored in the final computation.
In this paper, we outline a newly added component of ccT for testing similarly pa-
rameterised correspondence problems but generalising uniform equivalence [5]—that
is, we deal with a component of ccT for testing relativised uniform equivalence under
answer-set projection. This notion, recently introduced in previous work [6], is less re-
strained, along with a slightly lower complexity than its strong counterpart (provided
that the polynomial hierarchy does not collapse). However, in general, it is still outside
a feasible means to be computed by propositional answer-set solvers (again under the
proviso that the polynomial hierarchy does not collapse). Yet, like relativised strong
equivalence with projection, it can be efficiently reduced to the satisfiability problem
of quantified propositional logic, an extension of classical propositional logic charac-
terised by the condition that its sentences, generally referred to as quantified Boolean
formulas (QBFs), are permitted to contain quantifications over atomic formulas. The ar-
chitecture of ccT takes advantage of this and uses extant solvers for quantified propo-
sitional logic as back-end reasoning engines.
</bodyText>
<sectionHeader confidence="0.974729" genericHeader="keywords">
2 Background
</sectionHeader>
<bodyText confidence="0.768178">
Propositional disjunctive logic programs (DLPs) are finite sets of rules of the form
</bodyText>
<equation confidence="0.908267">
a1 V ··· V al &amp;lt;-- al+1, ... , a,,,,,, not a,,,,,+1, ... , not arm,, (1)
n &amp;gt; m &amp;gt; l &amp;gt; 0, where all ai are propositional atoms from some fixed universe U and
</equation>
<bodyText confidence="0.99068884375">
not denotes default negation. An interpretation I is a model of a program P, de-
noted by I j= P, iff for every rule from P (as defined above), it holds that, whenever
fal+1,..., a,,,,,} C I and fa,,,,,+1,..., arm,} n I = 0, then fa1, ..., al} n I =6 0.
Following Gelfond and Lifschitz [2], an interpretation I is an answer set of a pro-
gram P iff it is a minimal model of the reduct PI, resulting from P by (i) deleting all
rules containing default negated atoms not a such that a G I, and (ii) deleting all default
negated atoms in the remaining rules. The collection of all answer sets of a program P
is denoted by AS(P).
In order to semantically compare programs, different notions of equivalence have
been introduced in the context of the answer-set semantics. Two programs, P and Q,
are strongly equivalent iff, for any program R, AS(P [ R) = AS(Q [ R); they are uni-
formly equivalent iff, for any set F of facts, AS(P [ F) = AS(Q [ F). While strong
equivalence is relevant for program optimisation and modular programming in gen-
eral [7–9], uniform equivalence is useful in the context of hierarchically structured pro-
gram components, where lower-layered components provide input for higher-layered
ones. In abstracting from strong and uniform equivalence, Eiter et al. [4] introduced the
notion of a correspondence problem which allows to specify (i) a context, i.e., a class of
programs used to be added to the programs under consideration, and (ii) the comparison
relation that has to hold between the answer sets of the extended programs. Following
Eiter et al. [4], we focus here on correspondence problems where the comparison re-
lation is a projection (to a given set of atoms) of the standard subset or set-equality
relation. The context, on the other hand, contains all programs which are sets of facts
over some set A of atoms, identified with the power set 2A over A.
Thus, the concrete formal realisation of relativised uniform equivalence with pro-
jection is as follows [6]: Consider a quadruple 11 = (P, Q, 2A, OB), where P, Q are
programs, A, B are sets of atoms, O E {C, =}, and S OB S′ stands for {I n B  |I E
S} O {J n B  |J E S′}. 11 is called a propositional query equivalence problem (PQEP)
if OB is given by =B, and a propositional query inclusion problem (PQIP) if OB is
given by CB. We say that 11 holds iff, for each F E 2A, AS(P U F) OB AS(Q U F).
Note that (P, Q, 2A, =B) holds iff (P, Q, 2A, CB) and (Q, P, 2A, CB) jointly hold. We
also refer to A as the context set and to B as the projection set.
For illustration, consider the programs
</bodyText>
<equation confidence="0.9996695">
P = {sad V happy &amp;lt;--; sappy &amp;lt;-- sad, happy; confused &amp;lt;-- sappy} and
Q = {sad &amp;lt;-- not happy; happy &amp;lt;-- not sad; confused &amp;lt;-- sad, happy},
</equation>
<bodyText confidence="0.9999265">
which express some knowledge about the “moods” of a person, where P uses an aux-
iliary atom sappy. The programs can be seen as queries over a propositional database
which consists of facts from, e.g., {happy, sad}. For the output, it would be natural
to consider the common intensional atom confused. We thus consider 11 = (P, Q,
2A, =B) as a suitable PQEP, specifying A = {happy, sad} and B = {confused}. It is
a straightforward matter to check that 11, defined in this way, holds.
</bodyText>
<sectionHeader confidence="0.989503" genericHeader="introduction">
3 System Specifics
</sectionHeader>
<bodyText confidence="0.997336058823529">
As pointed out in Section 1, the overall approach of ccT is to reduce PQEPs and
PQIPs to the satisfiability problem of quantified propositional logic and to use extant
solvers [10] for the latter language as back-end inference engines for evaluating the
resulting formulas. The reductions required for this approach are described by Oetsch
et al. [6] but ccT employs additional optimisations [11]. The overall architecture of
ccT is depicted in Fig. 1. The system takes as input two programs, P and Q, and two
sets of atoms, A and B. Command-line options select between two kinds of reductions,
a direct one or an optimised one, and whether the programs are compared as a PQIP or
a PQEP. Detailed invocation syntax can be requested with option -h.
Next, let us turn our attention to the concrete usage of ccT. The syntax of the pro-
grams is the basic DLV syntax.3 In this syntax, the two programs P and Q from the
above example look as follows:
P= ⎧ sad v happy. Q = ⎧ sad :- not happy.
⎨ sappy :- sad, happy. ⎨ happy :- not sad.
⎩ confused :- sappy. ⎩ confused :- sad, happy.
Let us assume that the two programs are stored in the files P.dl and Q.dl. The two
sets A and B from the example are written as comma separated lists within brackets:
</bodyText>
<figure confidence="0.9631809375">
3 See http://www.dlvsystem.com/ for details about DLV.
program P
program Q
projection set B
input files
normal form
QBF
qst
non-normal form
QBF
ccT
context set A
non-normal form
QBF-solver
normal form
QBF-solver
</figure>
<figureCaption confidence="0.999119">
Fig. 1. Overall architecture of cc⊤.
</figureCaption>
<bodyText confidence="0.993113117647059">
context set A: (happy, sad),
projection set B: (confused).
We assume them to be stored in files A and B. The concrete invocation syntax for trans-
lating the problem Π = (P, Q, 2A, =B) into a corresponding QBF is
ccT -u -e P.dl Q.dl A B
where the command-line options ‘-u’ and ‘-e’ evince that we want to check for a
notion of uniform equivalence. To check for uniform inclusion, replace ‘-e’ by ‘-i’ or
omit the parameter.
The output will be written directly to the standard-output device from where it can
serve as input for QBF-solvers. Since cc⊤ does not output QBFs in a specific nor-
mal form, for using solvers requiring normal-form QBFs, the additional normaliser
qst [12] is employed. Finally, cc⊤ is developed entirely in ANSI C; hence, it is highly
portable. The parser for the input data was written using LEX and YACC. Further in-
formation about cc⊤ is available at
http://www.kr.tuwien.ac.at/research/ccT/.
Experimental evaluations using different QBF-solvers are reported in a companion pa-
per [11].
</bodyText>
<sectionHeader confidence="0.904131" genericHeader="method">
4 cc⊤ on Stage
</sectionHeader>
<bodyText confidence="0.99997555">
In this section, we give a brief and, for space reasons, rather informal discussion on
an application of cc⊤ for verification and debugging needs in the context of a logic
programming course at our university. This is not only to make the concept of cor-
respondence checking within a refined framework more tangible but also to show a
concrete application field. As a subtask in this course, the students have to model an
air-conditioning system consisting of components for cooling and heating, as well as a
valve and a switch element. More specifically, they are given a detailed description of
the desired input/output behaviour of the components and the system as a whole, and
they have to develop logic programs that comply with that specification. Without go-
ing into the details, such a specification could demand that the input of, e.g., a heating
component consists of an airstream which can be 0 (air does not float) or 1 (air floats)
and has an associated temperature (an integer from a certain range) as well as a con-
trol parameter (also an integer) to control the heating power. Analogously to the input
airstream, a heater has an output airstream. Now, the specification determines the be-
haviour of the component with respect to the output airstream conditioned by the input
airstream and the control parameter.
A straightforward strategy to verify the student’s solution is the following: (i) write
a sample solution that correctly implements the specification, (ii) define test cases, i.e.,
sets of facts representing the input for a component, and (iii) compare the output of our
sample solution against the output of the student’s component. This method, used in
previous years and implemented by a more or less simple script, is obviously sound but
not complete with respect to detecting potential flaws. Here comes cc⊤ into the play:
this verification problem can be stated as a PQEP4, where the context set consist of the
atoms that constitute the input and the projection set contains the atoms that represent
the output of a component (thus allowing the students an unrestricted use of additional
atoms in their programs). Hence, we have a sound and complete method for verification
at hand. We employed this approach last winter semester for evaluating the submitted
exercises and it compared favourably to the old method.
Two things were necessary to obtain reasonable run-times for evaluating the QBFs,
however: First, we had to restrict the context class, and second, we added additional con-
straints to the programs to impose some restrictions on the input of the components, like
specifying not more than one input value for an airstream temperature. The later point
is also to make the test more fair. Albeit we loose completeness in the sense from above
this way, we are able to verify thousands of test cases implicitly with the cc⊤-approach
compared to only 10 to 20 test cases with the old script. Also, a direct comparison of the
results between the two test approaches is very encouraging: all errors detected by the
script were also detected by the cc⊤-approach, while 26 (out of 200) components were
classified as correct by the script but as non-equivalent to our sample solution by cc⊤.
It is worth mentioning that on these problem instances the solver qpro [13] showed,
with a median run-time of 2.54 seconds, excellent performance.
</bodyText>
<sectionHeader confidence="0.998955" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.9801634">
In this paper, we presented the architecture and system specifics of a new compo-
nent of the tool cc⊤ for testing parameterised correspondence problems based on uni-
form equivalence for disjunctive logic programs under the answer-set semantics. The
correspondence problems are efficiently compiled to quantified Boolean formulas for
which many solvers have been implemented. As related work, we mention the system
DLPEQ [14] for deciding ordinary equivalence, which is based on a reduction to logic
programs, and the system SELP [15] for checking strong equivalence, which is based
4 The programs under consideration are not propositional, i.e., they contain variables. Never-
theless, the domain, i.e., the set of constants that can occur in the programs is finite and such
programs can always be treated as a shorthand for the respective propositional programs.
on a reduction to classical logic quite in the spirit of our implementation approach.
We successfully applied cc⊤ for the verification of students’ programs obtained from
a laboratory course about logic programming at our university. Future work includes
extending our methods to non-ground answer set programs, which are important in
practical applications.
</bodyText>
<sectionHeader confidence="0.998547" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.998567902439025">
1. Oetsch, J., Seidl, M., Tompits, H., Woltran, S.: ccT: A Tool for Checking Advanced Corre-
spondence Problems in Answer-Set Programming. In Proceedings of the 15th International
Conference on Computing (CIC 2006), IEEE Computer Society Press (2006) 3–10
2. Gelfond, M., Lifschitz, V.: Classical Negation in Logic Programs and Disjunctive Databases.
New Generation Computing 9 (1991) 365–385
3. Lifschitz, V., Pearce, D., Valverde, A.: Strongly Equivalent Logic Programs. ACM TOCL
2(4) (2001) 526–541
4. Eiter, T., Tompits, H., Woltran, S.: On Solution Correspondences in Answer Set Program-
ming. In Proceedings of the 19th International Joint Conference on Artificial Intelligence
(IJCAI 2005). (2005) 97–102
5. Eiter, T., Fink, M.: Uniform Equivalence of Logic Programs under the Stable Model Se-
mantics. In Proceedings of the 19th International Conference on Logic Programming (ICLP
2003). Volume 2916 of LNCS, Springer (2003) 224–238
6. Oetsch, J., Tompits, H., Woltran, S.: Facts do not Cease to Exist Because They are Ignored:
Relativised Uniform Equivalence with Answer-Set Projection. In Proceedings of the 22nd
National Conference on Artificial Intelligence (AAAI 2007), AAAI Press (2007) 458–464
7. Eiter, T., Fink, M., Tompits, H., Woltran, S.: Simplifying Logic Programs Under Uniform and
Strong Equivalence. In Proceedings of the 7th International Conference on Logic Program-
ming and Nonmonotonic Reasoning (LPNMR-7). Volume 2923 of LNCS, Springer (2004)
87–99
8. Pearce, D.: Simplifying Logic Programs under Answer Set Semantics. In Proceedings of the
20th International Conference on Logic Programming (ICLP 2004). Volume 3132 of LNCS,
Springer (2004) 210–224
9. Lin, F., Chen, Y.: Discovering Classes of Strongly Equivalent Logic Programs. In Pro-
ceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI 2005).
(2005) 516–521
10. Le Berre, D., Narizzano, M., Simon, L., Tacchella, L.A.: The Second QBF Solvers Compar-
ative Evaluation. In Proceedings of the 7th International Conference on Theory and Applica-
tions of Satisfiability Testing (SAT 2004). Volume 3542 of LNCS, Springer (2005) 376–392
11. Oetsch, J., Seidl, M., Tompits, H., Woltran, S.: An Extension of the System cc⊤ for Testing
Relativised Uniform Equivalence under Answer-Set Projection (2007) Submitted draft.
12. Zolda, M.: Comparing Different Prenexing Strategies for Quantified Boolean Formulas
(2004) Master’s Thesis, Vienna University of Technology.
13. Egly, U., Seidl, M., Woltran, S.: A Solver for QBFs in Nonprenex Form. In Proceedings of
the 17th European Conference on Artificial Intelligence (ECAI 2006). (2006) 477–481
14. Oikarinen, E., Janhunen, T.: Verifying the Equivalence of Logic Programs in the Disjunc-
tive Case. In Proceedings of the 7th International Conference on Logic Programming and
Nonmonotonic Reasoning (LPNMR-7). Volume 2923 of LNCS, Springer (2004) 180–193
15. Chen, Y., Lin, F., Li, L.: SELP - A System for Studying Strong Equivalence Between Logic
Programs. In Proceedings of the 8th International Conference on Logic Programming and
Non Monotonic Reasoning (LPNMR 2005). Volume 3552 of LNCS, Springer (2005) 442–
</reference>
<page confidence="0.928456">
446
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.013560">
<title confidence="0.997979">Testing Relativised Uniform Equivalence Projection in the System</title>
<author confidence="0.999348">Martina Hans</author>
<author confidence="0.999348">Stefan</author>
<affiliation confidence="0.684087">für Informationssysteme, Technische Universität</affiliation>
<address confidence="0.493522">Favoritenstraße 9-11, A-1040 Vienna,</address>
<email confidence="0.448821">fürSoftwaretechnik,TechnischeUniversität</email>
<abstract confidence="0.994749785714286">Favoritenstraße 9-11, A-1040 Vienna, seidl@big.tuwien.ac.at system a tool for testing correspondence between propositional logic programs under the answer-set semantics with respect to different refined notions of program correspondence. The underlying methodology of to reduce a given correspondence problem to the satisfiability problem of quantified propositional logic and to employ extant solvers for the latter language back-end inference engines. In a previous version of the system was to test correspondence between programs based on strong under answer-set Such a setting generalises the standard notion of strong equivalence by taking the alphabet of the context programs as well as the projection of the compared answer sets to a set of designated outatoms into account. This paper outlines a newly added component of testing similarly parameterised correspondence problems based on 1 Motivation and General Information An important issue in software development is to determine whether two encodings of a given problem are equivalent, i.e., whether they yield the same result on a given problem instance. Depending on the context of problem representations, different definitions of are useful and desirable. The system (short for “correspondencechecking tool”) is devised as a checker for a broad range of different such comparison defined between logic programs the answer-set se- In a previous version of the system was designed to test corresponbetween logic programs based on strong equivalence under answer- Such a setting generalises the standard notion of strong equivalence [3] by taking the alphabet of the context programs as well as the projection of the compared answer sets to a set of designated output atoms into account [4]. The latter feature work was partially supported by the Austrian Science Fund (FWF) under grant P18019. The second author was also supported by the Austrian Federal Ministry of Transport, Innovation, and Technology (BMVIT) and the Austrian Research Promotion Agency (FFG) under grant FIT-IT-810806. reflects the common use of local (hidden) variables which may be used in submodules but which are ignored in the final computation. this paper, we outline a newly added component of testing similarly pacorrespondence problems but generalising equivalence we deal with a component of testing uniform equivalence under This notion, recently introduced in previous work [6], is less restrained, along with a slightly lower complexity than its strong counterpart (provided that the polynomial hierarchy does not collapse). However, in general, it is still outside a feasible means to be computed by propositional answer-set solvers (again under the proviso that the polynomial hierarchy does not collapse). Yet, like relativised strong equivalence with projection, it can be efficiently reduced to the satisfiability problem of quantified propositional logic, an extension of classical propositional logic characby the condition that its sentences, generally referred to as Boolean are permitted to contain quantifications over atomic formulas. The arof advantage of this and uses extant solvers for quantified propositional logic as back-end reasoning engines. 2 Background disjunctive logic programs are finite sets of rules of the form ··· V ... , not... , where all propositional atoms from some fixed universe default negation. An a a program deby iff for every rule from defined above), it holds that, whenever C n then ..., n Gelfond and Lifschitz [2], an interpretation an set a proit is a minimal model of the resulting from (i) deleting all containing default negated atoms that and (ii) deleting all default atoms in the remaining rules. The collection of all answer sets of a program denoted by In order to semantically compare programs, different notions of equivalence have introduced in the context of the answer-set semantics. Two programs, equivalent for any program = they are uniequivalent for any set facts, = While strong equivalence is relevant for program optimisation and modular programming in general [7–9], uniform equivalence is useful in the context of hierarchically structured program components, where lower-layered components provide input for higher-layered In abstracting from strong and uniform equivalence, Eiter al. introduced the of a problem allows to specify (i) a i.e., a class of programs used to be added to the programs under consideration, and (ii) the comparison relation that has to hold between the answer sets of the extended programs. Following al. we focus here on correspondence problems where the comparison relation is a projection (to a given set of atoms) of the standard subset or set-equality relation. The context, on the other hand, contains all programs which are sets of facts some set atoms, identified with the power set over Thus, the concrete formal realisation of relativised uniform equivalence with prois as follows [6]: Consider a quadruple Q, where Q B sets of atoms, E and stands for O called a query equivalence problem given by and a query inclusion problem if by We say that for each that Q, iff Q, P, hold. We refer to the set to the For illustration, consider the programs express some knowledge about the “moods” of a person, where an auxatom The programs can be seen as queries over a propositional database consists of facts from, e.g., For the output, it would be natural consider the common intensional atom We thus consider Q, a suitable PQEP, specifying It is straightforward matter to check that defined in this way, holds. 3 System Specifics pointed out in Section 1, the overall approach of to reduce PQEPs and PQIPs to the satisfiability problem of quantified propositional logic and to use extant solvers [10] for the latter language as back-end inference engines for evaluating the resulting formulas. The reductions required for this approach are described by Oetsch al. but additional optimisations [11]. The overall architecture of depicted in Fig. 1. The system takes as input two programs, and two of atoms, Command-line options select between two kinds of reductions, a direct one or an optimised one, and whether the programs are compared as a PQIP or PQEP. Detailed invocation syntax can be requested with option let us turn our attention to the concrete usage of The syntax of the prois the basic In this syntax, the two programs the above example look as follows: ⎧ sad v happy. ⎧ sad :not happy. ⎨ sappy :sad, happy. ⎨ happy :not sad. ⎩ confused :sappy. ⎩ confused :sad, happy. us assume that the two programs are stored in the files The two the example are written as comma separated lists within brackets: details about program P program Q projection set B input files normal form QBF qst non-normal form QBF ccT context set A non-normal form QBF-solver normal form QBF-solver 1. architecture of set set assume them to be stored in files The concrete invocation syntax for transthe problem Q, a corresponding QBF is ccT -u -e P.dl Q.dl A B the command-line options and evince that we want to check for a of To check for uniform inclusion, replace by or omit the parameter. The output will be written directly to the standard-output device from where it can as input for QBF-solvers. Since not output QBFs in a specific normal form, for using solvers requiring normal-form QBFs, the additional normaliser is employed. Finally, developed entirely in ANSI C; hence, it is highly portable. The parser for the input data was written using LEX and YACC. Further inabout available at Experimental evaluations using different QBF-solvers are reported in a companion paper [11]. Stage In this section, we give a brief and, for space reasons, rather informal discussion on application of verification and debugging needs in the context of a logic programming course at our university. This is not only to make the concept of correspondence checking within a refined framework more tangible but also to show a concrete application field. As a subtask in this course, the students have to model an air-conditioning system consisting of components for cooling and heating, as well as a valve and a switch element. More specifically, they are given a detailed description of the desired input/output behaviour of the components and the system as a whole, and they have to develop logic programs that comply with that specification. Without going into the details, such a specification could demand that the input of, e.g., a heating consists of an airstream which can be does not float) or floats) and has an associated temperature (an integer from a certain range) as well as a control parameter (also an integer) to control the heating power. Analogously to the input airstream, a heater has an output airstream. Now, the specification determines the behaviour of the component with respect to the output airstream conditioned by the input airstream and the control parameter. A straightforward strategy to verify the student’s solution is the following: (i) write a sample solution that correctly implements the specification, (ii) define test cases, i.e., sets of facts representing the input for a component, and (iii) compare the output of our sample solution against the output of the student’s component. This method, used in previous years and implemented by a more or less simple script, is obviously sound but complete with respect to detecting potential flaws. Here comes the play: verification problem can be stated as a where the context set consist of the atoms that constitute the input and the projection set contains the atoms that represent the output of a component (thus allowing the students an unrestricted use of additional atoms in their programs). Hence, we have a sound and complete method for verification at hand. We employed this approach last winter semester for evaluating the submitted exercises and it compared favourably to the old method. Two things were necessary to obtain reasonable run-times for evaluating the QBFs, however: First, we had to restrict the context class, and second, we added additional constraints to the programs to impose some restrictions on the input of the components, like specifying not more than one input value for an airstream temperature. The later point is also to make the test more fair. Albeit we loose completeness in the sense from above way, we are able to verify thousands of test cases implicitly with the to only cases with the old script. Also, a direct comparison of the results between the two test approaches is very encouraging: all errors detected by the were also detected by the while of components were as correct by the script but as non-equivalent to our sample solution by is worth mentioning that on these problem instances the solver showed, a median run-time of excellent performance. 5 Conclusion In this paper, we presented the architecture and system specifics of a new compoof the tool testing parameterised correspondence problems based on uniequivalence disjunctive logic programs under the answer-set semantics. The correspondence problems are efficiently compiled to quantified Boolean formulas for which many solvers have been implemented. As related work, we mention the system DLPEQ [14] for deciding ordinary equivalence, which is based on a reduction to logic programs, and the system SELP [15] for checking strong equivalence, which is based programs under consideration are not propositional, i.e., they contain variables. Nevertheless, the domain, i.e., the set of constants that can occur in the programs is finite and such programs can always be treated as a shorthand for the respective propositional programs. on a reduction to classical logic quite in the spirit of our implementation approach. successfully applied the verification of students’ programs obtained from a laboratory course about logic programming at our university. Future work includes extending our methods to non-ground answer set programs, which are important in practical applications.</abstract>
<note confidence="0.923459166666667">References 1. Oetsch, J., Seidl, M., Tompits, H., Woltran, S.: ccT: A Tool for Checking Advanced Correspondence Problems in Answer-Set Programming. In Proceedings of the 15th International Conference on Computing (CIC 2006), IEEE Computer Society Press (2006) 3–10 2. Gelfond, M., Lifschitz, V.: Classical Negation in Logic Programs and Disjunctive Databases. Generation Computing 365–385</note>
<address confidence="0.606239">3. Lifschitz, V., Pearce, D., Valverde, A.: Strongly Equivalent Logic Programs. ACM TOCL</address>
<phone confidence="0.763518">(2001) 526–541</phone>
<note confidence="0.969116171428571">4. Eiter, T., Tompits, H., Woltran, S.: On Solution Correspondences in Answer Set Programming. In Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI 2005). (2005) 97–102 5. Eiter, T., Fink, M.: Uniform Equivalence of Logic Programs under the Stable Model Semantics. In Proceedings of the 19th International Conference on Logic Programming (ICLP 2003). Volume 2916 of LNCS, Springer (2003) 224–238 6. Oetsch, J., Tompits, H., Woltran, S.: Facts do not Cease to Exist Because They are Ignored: Relativised Uniform Equivalence with Answer-Set Projection. In Proceedings of the 22nd National Conference on Artificial Intelligence (AAAI 2007), AAAI Press (2007) 458–464 7. Eiter, T., Fink, M., Tompits, H., Woltran, S.: Simplifying Logic Programs Under Uniform and Strong Equivalence. In Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-7). Volume 2923 of LNCS, Springer (2004) 87–99 8. Pearce, D.: Simplifying Logic Programs under Answer Set Semantics. In Proceedings of the 20th International Conference on Logic Programming (ICLP 2004). Volume 3132 of LNCS, Springer (2004) 210–224 9. Lin, F., Chen, Y.: Discovering Classes of Strongly Equivalent Logic Programs. In Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI 2005). (2005) 516–521 10. Le Berre, D., Narizzano, M., Simon, L., Tacchella, L.A.: The Second QBF Solvers Comparative Evaluation. In Proceedings of the 7th International Conference on Theory and Applications of Satisfiability Testing (SAT 2004). Volume 3542 of LNCS, Springer (2005) 376–392 Oetsch, J., Seidl, M., Tompits, H., Woltran, S.: An Extension of the System Testing Relativised Uniform Equivalence under Answer-Set Projection (2007) Submitted draft. 12. Zolda, M.: Comparing Different Prenexing Strategies for Quantified Boolean Formulas (2004) Master’s Thesis, Vienna University of Technology. 13. Egly, U., Seidl, M., Woltran, S.: A Solver for QBFs in Nonprenex Form. In Proceedings of the 17th European Conference on Artificial Intelligence (ECAI 2006). (2006) 477–481 14. Oikarinen, E., Janhunen, T.: Verifying the Equivalence of Logic Programs in the Disjunctive Case. In Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-7). Volume 2923 of LNCS, Springer (2004) 180–193 15. Chen, Y., Lin, F., Li, L.: SELP - A System for Studying Strong Equivalence Between Logic Programs. In Proceedings of the 8th International Conference on Logic Programming and Non Monotonic Reasoning (LPNMR 2005). Volume 3552 of LNCS, Springer (2005) 442– 446</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J Oetsch</author>
<author>M Seidl</author>
<author>H Tompits</author>
<author>Woltran</author>
</authors>
<title>S.: ccT: A Tool for Checking Advanced Correspondence Problems in Answer-Set Programming.</title>
<date>2006</date>
<booktitle>In Proceedings of the 15th International Conference on Computing (CIC</booktitle>
<pages>3--10</pages>
<publisher>IEEE Computer Society Press</publisher>
<contexts>
<context position="1762" citStr="[1]" startWordPosition="242" endWordPosition="242">., whether they yield the same result on a given problem instance. Depending on the context of problem representations, different definitions of “equivalence” are useful and desirable. The system cc⊤ [1] (short for “correspondencechecking tool”) is devised as a checker for a broad range of different such comparison relations defined between disjunctive logic programs (DLPs) under the answer-set seman</context>
</contexts>
<marker>1.</marker>
<rawString>Oetsch, J., Seidl, M., Tompits, H., Woltran, S.: ccT: A Tool for Checking Advanced Correspondence Problems in Answer-Set Programming. In Proceedings of the 15th International Conference on Computing (CIC 2006), IEEE Computer Society Press (2006) 3–10</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Gelfond</author>
<author>V Lifschitz</author>
</authors>
<title>Classical Negation in Logic Programs and Disjunctive Databases.</title>
<date>1991</date>
<journal>New Generation Computing</journal>
<volume>9</volume>
<pages>365--385</pages>
<contexts>
<context position="1970" citStr="[2]" startWordPosition="273" endWordPosition="273">rt for “correspondencechecking tool”) is devised as a checker for a broad range of different such comparison relations defined between disjunctive logic programs (DLPs) under the answer-set semantics [2]. In a previous version of cc⊤, the system was designed to test correspondence between logic programs based on relativised strong equivalence under answerset projection. Such a setting generalises the</context>
<context position="4515" citStr="[2]" startWordPosition="684" endWordPosition="684"> by I j= P, iff for every rule from P (as defined above), it holds that, whenever fal+1,..., a,,,,,} C I and fa,,,,,+1,..., arm,} n I = 0, then fa1, ..., al} n I =6 0. Following Gelfond and Lifschitz [2], an interpretation I is an answer set of a program P iff it is a minimal model of the reduct PI, resulting from P by (i) deleting all rules containing default negated atoms not a such that a G I, and</context>
</contexts>
<marker>2.</marker>
<rawString>Gelfond, M., Lifschitz, V.: Classical Negation in Logic Programs and Disjunctive Databases. New Generation Computing 9 (1991) 365–385</rawString>
</citation>
<citation valid="true">
<authors>
<author>V Lifschitz</author>
<author>D Pearce</author>
<author>Valverde</author>
</authors>
<title>A.: Strongly Equivalent Logic Programs.</title>
<date>2001</date>
<journal>ACM TOCL</journal>
<volume>2</volume>
<issue>4</issue>
<pages>526--541</pages>
<contexts>
<context position="2212" citStr="[3]" startWordPosition="310" endWordPosition="310">tem was designed to test correspondence between logic programs based on relativised strong equivalence under answerset projection. Such a setting generalises the standard notion of strong equivalence [3] by taking the alphabet of the context programs as well as the projection of the compared answer sets to a set of designated output atoms into account [4]. The latter feature ⋆ This work was partially</context>
</contexts>
<marker>3.</marker>
<rawString>Lifschitz, V., Pearce, D., Valverde, A.: Strongly Equivalent Logic Programs. ACM TOCL 2(4) (2001) 526–541</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Eiter</author>
<author>H Tompits</author>
<author>S Woltran</author>
</authors>
<title>On Solution Correspondences in Answer Set Programming.</title>
<date>2005</date>
<booktitle>In Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI</booktitle>
<pages>97--102</pages>
<contexts>
<context position="2366" citStr="[4]" startWordPosition="339" endWordPosition="339">ses the standard notion of strong equivalence [3] by taking the alphabet of the context programs as well as the projection of the compared answer sets to a set of designated output atoms into account [4]. The latter feature ⋆ This work was partially supported by the Austrian Science Fund (FWF) under grant P18019. The second author was also supported by the Austrian Federal Ministry of Transport, Inno</context>
<context position="5503" citStr="[4]" startWordPosition="856" endWordPosition="856"> in the context of hierarchically structured program components, where lower-layered components provide input for higher-layered ones. In abstracting from strong and uniform equivalence, Eiter et al. [4] introduced the notion of a correspondence problem which allows to specify (i) a context, i.e., a class of programs used to be added to the programs under consideration, and (ii) the comparison relati</context>
</contexts>
<marker>4.</marker>
<rawString>Eiter, T., Tompits, H., Woltran, S.: On Solution Correspondences in Answer Set Programming. In Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI 2005). (2005) 97–102</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Eiter</author>
<author>M Fink</author>
</authors>
<title>Uniform Equivalence of Logic Programs under the Stable Model Semantics.</title>
<date>2003</date>
<booktitle>In Proceedings of the 19th International Conference on Logic Programming (ICLP 2003). Volume 2916 of LNCS,</booktitle>
<pages>224--238</pages>
<publisher>Springer</publisher>
<contexts>
<context position="2962" citStr="[5]" startWordPosition="430" endWordPosition="430">t which are ignored in the final computation. In this paper, we outline a newly added component of ccT for testing similarly parameterised correspondence problems but generalising uniform equivalence [5]—that is, we deal with a component of ccT for testing relativised uniform equivalence under answer-set projection. This notion, recently introduced in previous work [6], is less restrained, along with</context>
</contexts>
<marker>5.</marker>
<rawString>Eiter, T., Fink, M.: Uniform Equivalence of Logic Programs under the Stable Model Semantics. In Proceedings of the 19th International Conference on Logic Programming (ICLP 2003). Volume 2916 of LNCS, Springer (2003) 224–238</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Oetsch</author>
<author>H Tompits</author>
<author>S Woltran</author>
</authors>
<title>Facts do not Cease to Exist Because They are Ignored: Relativised Uniform Equivalence with Answer-Set Projection.</title>
<date>2007</date>
<booktitle>In Proceedings of the 22nd National Conference on Artificial Intelligence (AAAI</booktitle>
<pages>458--464</pages>
<publisher>AAAI Press</publisher>
<contexts>
<context position="3130" citStr="[6]" startWordPosition="454" endWordPosition="454">eneralising uniform equivalence [5]—that is, we deal with a component of ccT for testing relativised uniform equivalence under answer-set projection. This notion, recently introduced in previous work [6], is less restrained, along with a slightly lower complexity than its strong counterpart (provided that the polynomial hierarchy does not collapse). However, in general, it is still outside a feasible</context>
<context position="6214" citStr="[6]" startWordPosition="977" endWordPosition="977">grams which are sets of facts over some set A of atoms, identified with the power set 2A over A. Thus, the concrete formal realisation of relativised uniform equivalence with projection is as follows [6]: Consider a quadruple 11 = (P, Q, 2A, OB), where P, Q are programs, A, B are sets of atoms, O E {C, =}, and S OB S′ stands for {I n B |I E S} O {J n B |J E S′}. 11 is called a propositional query equ</context>
<context position="7781" citStr="[6]" startWordPosition="1281" endWordPosition="1281">ic and to use extant solvers [10] for the latter language as back-end inference engines for evaluating the resulting formulas. The reductions required for this approach are described by Oetsch et al. [6] but ccT employs additional optimisations [11]. The overall architecture of ccT is depicted in Fig. 1. The system takes as input two programs, P and Q, and two sets of atoms, A and B. Command-line opt</context>
</contexts>
<marker>6.</marker>
<rawString>Oetsch, J., Tompits, H., Woltran, S.: Facts do not Cease to Exist Because They are Ignored: Relativised Uniform Equivalence with Answer-Set Projection. In Proceedings of the 22nd National Conference on Artificial Intelligence (AAAI 2007), AAAI Press (2007) 458–464</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Eiter</author>
<author>M Fink</author>
<author>H Tompits</author>
<author>S Woltran</author>
</authors>
<title>Simplifying Logic Programs Under Uniform and Strong Equivalence.</title>
<date>2004</date>
<booktitle>In Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-7). Volume 2923 of LNCS,</booktitle>
<pages>87--99</pages>
<publisher>Springer</publisher>
<marker>7.</marker>
<rawString>Eiter, T., Fink, M., Tompits, H., Woltran, S.: Simplifying Logic Programs Under Uniform and Strong Equivalence. In Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-7). Volume 2923 of LNCS, Springer (2004) 87–99</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Pearce</author>
</authors>
<title>Simplifying Logic Programs under Answer Set Semantics.</title>
<date>2004</date>
<booktitle>In Proceedings of the 20th International Conference on Logic Programming (ICLP 2004). Volume 3132 of LNCS,</booktitle>
<pages>210--224</pages>
<publisher>Springer</publisher>
<marker>8.</marker>
<rawString>Pearce, D.: Simplifying Logic Programs under Answer Set Semantics. In Proceedings of the 20th International Conference on Logic Programming (ICLP 2004). Volume 3132 of LNCS, Springer (2004) 210–224</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Lin</author>
<author>Y Chen</author>
</authors>
<title>Discovering Classes of Strongly Equivalent Logic Programs.</title>
<date>2005</date>
<booktitle>In Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI</booktitle>
<pages>516--521</pages>
<marker>9.</marker>
<rawString>Lin, F., Chen, Y.: Discovering Classes of Strongly Equivalent Logic Programs. In Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI 2005). (2005) 516–521</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Le Berre</author>
<author>M Narizzano</author>
<author>L Simon</author>
<author>L A Tacchella</author>
</authors>
<title>The Second QBF Solvers Comparative Evaluation.</title>
<date>2004</date>
<booktitle>In Proceedings of the 7th International Conference on Theory and Applications of Satisfiability Testing (SAT</booktitle>
<volume>3542</volume>
<pages>376--392</pages>
<publisher>Springer</publisher>
<contexts>
<context position="7611" citStr="[10]" startWordPosition="1255" endWordPosition="1255">lds. 3 System Specifics As pointed out in Section 1, the overall approach of ccT is to reduce PQEPs and PQIPs to the satisfiability problem of quantified propositional logic and to use extant solvers [10] for the latter language as back-end inference engines for evaluating the resulting formulas. The reductions required for this approach are described by Oetsch et al. [6] but ccT employs additional op</context>
</contexts>
<marker>10.</marker>
<rawString>Le Berre, D., Narizzano, M., Simon, L., Tacchella, L.A.: The Second QBF Solvers Comparative Evaluation. In Proceedings of the 7th International Conference on Theory and Applications of Satisfiability Testing (SAT 2004). Volume 3542 of LNCS, Springer (2005) 376–392</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Oetsch</author>
<author>M Seidl</author>
<author>H Tompits</author>
<author>S Woltran</author>
</authors>
<title>An Extension of the System cc⊤ for Testing Relativised Uniform Equivalence under Answer-Set Projection</title>
<date>2007</date>
<note>Submitted draft.</note>
<contexts>
<context position="7827" citStr="[11]" startWordPosition="1287" endWordPosition="1287">ter language as back-end inference engines for evaluating the resulting formulas. The reductions required for this approach are described by Oetsch et al. [6] but ccT employs additional optimisations [11]. The overall architecture of ccT is depicted in Fig. 1. The system takes as input two programs, P and Q, and two sets of atoms, A and B. Command-line options select between two kinds of reductions, a</context>
<context position="9930" citStr="[11]" startWordPosition="1662" endWordPosition="1662">tten using LEX and YACC. Further information about cc⊤ is available at http://www.kr.tuwien.ac.at/research/ccT/. Experimental evaluations using different QBF-solvers are reported in a companion paper [11]. 4 cc⊤ on Stage In this section, we give a brief and, for space reasons, rather informal discussion on an application of cc⊤ for verification and debugging needs in the context of a logic programming</context>
</contexts>
<marker>11.</marker>
<rawString>Oetsch, J., Seidl, M., Tompits, H., Woltran, S.: An Extension of the System cc⊤ for Testing Relativised Uniform Equivalence under Answer-Set Projection (2007) Submitted draft.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Zolda</author>
</authors>
<title>Comparing Different Prenexing Strategies for Quantified Boolean Formulas</title>
<date>2004</date>
<institution>Master’s Thesis, Vienna University of Technology.</institution>
<contexts>
<context position="9599" citStr="[12]" startWordPosition="1613" endWordPosition="1613">d-output device from where it can serve as input for QBF-solvers. Since cc⊤ does not output QBFs in a specific normal form, for using solvers requiring normal-form QBFs, the additional normaliser qst [12] is employed. Finally, cc⊤ is developed entirely in ANSI C; hence, it is highly portable. The parser for the input data was written using LEX and YACC. Further information about cc⊤ is available at ht</context>
</contexts>
<marker>12.</marker>
<rawString>Zolda, M.: Comparing Different Prenexing Strategies for Quantified Boolean Formulas (2004) Master’s Thesis, Vienna University of Technology.</rawString>
</citation>
<citation valid="true">
<authors>
<author>U Egly</author>
<author>M Seidl</author>
<author>S Woltran</author>
</authors>
<title>A Solver for QBFs in Nonprenex Form.</title>
<date>2006</date>
<booktitle>In Proceedings of the 17th European Conference on Artificial Intelligence (ECAI</booktitle>
<pages>477--481</pages>
<contexts>
<context position="13246" citStr="[13]" startWordPosition="2214" endWordPosition="2214">, while 26 (out of 200) components were classified as correct by the script but as non-equivalent to our sample solution by cc⊤. It is worth mentioning that on these problem instances the solver qpro [13] showed, with a median run-time of 2.54 seconds, excellent performance. 5 Conclusion In this paper, we presented the architecture and system specifics of a new component of the tool cc⊤ for testing pa</context>
</contexts>
<marker>13.</marker>
<rawString>Egly, U., Seidl, M., Woltran, S.: A Solver for QBFs in Nonprenex Form. In Proceedings of the 17th European Conference on Artificial Intelligence (ECAI 2006). (2006) 477–481</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Oikarinen</author>
<author>T Janhunen</author>
</authors>
<title>Verifying the Equivalence of Logic Programs in the Disjunctive Case.</title>
<date>2004</date>
<booktitle>In Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-7). Volume 2923 of LNCS,</booktitle>
<pages>180--193</pages>
<publisher>Springer</publisher>
<contexts>
<context position="13753" citStr="[14]" startWordPosition="2289" endWordPosition="2289">he answer-set semantics. The correspondence problems are efficiently compiled to quantified Boolean formulas for which many solvers have been implemented. As related work, we mention the system DLPEQ [14] for deciding ordinary equivalence, which is based on a reduction to logic programs, and the system SELP [15] for checking strong equivalence, which is based 4 The programs under consideration are not</context>
</contexts>
<marker>14.</marker>
<rawString>Oikarinen, E., Janhunen, T.: Verifying the Equivalence of Logic Programs in the Disjunctive Case. In Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-7). Volume 2923 of LNCS, Springer (2004) 180–193</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Chen</author>
<author>F Lin</author>
<author>L Li</author>
</authors>
<title>SELP - A System for Studying Strong Equivalence Between Logic Programs.</title>
<date>2005</date>
<booktitle>In Proceedings of the 8th International Conference on Logic Programming and Non Monotonic Reasoning (LPNMR 2005). Volume 3552 of LNCS,</booktitle>
<pages>442</pages>
<publisher>Springer</publisher>
<contexts>
<context position="13862" citStr="[15]" startWordPosition="2307" endWordPosition="2307">for which many solvers have been implemented. As related work, we mention the system DLPEQ [14] for deciding ordinary equivalence, which is based on a reduction to logic programs, and the system SELP [15] for checking strong equivalence, which is based 4 The programs under consideration are not propositional, i.e., they contain variables. Nevertheless, the domain, i.e., the set of constants that can o</context>
</contexts>
<marker>15.</marker>
<rawString>Chen, Y., Lin, F., Li, L.: SELP - A System for Studying Strong Equivalence Between Logic Programs. In Proceedings of the 8th International Conference on Logic Programming and Non Monotonic Reasoning (LPNMR 2005). Volume 3552 of LNCS, Springer (2005) 442–</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>