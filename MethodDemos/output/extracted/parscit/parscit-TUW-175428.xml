<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.8273474">
Ein hybrides Verfahren basierend auf
Variabler Nachbarschaftssuche und
Dynamischer Programmierung zur
Tourenfindung in einem Ersatzteillager mit
domänenspezifischen Nebenbedingungen
</title>
<sectionHeader confidence="0.574678" genericHeader="abstract">
DIPLOMARBEIT
</sectionHeader>
<bodyText confidence="0.549061">
zur Erlangung des akademischen Grades
</bodyText>
<note confidence="0.510126">
Diplom-Ingenieur
im Rahmen des Studiums
</note>
<author confidence="0.522971">
Software Engineering &amp; Internet Computing
</author>
<affiliation confidence="0.348236">
eingereicht von
</affiliation>
<subsectionHeader confidence="0.270842">
Thomas Misar
</subsectionHeader>
<bodyText confidence="0.435853">
Matrikelnummer 0025068
an der
Fakultät für Informatik der Technischen Universität Wien
</bodyText>
<note confidence="0.540463714285714">
Betreuung:
Betreuer: Univ.Prof. Dipl.-Ing. Dr. Günther Raidl
Mitwirkung: Univ.Ass. Mag. Dipl.-Ing. Matthias Prandtstetter
Wien, 20.04.2009
(Unterschrift Verfasser) (Unterschrift Betreuer)
Technische Universität Wien
A-1040 Wien Karlsplatz 13 Tel. +43/(0)1/58801-0 http://www.tuwien.ac.at
</note>
<page confidence="0.655121">
ii
</page>
<bodyText confidence="0.978708984615384">
Danksagung
Die vorliegende Arbeit durfte ich am Institut für Computergraphik und Algorithmen
der Technischen Universität Wien erstellen und es freut mich diese nun fertig in
Händen halten zu können.
Ich möchte mich für die Geduld und Mithilfe von Seiten Günther Raidls bedanken
und ebenso Matthias Prandtstetter großen Dank für seine Betreuung aussprechen. In
den vergangenen Monaten hat er einen besonders großen Beitrag zur Vervollständi-
gung dieser Arbeit geleistet. Natürlich gilt meine Anerkennung auch allen anderen
Personen, die von Seiten des Instituts ihren Anteil an der Entstehung dieser Arbeit
hatten.
Es ist mir weiters ein Anliegen auch all jene zu erwähnen, die mich im Laufe des
gesamten Studiums begleitet und unterstützt haben. Dazu zählen vor allem meine
Studienkollegen Christian und Gerhard, sowie gleichermaßen auch meine Eltern, die
mir zu jedem Zeitpunkt eine große Hilfe waren und Linda, der ich an dieser Stelle
für ihre Ausdauer und Motivation danken will.
iii
iv
Erklärung zur Verfassung der Arbeit
Hiermit erkläre ich, Thomas Misar, wohnhaft in 1070 Wien, Seidengasse 3/108, dass
ich diese Arbeit selbständig verfasst habe, dass ich die verwendeten Quellen und Hilfs-
mittel vollständig angegeben habe und dass ich die Stellen der Arbeit (einschließlich
Tabellen, Karten und Abbildungen), die anderen Werken oder dem Internet im Wort-
laut oder dem Sinn nach entnommen sind, auf jeden Fall unter Angabe der Quelle
als Entlehnung kenntlich gemacht habe.
Wien, 20.04.2009
(Unterschrift Verfasser)
v
vi
Kurzfassung
Im Rahmen dieser Arbeit wird eine konkrete Problemstellung aus dem Bereich der
Lagerverwaltung behandelt. Dabei soll die benötigte Zeit zum Ausfassen von Artikeln
aus dem Lager unter Berücksichtigung von domänenspezifischen Nebenbedingungen
minimiert werden. Ausgehend von durch Kunden laufend aufgegebenen Bestellungen
sollen feste Lieferzeiten eingehalten werden und Einschränkungen wie etwa Kapa-
zitätslimits oder das Vermeiden von Kollisionen zwischen Arbeitern beachtet werden.
Die für die gegebene Problemstellung zentrale Bestimmung effizienter Touren steht
im Mittelpunkt der Arbeit, welche mit Ergebnissen aus einer konkreten Implemen-
tierung des vorgestellten Ansatzes abschließt.
Es wird ein Algorithmus vorgestellt, der ein eigens entwickeltes Dynamisches Pro-
gramm zur Berechnung optimaler Wege durch das Warenlager mit der Umsetzung
einer Variablen Nachbarschaftssuche (engl.: Variable Neighborhood Search) (VNS)
verbindet. In mehreren Phasen werden dabei die vorliegenden Bestellungen zerlegt
und davon ausgehend Touren gebildet, welche zuletzt auf alle verfügbaren Lagerar-
beiter verteilt werden. Innerhalb der VNS kommt eine Variante des Variable Neigh-
borhood Descent (VND) als lokale Verbesserungskomponente zum Einsatz. Während
über die definierten Nachbarschaftsstrukturen unterschiedliche potentielle Lösungen
erzeugt werden, erfolgt deren Bewertung durch die Berechnung von konkreten Touren
mittels eines für diesen Zweck entwickelten Dynamischen Programms. Dabei werden
spezielle Eigenschaften der zugrundeliegenden Lagerstruktur ausgenutzt, um so in po-
lynomieller Zeit die bestmögliche Wegführung durch das Lager berechnen zu können.
Für die Zuordnung von Arbeitern zu den auf diese Weise berechneten Touren wird
schließlich eine zusätzliche VNS verwendet, deren Aufgabe es ist, die notwendigen
Touren derart zu verteilen, dass der letzte Artikel zum frühest möglichen Zeitpunkt
ausgefasst werden kann.
Die anhand des implementierten Programms durchgeführten Tests zeigen, dass die
erfolgte Tourenplanung wertvolle Ergebnisse liefert und die notwendige Rechenzeit
niedrig gehalten werden kann. Getestet wurde mit Bezug auf eine Referenzlösung,
welche auf Basis eines aus der Literatur entnommenen Ansatzes erzeugt werden konn-
te. Eine ausführliche Auswertung der Testergebnisse zeigte, dass die Anwendung des
hier vorgestellten Ansatzes im Echtbetrieb als sehr vielversprechend gilt und er-
hebliche Einsparungen bezüglich der benötigten Arbeitszeit erreicht werden können.
Insgesamt betrachtet wird ein effizientes und zielführendes Verfahren zur Lösung des
vorliegenden Problems vorgestellt.
vii
viii
</bodyText>
<sectionHeader confidence="0.981704" genericHeader="keywords">
Abstract
</sectionHeader>
<bodyText confidence="0.977713392857143">
Within this thesis a real-world problem related to a warehouse for spare parts is
considered. Regarding several constraints typically stated by spare parts suppliers the
time needed to collect articles should be minimized. Based on continuously arriving
orders by customers predefined delivery times and capacity constraints have to be
met. To accomplish this task efficient pickup tours need to be determined which is
the main issue covered by this work which comes to an end with experimental results
of a concrete implementation of the proposed approach.
The algorithm presented embeds a specifically developed dynamic program for com-
puting optimal walks through the warehouse into a general variable neighborhood
search (VNS) scheme. Several stages are used for first splitting up all orders, then
creating tours out of the results and finally assigning them to available workers. The
VNS uses a variant of the variable neighborhood descent (VND) as local improve-
ment procedure. While the neighborhood structures defined are intended to produce
candidate solutions, a dynamic program specially designed to compute optimal order
picking tours is used to evaluate them. For this purpose properties specific to ware-
houses are exploited such to compute optimal routes within polynomial time. The
final assignment of workers to tours is realized by another VNS. The task is then to
find an allocation such that the last article to be picked up will be collected as early
as possible.
Evaluations of experimental results of a concrete implementation indicate that the
presented approach provides valuable pickup plans and computation times can be
kept low. Moreover the performed test runs have been compared to a reference so-
lution which was computed based on an approach found in relevant literature. A
detailed analysis of the obtained results showed that the application of the proposed
approach to real-world instances is promising whereas the savings with respect to
working time can be kept high. Overall an efficient as well as effective approach is
introduced to solve this real-world problem.
ix
</bodyText>
<page confidence="0.535852">
X
</page>
<sectionHeader confidence="0.500454" genericHeader="introduction">
Inhaltsverzeichnis
</sectionHeader>
<table confidence="0.976030257142857">
1 Einleitung 1
2 Problembeschreibung 3
3 Verwandte Arbeiten 9
3.1 Vehicle Routing Problem 10
3.1.1 Capacitated Vehicle Routing Problem 10
3.1.2 Split Delivery Vehicle Routing Problem 11
3.1.3 Vehicle Routing Problem with Time Windows 11
3.2 Generalisierte Netzwerkprobleme 12
3.3 Traveling Salesman Problem 12
3.4 Bekannte Lösungsansätze 13
4 Dynamische Programmierung 15
5 Variable Nachbarschaftssuche 17
5.1 Lokale Suche und Shaking 18
5.2 Genereller Ansatz für die Variable Nachbarschaftssuche 20
6 Ein hybrides Verfahren 23
6.1 Der grundsätzliche Ablauf 23
6.2 Variable Nachbarschaftssuche und Dynamische Programmierung . . . 24
7 Der Algorithmus im Detail 27
7.1 Partitionierung vorhandener Bestellungen 27
7.2 Zuordnung von Artikeln zu Touren 27
7.2.1 Konstruktionsheuristiken 28
7.2.2 Reparatur- und Verbesserungsheuristik 30
7.2.3 Durchsuchen der Nachbarschaften 35
7.2.4 Dynamische Reihenfolge der Nachbarschaften 36
7.3 Berechnung einzelner Touren 38
7.3.1 Repräsentation als Graph 38
7.3.2 Ein Dynamisches Programm 39
7.3.3 S-Shape-Heuristik 45
7.4 Zuordnung von Arbeitern zu Touren 46
7.4.1 Konstruktionsheuristik 47
xi
Inhaltsverzeichnis
7.4.2 Reparatur- und Verbesserungsheuristik 48
7.5 Erweiterter Algorithmus 48
8 Testergebnisse 51
</table>
<address confidence="0.820871833333333">
8.1 Wahl der Konstruktionsheuristik 51
8.2 Wahl von Berechnungsparametern 53
8.3 Effizienz einzelner Nachbarschaften 56
8.4 Rechenzeit der Nachbarschaften 57
8.5 Laufzeit und Lösungsverbesserung 60
8.6 Lösungsqualität bei Verwendung zusätzlicher Nachbarschaften . . . 60
</address>
<sectionHeader confidence="0.720973" genericHeader="method">
9 Fazit 65
</sectionHeader>
<subsectionHeader confidence="0.451279">
Literaturverzeichnis 67
</subsectionHeader>
<bodyText confidence="0.573601">
xii
</bodyText>
<sectionHeader confidence="0.992933" genericHeader="method">
1 Einleitung
</sectionHeader>
<bodyText confidence="0.999582970588235">
Die vorliegende Arbeit ist aus einer Zusammenarbeit des Instituts für Computergra-
phik und Algorithmen der Technischen Universität Wien mit der Firma Dataphone
GmbH entstanden, welche sich mit Problemen der Lagerverwaltung auseinandersetzt
und in diesem Fall Aufgaben innerhalb des Lagers eines Ersatzteillieferanten analy-
sieren soll. Neben der Verwaltung sämtlicher Stammdaten und Auftragsdaten des
Lagers gilt es, die tatsächliche Anordnung von Artikeln im Lager zu erfassen und
davon ausgehend die benötigte Zeit zum Ausfassen von bestellten Artikeln (im Wei-
teren wird dieser Vorgang auch Kommissionierung genannt) zu minimieren. Dadurch
müssen auch die Arbeitsschritte des Lagerpersonals berücksichtigt und im System
abgebildet werden.
Der Aufbau des Lagers gleicht im Wesentlichen dem, was man sich gemeinhin beim
Gedanken an ein Warenlager vorstellt. Es sind parallel zueinander angeordnete Re-
gale vorhanden, zwischen denen jeweils Gänge verlaufen, um entsprechend lagernde
Artikel ausfassen zu können. An den beiden Enden jedes dieser Regalgänge verlaufen
orthogonal dazu etwas breitere Hauptgänge (siehe dazu Abb. 1.1). Innerhalb die-
ses Gangsystems bewegen sich dann meist mehrere Arbeiter gleichzeitig, die unter
Zuhilfenahme von Kommissionierungswagen diverse Artikel einsammeln. Welche Ar-
tikel benötigt werden, ergibt sich aus den jeweils vorliegenden Bestellungen, welche
im Laufe des Arbeitstages durch Kunden in Auftrag gegeben werden. Da der Er-
satzteillieferant gewisse Lieferzeiten einhalten will und muss, ist eine entsprechend
effiziente Bearbeitung der Aufträge notwendig. Sobald die verlangten Artikel einge-
sammelt wurden, werden sie zu einer zentralen Stelle im Lager, der Verdichtungszone,
gebracht, wo sie verpackt und für den Versand an die Kunden vorbereitet werden.
Ohne Unterstützung durch ein entsprechendes System obliegt es nun dem Lager-
leiter die vorhandenen Aufträge auf seine Mitarbeiter derart aufzuteilen, dass in
möglichst kurzer Zeit die gewünschten Artikel in der Verdichtungszone bereitstehen.
Die Reihenfolge, in der Artikel ausgefasst werden, ist nicht weiter vorgegeben und
so entscheidet jeder Lagerarbeiter selbst über seinen Weg durch das Lager. Diese
Wege oder Touren durch das Lager sind nun genau jener Teil innerhalb des gesamten
Bestellablaufs, der großes Optimierungspotential bietet.
Ziel der Arbeit ist es, das Ressourcenmanagement innerhalb des Lagers dahingehend
zu optimieren, dass zunächst die Zusammenstellung von einzusammelnden Artikeln
geschickt gewählt wird und damit im Weiteren das Erstellen von dafür kürzest mögli-
chen Touren einen erheblichen Vorteil in der Planung des Ablaufs bringt. Ein wesent-
</bodyText>
<page confidence="0.758812">
1
</page>
<sectionHeader confidence="0.486009" genericHeader="method">
1 Einleitung
</sectionHeader>
<bodyText confidence="0.976759357142857">
Abbildung 1.1: Schematische Darstellung des Lagers
licher Beitrag dazu ist ein von mir im Rahmen dieser Arbeit erstelltes Programm,
das der Umsetzung sämtlicher Überlegungen innerhalb einer Heuristik dient. Dabei
wird die vorhandene Problemstellung in vier algorithmischen Schritten bearbeitet.
Es wird anhand bestimmter Kriterien, wie etwa Lieferzeit oder Platzbedarf eines
Artikels, bestimmt, welche Artikel innerhalb einer Tour eines Arbeiters im Lager
eingesammelt werden sollen. Der Schritt zur Berechnung von Touren ist dabei ein
zentraler Bestandteil des Algorithmus und wurde mittels eines speziell entwickelten
Dynamischen Programms umgesetzt. Sobald alle benötigten Touren berechnet wur-
den, können diese auf alle verfügbaren Lagermitarbeiter aufgeteilt werden, was im
letzten Schritt erfolgt.
Im Anschluss an die Beschreibung des Algorithmus kann man anhand der Testergeb-
nisse sehen, dass die Effizienz des Programms einen durchwegs positiven Eindruck
vermittelt. Große Probleminstanzen können zwar sehr lange Laufzeiten im Bereich
von mehreren Stunden benötigen, bis der Algorithmus keine weitere Verbesserung
bringt, allerdings werden schon innerhalb der ersten Minuten gute Lösungen erzeugt
und somit bleibt der Einsatz in der Praxis vielversprechend.
Zuerst werde ich nun eine detaillierte Problembeschreibung geben, die als Basis für
meine Untersuchungen gedient hat. Im Anschluss daran möchte ich anhand von ver-
wandten Arbeiten aus der Literatur einen Überblick über den Rahmen geben, in dem
sich diese Arbeit bewegt. Ich werde im Weiteren beschreiben, aus welchen Teilen der
letztlich verwendete Algorithmus aufgebaut ist und mit welchen Methoden der zuvor
beschriebenen Arbeiten hierbei vorgegangen wird, wobei auch diese, wo sinnvoll und
passend, im Detail behandelt werden. Im Zuge der Erläuterungen zum algorithmi-
schen Verlauf, werde ich auch auf einige spezielle Probleme eingehen, die in diesem
Zusammenhang zu lösen waren. Abschließend werden dann die Ergebnisse, die mit
dem vorhandenen Programm erzielt werden konnten und aufgrund statistischer Aus-
wertungen mehrerer Testläufe zustande gekommen sind, die Arbeit abschließen.
</bodyText>
<figure confidence="0.848165">
Regal
Regalgang
Hauptgang
VZ Verdichtungszone
VZ
</figure>
<page confidence="0.990029">
2
</page>
<sectionHeader confidence="0.994434" genericHeader="method">
2 Problembeschreibung
</sectionHeader>
<bodyText confidence="0.9981608125">
Die folgende Aufgabenstellung stammt in ihrer ursprünglichen Form von der Firma
Dataphone GmbH und wurde in Zusammenarbeit mit Mitarbeitern des Instituts für
Computergraphik und Algorithmen der Technischen Universität Wien angepasst, um
innerhalb eines gemeinsamen Projekts einen Lösungsansatz dafür zu entwerfen.
Im Zuge der Reorganisation und Erweiterung des Lagers eines Ersatzteillieferanten
soll eine automationstechnisch unterstützte Lagerverwaltung eingeführt und ausge-
baut werden, die unter anderem die Möglichkeit bieten soll, einzelne Prozessabläufe
im Lageralltag zu rationalisieren. Zu diesem Zweck wurden sämtliche Artikel bezie-
hungsweise jene Ladungsträger, auf denen sich die Artikel befinden, mit maschinen-
lesbaren Kodierungen, konkret mit Barcodes, versehen und eine zentrale Lagerver-
waltungssoftware eingeführt. Auf Basis einer im Hintergrund eingerichteten Daten-
bank erlaubt die grafische Oberfläche der Software die Erfassung und Verwaltung
von Stammdaten und Bestelldaten sowie den Zugriff auf den aktuellen Lagerstand.
In einer ersten Ausbaustufe soll vor allem die Zusammenstellung der einzelnen von
Kunden in Auftrag gegebenen Bestellungen möglichst effizient realisiert werden, wo-
bei folgende Schritte zu berücksichtigen sind:
</bodyText>
<listItem confidence="0.898145571428571">
1. Ein Kunde gibt eine Ersatzteillieferung in Auftrag.
2. Für jeden Auftrag fasst ein Lagerarbeiter die erforderliche Anzahl der bestellten
Artikel aus dem Lager aus und bringt sie in eine so genannte Verdichtungszone.
3. Ein dieser Verdichtungszone zugeteilter Mitarbeiter packt alle zu den jeweili-
gen Bestellungen gehörenden Einzelteile in entsprechend dimensionierte Kisten,
versieht diese mit Adresstickets und leitet sie an den Lieferanten (Paketdienst,
Post, etc.) weiter.
</listItem>
<bodyText confidence="0.999725666666667">
Während der erste und der dritte Punkt dieser Abarbeitungsreihenfolge derzeit schon
verlässlich und ohne gröbere Verzögerungen ablaufen, stellt der zweite Punkt den
Flaschenhals in der Zusammenstellung der Aufträge dar, da hierbei die Mitarbeiter
große Strecken im Lager zurücklegen müssen, um alle Einzelteile einzusammeln. Da
im Normalfall bis zu sechs Mitarbeiter gleichzeitig an bis zu 1000 täglichen Aufträgen
bestehend aus je fünf unterschiedlichen Artikeln arbeiten, gibt es durch geschickte
Aufteilung der Aufträge ein großes Einsparungspotential, sofern eine geschickte Ein-
teilung von Artikeln zu Touren vorgenommen wird. Folgender neu gestalteter Ablauf
soll daher realisiert werden:
</bodyText>
<page confidence="0.948113">
3
</page>
<listItem confidence="0.8314730625">
2 Problembeschreibung
1. Mehrere Kunden geben (unabhängig voneinander) jeweils eine Ersatzteilliefe-
rung in Auftrag.
2. Alle derzeit im Lager tätigen Mitarbeiter bekommen jeweils eine Liste von
Artikeln, die sie entlang einer vorberechneten Tour im Lager auf Kommissio-
nierungswagen laden sollen. Diese Artikel können im Allgemeinen auch zu un-
terschiedlichen Aufträgen gehören.
3. Nach Abarbeitung dieser Liste stellt jeder Mitarbeiter den von ihm bedienten
Kommissionierungswagen in der Verdichtungszone ab und entnimmt dort einen
weiteren, allerdings leeren Kommissionierungswagen, um sich auf eine neue
Tour zum Ausfassen weiterer Artikel zu machen.
4. Der Mitarbeiter in der Verdichtungszone verfährt weiterhin so, dass er alle
Artikel eines Auftrags in entsprechende Schachteln verpackt und an den Bo-
tendienst übergibt. Dabei muss er allerdings beachten, dass nun die Artikel, die
einer Bestellung zugeordnet sind, auf unterschiedlichen Kommissionierungswa-
gen zwischengelagert sein können.
</listItem>
<bodyText confidence="0.99991888">
Die Verdichtungszone selbst (siehe Abb. 2.1) ist in drei Zonen unterteilt, die als eine
Art Zwischenlager verstanden werden können. Von dort holen die Lagermitarbeiter
leere Kommissionierungswagen, um Artikel aus dem Lager auszufassen und stellen
diese befüllt wieder dort ab. Mitarbeiter, die für Verpackung und Versand zuständig
sind, können dann von dort die entsprechenden Waren abholen und die Bestellabwick-
lung fortsetzen. Da diese einzelnen Zonen entsprechend weitläufig sind, um genügend
Platz zu bieten, ist vorgesehen, dass alle zu einer Bestellung gehörigen Artikel inner-
halb derselben Zone abgeliefert werden sollen. Dies verringert den Zeitaufwand für
die Verpackung und macht die Arbeit in der Verdichtungszone wesentlich einfacher
und effizienter.
Gegenstand dieser Arbeit ist nun die Entwicklung eines Lösungsansatzes, mit dessen
Hilfe es möglich wird, die Aufteilung der Bestellungen auf unterschiedliche Mitarbei-
ter derart zu optimieren, dass die Touren der Kommissionierer möglichst kurz wer-
den, wodurch gleichzeitig der zeitliche Abstand zweier Entnahmen einzelner Artikel
aus dem Lager minimiert wird. Ausschlaggebend hierfür ist, dass durch diese Auf-
teilung der Bestellungen auf mehrere gleichzeitig im Lager arbeitende Personen bei
entsprechender Optimierung große Einsparungen erreicht werden können, da für die
Mitarbeiter besser organisierte Touren mit kürzeren Wegen möglich sind. Weiters soll
erreicht werden, dass die jeweils zu einer gemeinsamen Bestellung gehörenden Artikel
ungefähr zeitgleich in der Verdichtungszone bereitgestellt und im Weiteren verpackt
werden, um mehrere Aufträge ohne den Einsatz größerer Zwischenlager gleichzeitig
bearbeiten zu können.
Neben dieser prinzipiellen Aufgabenstellung müssen jedoch noch mehrere Nebenbe-
dingungen berücksichtigt werden, die einen entscheidenden Einfluss auf die tatsächli-
che Realisierung der einzelnen Kommissionierungstouren haben:
</bodyText>
<page confidence="0.955074">
4
</page>
<figure confidence="0.998593714285715">
VZ1
VZ2
VZ3
Verdichtungszone
W
Stellplatz für Kommissionierungswagen
W W W W W W W
W W
W W
W W
W W
W W
W
W
W
W
W
W
W
W
W
W
W W
W W
W W
W W
W W
W
W
W
W
W
W
Verpackung
&amp; Versand
</figure>
<listItem confidence="0.971382964285714">
Abbildung 2.1: Schematische Darstellung der Verdichtungszone
• Die Kommissionierungswagen können einerseits nur bis zu einer gewissen Ka-
pazität beladen werden und andererseits ist es aufgrund ihrer Bauweise nur
vorgesehen, dass sie sich in eine Richtung bewegen. Wegen des schmalen Gang-
systems ist ein Umkehren innerhalb eines Ganges nicht ohne Weiteres möglich.
• Die Überkreuzung zweier Kommissionierungstouren innerhalb eines Regalgan-
ges sollte möglichst vermieden werden, da aufgrund der Platzbeschränkung ein
¨Uberholen oder aneinander Vorbeifahren nicht möglich ist.
• Manche Artikel können an mehreren Positionen im Lager verfügbar sein. Ab-
hängig von der bestellten Menge müssen oder können dann unter Umständen
auch mehrere solcher Lagerplätze für einen Artikel angefahren werden.
• Einen weiteren Aspekt birgt die Tatsache, dass nicht alle an einem Tag zu
bearbeitenden Bestellungen zu Arbeitsbeginn bereits bekannt sind, da noch
im Laufe des Tages weitere Bestellungen eintreffen können. Dies entspricht
sogar eher dem Normalfall, wodurch Anzahl und Struktur der zu bearbeitenden
Aufträge im Laufe des Tages stark variieren. Ein Lösungsansatz soll das insofern
berücksichtigen, als die Berechnungen jederzeit mit angepassten Eingabewerten
wieder gestartet werden können sollen. Das heißt, es wird immer mit den aktuell
offenen Bestellungen neu gerechnet.
• Die Bearbeitung von Bestellungen sollte nach Möglichkeit in der Reihenfolge
ihres Eintreffens geschehen, um die Lieferzeiten möglichst sicher einhalten zu
können.
5
2 Problembeschreibung
• Die zuvor beschriebene Einteilung der Verdichtungszone in drei Zonen muss
derart berücksichtigt werden, dass von den Kommissionierern ausnahmslos alle
zu einer Bestellung gehörigen Artikel in derselben dieser drei Zonen abgeliefert
werden.
</listItem>
<bodyText confidence="0.996695857142857">
Durch mobile Datenerfassungsgeräte soll der Optimierungsprozess unterstützt wer-
den, da der Einsatz dieser Geräte es ermöglicht, die Entnahme eines Artikels be-
ziehungsweise Abgabe eines Kommissionierungswagens in der Verdichtungszone in
Echtzeit nachzuvollziehen. Dieses neue Lagerverwaltungssystem soll das derzeitige
Verfahren ablösen, bei dem alle Entscheidungen durch Mitarbeiter getroffen werden.
Unter Berücksichtigung dieser Einschränkungen gilt es nun vorrangig die Berechnung
von kürzesten Touren für die Mitarbeiter zu behandeln.
</bodyText>
<subsectionHeader confidence="0.700267">
Mögliche Erweiterungen
</subsectionHeader>
<bodyText confidence="0.9995365">
Die folgende Auflistung eröffnet mögliche Erweiterungen der gegebenen Problem-
beschreibung, wobei deren Umsetzung aufgrund von massivem Mehraufwand nicht
erfolgte. Überdies beeinflussen diese Aspekte den Kern der Arbeit nicht, wodurch die
zentralen Ergebnisse des vorgestellten Verfahrens ihre Aussagekraft behalten.
</bodyText>
<listItem confidence="0.965973925">
Folgende Punkte sind als zusätzliche Funktionalitäten und Optionen denkbar:
• Die im Lager verfügbaren Kommissionierungswagen haben durchaus unter-
schiedliche bauartliche Voraussetzungen, was sich auf damit verbundene Eigen-
schaften, wie Geschwindigkeit, Ladefläche oder Manövrierfähigkeit, auswirkt.
Ein entwickelter Lösungsansatz dafür sollte dann genügend Flexibilität aufwei-
sen, um damit umgehen zu können. Die Palette an Transportmitteln reicht
dabei von ”einkaufswagenähnlichen“ Fahrzeugen bis hin zu Gabelstaplern.
• Die eingeschränkte Bewegungsfreiheit aufgrund der sehr schmalen Gänge im
Lager verhindert es, dass zwei Kommissionierungswagen aneinander vorbeifah-
ren können. Um Kollisionen auszuschließen, wäre es denkbar einen Algorithmus
zu entwerfen, der entsprechende Zustände verbietet.
• Ein weiterer Punkt in Zusammenhang mit den im Lager verwendeten Fahrzeu-
gen bezieht sich auf die Sicherheitsbestimmungen in Bezug auf Gabelstapler.
Diese schreiben es prinzipiell vor, dass sich in einem Gang kein anderer Mit-
arbeiter gleichzeitig mit einem Gabelstapler aufhalten darf. Die Sperrung von
solchen Gängen muss dann natürlich berücksichtigt werden.
• Es kann der Fall auftreten, dass der Lagerleiter befindet, einen Lagerplatz
mit einem anderen Artikel belegen zu wollen. In einem solchen Fall muss die
Möglichkeit gegeben sein, dass der anderweitig benötigte Lagerplatz möglichst
schnell (gleichzeitig aber kosteneffizient) leer geräumt wird.
6
• Weiters liegt durch das ständige Eintreffen von Bestellungen im Laufe eines Ar-
beitstages der Anspruch an eine Online-Optimierungsaufgabe nahe. Das heißt,
dass aktuell eintreffende Bestellungen jederzeit in den Optimierungsprozess
aufgenommen werden können müssen. Im Unterschied zu einem kompletten
Neustart der Berechnungen müssen in diesem Fall die bereits getätigten Opti-
mierungen in den weiteren Verlauf des Programms einfließen.
• Außerdem kann es vorkommen, dass während der Zusammenstellung der einzel-
nen Aufträge unvorhersehbare Vorkommnisse auftreten, auf die entsprechend
reagiert werden muss. Artikel können beispielsweise fehlerhaft, kaputt oder gar
nicht vorhanden sein. In einem solchen Fall muss der entsprechende Artikel
von einer anderen Position im Lager entnommen werden oder möglicherweise
sogar neu eingelagert werden. Wenn ein Lagerarbeiter mehr Zeit benötigt als
angenommen, verzögert sich natürlich auch die Kommissionierung und entspre-
chende Änderungen müssen berücksichtigt werden
• Eine zusätzliche Straffung der Nebenbedingungen ist durch die Garantie des
Ersatzteillieferanten gegeben, fixe Lieferzeiten an seine Kunden einzuhalten.
Diese sind auf alle Fälle einzuhalten. Es muss daher sichergestellt sein, dass
jeder Auftrag bis zu einem vorgegebenen Termin verpackt ist, um verschickt
werden zu können.
</listItem>
<page confidence="0.9923165">
7
8
</page>
<sectionHeader confidence="0.995033" genericHeader="method">
3 Verwandte Arbeiten
</sectionHeader>
<bodyText confidence="0.999960314285714">
Aus der detaillierten Problemspezifikation folgt unmittelbar, dass es sich bei dieser
Aufgabenstellung um ein mit dem Vehicle Routing Problem (VRP) [18] verwand-
tes Problem handelt, das zu den im klassischen VRP definierten Nebenbedingungen
noch weitere domänenspezifische Einschränkungen enthält. Die ursprüngliche Varian-
te des VRP verlangt, dass ausgehend von einem Depot Kunden mit unterschiedlichen
Bestellungen beliefert werden müssen. Um den Transport des Ladeguts zu gewähr-
leisten, steht eine Flotte von Lkws zur Verfügung. Gesucht ist eine Einteilung von
Lkws zu Kunden, sodass die insgesamt zurückgelegte Wegstrecke der Lieferfahrzeuge
minimiert wird. Auch Parallelen zu in der Literatur häufig auftretenden Varianten
des VRP können festgestellt werden. Zum Beispiel darf beim Capacitated VRP jeder
Lkw nur eine gewisse Last transportieren, beim Split Delivery VRP dürfen hingegen
alle Kunden von beliebig vielen Lkws angefahren werden. Es konnte allerdings keine
Arbeit gefunden werden, die alle diese Varianten ineinander vereint und zusätzlich
noch die bereits beschriebenen domänenspezifischen Nebenbedingungen, wie etwa die
beschränkte Breite von Gängen, berücksichtigt.
Neben der offensichtlichen Verwandtschaft mit Varianten des VRP, besteht auch eine
Verbindung zu Generalisierten Netzwerkproblemen [9]. So kann die Möglichkeit einen
Artikel von unterschiedlichen Lagerplätzen zu holen als implizite Clusterbildung ver-
standen werden. Jeweils nur ein Knoten aus einem solchen Cluster soll besucht wer-
den. Unter diesem Blickwinkel ist eine Verbindung zum Generalized Traveling Sales-
man Problem (GTSP) [10] offensichtlich, bei dem es gilt, jeweils einen Knoten pro
Cluster auszuwählen und anschließend eine Tour zu berechnen, sodass jeder Cluster
genau einmal besucht wird.
Wie später genauer erklärt wird, basiert der hier vorgeschlagene Lösungsansatz auf
Variabler Nachbarschaftssuche (engl.: Variable Neighborhood Search) (VNS) [12] mit
integriertem Variable Neighborhood Descent (VND). Bei VNS/VND handelt es sich
um Metaheuristiken, die auf der Idee aufbauen, dass ein globales Optimum stets
ein lokales Optimum bezüglich aller möglichen Nachbarschaftsfunktionen ist. Unter
einer Nachbarschaftsfunktion versteht man eine Rechenvorschrift, die es ermöglicht
aus einer gegebenen Lösung x eine neue Lösung x&apos; zu berechnen, wobei sich x und
x&apos; nur in einigen (wenigen) Merkmalen unterscheiden. VND durchsucht systematisch
eine Menge von gegebenen Nachbarschaften, um so zu einer möglichst guten Lösung
zu gelangen. Weiters wird durch VNS ein so genannter Shaking-Mechanismus ange-
wendet, der dazu dient, festgefahrene Suchläufe durch das Einbringen von zufälligen
Änderungen zu verbessern.
</bodyText>
<page confidence="0.865954">
9
</page>
<sectionHeader confidence="0.735399" genericHeader="method">
3 Verwandte Arbeiten
</sectionHeader>
<bodyText confidence="0.35577">
Abbildung 3.1: Vehicle Routing Problem (VRP)
</bodyText>
<subsectionHeader confidence="0.999535">
3.1 Vehicle Routing Problem
</subsectionHeader>
<bodyText confidence="0.999866818181818">
Beim klassischen Vehicle Routing Problem (VRP) handelt es sich um eine aus der
Transportlogistik stammende Problemstellung, welche die Verteilung von Gütern aus-
gehend von einem Depot an Kunden mit unterschiedlichen Standorten beschreibt
(siehe Abb. 3.1). Dabei fordert jeder Kunde eine gewisse Menge eines bestimmten
Gutes an. Das angestrebte Ziel hierbei ist es, Routen in der Form zu erstellen, dass
die Gesamtkosten zur Anlieferung aller Güter minimiert werden. Natürlich kann die-
se Formulierung auch entsprechend umgekehrt werden und so nicht Kunden beliefert
werden, sondern gewisse Güter eingesammelt werden. In der Regel unterliegt die
Routenerstellung gewissen Kriterien, wie etwa der Kapazität des jeweiligen Trans-
portmittels oder zeitlichen Einschränkungen. Das VRP gehört in die Klasse der NP-
schweren Probleme.
</bodyText>
<subsectionHeader confidence="0.834019">
3.1.1 Capacitated Vehicle Routing Problem
</subsectionHeader>
<bodyText confidence="0.993495">
Eine Variante des VRP ist das Capacitated Vehicle Routing Problem (CVRP) [17],
welches die Kapazitäten der verwendeten Fahrzeuge einschränkt. Das in [17] beschrie-
bene CVRP verlangt die Auslieferung eines einzigen Gutes an n Kunden ausgehend
von einem Depot {0} unter Verwendung von k unabhängigen Transportmitteln mit
jeweils identischer Kapazität C, wobei jedem Kunden i ∈ N = {1, ... , n} die Menge
di zugestellt wird. Aus kombinatorischer Sicht handelt es sich bei der Lösung um eine
Aufteilung {R1, ... , Rk} von N in k Routen, wobei jede dieser Routen Ej∈Ri dj &amp;lt; C,
1 &amp;lt; i &amp;lt; k erfüllen muss.
Zum klassischen, bereits NP-schweren VRP kommen also noch zusätzliche Ein-
schränkungen hinzu, welche zu berücksichtigen sind. Das Problem wird dadurch al-
lerdings nicht leichter.
</bodyText>
<figure confidence="0.982781">
4
5
3
2 1
6
Depot
12
7
9
8
11
10
</figure>
<page confidence="0.8035">
10
</page>
<subsectionHeader confidence="0.927743">
3.1 Vehicle Routing Problem
3.1.2 Split Delivery Vehicle Routing Problem
</subsectionHeader>
<bodyText confidence="0.98763747368421">
Das Split Delivery Vehicle Routing Problem (SDVRP) [2] beschreibt jene Form des
VRP, bei der ein Kunde mehrmals angefahren werden darf oder sogar muss. Wieder
sind mehrere Lieferanten im Einsatz und jedes Transportmittel hat die gleiche Ka-
pazität. Nun kann es allerdings vorkommen, dass die benötigte Menge eines Kunden
die Kapazität eines einzelnen Transportmittels übersteigt oder aber auch einfach aus
Effizienzgründen zwei Lieferanten einen Kunden mit Teillieferungen beliefern.
Wie bereits bei Dror und Trudeau in [7] und [8] gezeigt, können durch die Aufteilung
von Lieferungen beträchtliche Einsparungen erzielt werden, sowie auch die Anzahl
an Lieferanten reduziert werden. Dennoch bleibt das Problem an sich NP-schwer.
Die meisten Lösungsansätze gehen von der Annahme aus, dass die so genannte Drei-
ecksungleichung erfüllt ist. Geht man von der Kostenberechnung auf Basis von Weg-
strecken aus, so bedeutet dies, dass der direkte Weg zwischen zwei Knoten immer
der kostengünstigste ist. Formal lässt sich das ganz leicht durch
cij + cjk &gt;_ cik , mit i, j, k e {1, ... , n}
ausdrücken, wobei n die Anzahl an Kunden repräsentiert und cij die Kosten für den
Weg von Kunde i zu Kunde j angibt. Es wird dabei angenommen, dass cij = cji gilt.
Ein interessanter Aspekt der zuvor erwähnten Arbeiten [7] und [8] ist die Erkenntnis,
dass es bei geltender Dreiecksungleichung eine optimale Lösung gibt, bei der je zwei
Routen nie mehr als zwei gemeinsame Zielorte mit Teillieferungen anfahren.
</bodyText>
<subsectionHeader confidence="0.950995">
3.1.3 Vehicle Routing Problem with Time Windows
</subsectionHeader>
<bodyText confidence="0.9996964">
Eine weitere Variante des VRP behandelt jene Problemstellung, bei der die Kunden
innerhalb eines definierten Zeitfensters beliefert werden müssen. Bei diesem Problem,
dem Vehicle Routing Problem with Time Windows (VRPTW) [19], kann sich die
Reihenfolge der zu beliefernden Kunden daher nicht ausschließlich aus den Routen
mit kürzesten Wegen definieren, sondern wird zusätzlich von einer zeitlichen Be-
schränkung beeinflusst. Auch dieses kombinatorische Problem ist NP-schwer und ist
als Erweiterung des klassischen VRP eine sehr häufig vorkommende Problemstellung
im Bereich der Logistik, wo es neben der Belieferung aller Kunden mit minima-
len Kosten nun auch zu berücksichtigen gilt, dass jeder Kunde nur innerhalb eines
Zeitfensters [ai, bi] beliefert werden kann, wobei ai der früheste und bi der späteste
Zeitpunkt ist, zu dem Kunde i beliefert werden kann.
Da das Ziel die Minimierung des notwendigen Zeitaufwandes ist, muss die Dreiecksun-
gleichung in konkreten Szenarien meist nicht erfüllt werden, da kürzere Strecken nicht
immer gleichbedeutend mit kürzerem Zeitaufwand sind. Das heißt, dass tij+tjk &gt;_ tik,
wobei tij den Zeitaufwand für die Strecke von Kunde i zu Kunde j bezeichnet, in
</bodyText>
<page confidence="0.984192">
11
</page>
<sectionHeader confidence="0.739945" genericHeader="method">
3 Verwandte Arbeiten
</sectionHeader>
<bodyText confidence="0.650256">
diesem Fall nicht zwingend gilt.
</bodyText>
<subsectionHeader confidence="0.999508">
3.2 Generalisierte Netzwerkprobleme
</subsectionHeader>
<bodyText confidence="0.999935785714286">
Zur Klasse der Netzwerkprobleme zählt man unter anderen das Minimum Spanning
Tree Problem, das Traveling Salesman Problem sowie das Problem kürzester Wege.
Allgemein besteht die Aufgabe bei einem Netzwerkproblem darin, einen optimalen
Teilgraphen F eines Graphen G unter Einhaltung gewisser Randbedingungen zu fin-
den. Wenn man nun von Generalisierten Netzwerkproblemen spricht, so werden dabei
die Knoten des Graphen G in Gruppen (engl.: Cluster) eingeteilt und die Randbe-
dingungen auf dieser Basis formuliert. Hier kann dann beispielsweise ein minimaler
Spannbaum über alle Cluster oder ein Hamiltonkreis (siehe dazu auch Kapitel 3.3)
für alle Cluster gesucht werden.
Formal ist bei einem Generalisierten Netzwerkproblem ein (un)gerichteter Graph G =
(V, E), bestehend aus einer Menge von Knoten V = {1, ... , n} und der Kantenmenge
E ⊆ {(i, j) : i, j ∈ V }, gegeben. E(S) = {(i, j) ∈ E : i, j ∈ S} sei dann jene
Teilmenge von Kanten, die ihre Endpunkte in S ⊆ V haben. Je nachdem welche
Randbedingungen definiert werden, entsteht ein entsprechendes konkretes Problem.
</bodyText>
<subsectionHeader confidence="0.999888">
3.3 Traveling Salesman Problem
</subsectionHeader>
<bodyText confidence="0.999701277777778">
Beim sogenannten Traveling Salesman Problem (TSP) [1] handelt es sich um ein wei-
teres kombinatorisches Optimierungsproblem, das in der Klasse der NP-vollständi-
gen Probleme enthalten ist. Das Ziel hierbei ist es, alle vorhandenen Orte innerhalb
einer Rundreise, bei der also der Startort gleich dem Zielort ist, zu besuchen und
dabei eine möglichst kurze Strecke zu finden.
Um dieses Problem in ein mathematisches Modell zu bringen, bietet sich die Über-
setzung in ein graphentheoretisches Problem an, wobei die Orte den Knoten und die
Verbindungen der Orte den Kanten des Graphen entsprechen. Jede Kante besitzt ei-
ne bestimmte Länge, womit die mit ihrer Verwendung verbundenen Kosten definiert
sind. Gesucht ist nun eine Tour, welche ein Kreis im Graphen ist, der jeden Knoten
genau einmal enthält. Eine solche Tour wird auch Hamiltonkreis genannt.
Der Einfachheit halber wird für dieses Problem meist angenommen, dass der zugrun-
de liegende Graph vollständig ist, also je zwei Knoten durch eine Kante verbunden
sind. Sollte der Graph nicht vollständig sein, kann man sich dadurch helfen, die feh-
lenden Kanten einzufügen und mit so hohen Kosten zu belasten, dass sie in einer
minimalen Tour nicht vorkommen würden, es sei denn es wäre sonst keine Tour
auffindbar. Allerdings ist dann zu beachten, dass möglicherweise unlösbare Instan-
zen durch diese Anpassung lösbar werden. Die Komplexität des Suchraumes unter
</bodyText>
<page confidence="0.969744">
12
</page>
<subsectionHeader confidence="0.912997">
3.4 Bekannte Lösungsansätze
</subsectionHeader>
<bodyText confidence="0.9985563">
Berücksichtigung der Anzahl n an Knoten im Graphen ist dabei in O(nn).
Das Generalized Traveling Salesman Problem [10] behandelt die leicht abgeänderte
Variante des eigentlichen Problems, welche alle zu besuchenden Orte in Gruppen
einteilt und verlangt, dass genau ein Ort aus jeder Gruppe besucht werden muss.
Welcher das ist, kann frei gewählt werden. Es sind dafür also zwei miteinander ver-
knüpfte große Schritte notwendig, nämlich einerseits die Auswahl einer Teilmenge von
Knoten des zugrunde liegenden Graphen, wobei aus jeder Gruppe von Orten jeweils
genau einer in dieser Teilmenge enthalten ist und andererseits die Bestimmung einer
Tour mit minimalen Kosten innerhalb des Teilgraphen, der aus den ausgewählten
Knoten entstanden ist.
</bodyText>
<subsectionHeader confidence="0.987017">
3.4 Bekannte Lösungsansätze
</subsectionHeader>
<bodyText confidence="0.999879148148148">
Zur Lösung des Vehicle Routing Problem gibt es einige Ansätze, die unter anderem
Variable Nachbarschaftssuche oder Tabu-Suche einsetzen. Hierbei wird der Einsatz
solcher heuristischer Verfahren gewählt, da aufgrund der Problemstellung bereits für
kleine Probleminstanzen eine Vielzahl an möglichen Lösungen existiert, gleichzeitig
aber kein Algorithmus bekannt ist, der in polynomieller Zeit eine optimale Lösung
konstruiert.
In [13] wird etwa beschrieben, wie mittels Tabu-Suche nach einer Lösung für ein
SDVRP kombiniert mit einem VRPTW gesucht werden kann, für die die Anzahl
der verwendeten Fahrzeuge sowie die Länge der insgesamt zurückgelegten Strecke
minimiert werden.
Auch exakte Verfahren wie Ganzzahlige Lineare Optimierung (engl.: Integer Linear
Programming) (ILP) und Branch &amp; Bound beziehungsweise Branch &amp; Cut werden
häufig zur Lösung herangezogen. Ausgehend von einer ILP-Formulierung beschreibt
etwa [15] einen solchen Ansatz zur Lösung von CVRP-Instanzen mittels Branch &amp;
Cut.
In Zusammenhang mit Warenlagern, deren Anordnung in klassischer rechteckiger
Form vorliegt, ist auch das Aufsuchen von Touren ein interessantes Teilproblem im
Zuge der Optimierung von Lagerabläufen. In [5] wird ein Verfahren, die sogenannte
S-Shape-Heuristik, betrachtet, das der Erstellung solcher Touren dient. Dabei be-
wegen sich die Lagerarbeiter S-förmig durch das Lager, das heißt, dass ein Gang
komplett durchquert wird, sobald er einmal betreten wurde. Interessant ist dieser
Ansatz besonders deshalb, da er später für Vergleiche zu dem in dieser Arbeit vor-
gestellten Verfahren herangezogen wird. Betrachtungen der S-Shape-Heuristik, sowie
Varianten davon finden sich auch in [4], wo außerdem auf die Komplexität solcher La-
gerabläufe hingewiesen wird und klar hervorgeht, dass entsprechende Probleme stets
sehr speziell sind. Es gibt also kein Konzept und kein globales Optimierungsmodell
für eine systematische Behandlung ähnlicher Situationen.
</bodyText>
<page confidence="0.996448">
13
14
</page>
<sectionHeader confidence="0.998083" genericHeader="method">
4 Dynamische Programmierung
</sectionHeader>
<bodyText confidence="0.99988337037037">
Unter dem Begriff der Dynamischen Programmierung versteht man ein algorithmi-
sches Verfahren, bei dem in mehreren voneinander abhängigen Schritten Entschei-
dungen getroffen werden, die zur optimalen Lösung eines Problems führen. Dabei ist
stets die Lösung eines Problems unter Ausnützung des Wissens über bereits gelöste
Teilprobleme ein wesentlicher Bestandteil. Die in den einzelnen Berechnungsschrit-
ten zu lösenden Teilprobleme sind außerdem immer abhängig von den zuvor schon
gelösten. Sobald zu einem Teilproblem eine Lösung berechnet wurde, wird diese mit-
protokolliert, um für die spätere Verwendung abgerufen werden zu können und nicht
wiederholt berechnet werden zu müssen. So arbeitet man sich schrittweise anhand
optimaler Teillösungen zur Lösung des Gesamtproblems vor.
Der Ansatz der Dynamischen Programmierung basiert auf folgendem ursprünglich
von Bellman formulierten Postulat [3]:
”Ein optimales Verfahren hat die Eigenschaft, dass, wie auch immer
der Anfangszustand und die erste Entscheidung ausfielen, die folgenden
Entscheidungen für eine optimale Lösung sich auf den Zustand, der aus
der ersten Entscheidung resultiert, beziehen müssen.“
Wesentlich dabei ist, dass alle Entscheidungen des Algorithmus von bereits zuvor
getroffenen abhängen. Das bedeutet, dass die Lösung eines Teilproblems als Aus-
gangspunkt stets die Lösung eines vorangehenden Teilproblems heranziehen muss.
Folgt man diesem Prinzip, dann versucht man das Problem derart zu zerlegen, dass
jedes der entstehenden Teilprobleme optimal gelöst werden kann. Am Ende wird die
optimale Lösung des initial formulierten Problems erreicht und kann durch die zuvor
durchgeführten Schritte zusammengesetzt werden.
Ein ähnlicher Ansatz, der ebenso das Zerlegen eines Problems in Teilprobleme ver-
folgt, ist Divide &amp; Conquer. Dieses Verfahren unterscheidet sich allerdings wesentlich
von Dynamischer Programmierung, da hier per Definition keine Abhängigkeit zwi-
schen den einzelnen Teilproblemen bestehen muss.
</bodyText>
<subsectionHeader confidence="0.910472">
Kürzeste Wege in einem Graphen
</subsectionHeader>
<bodyText confidence="0.996048">
Ein gutes Beispiel für Dynamische Programmierung bietet der Algorithmus für kür-
zeste Wege in einem Graphen, welcher 1959 von Dijkstra [6] vorgestellt wurde. Ge-
</bodyText>
<page confidence="0.9485">
15
</page>
<sectionHeader confidence="0.830308" genericHeader="method">
4 Dynamische Programmierung
</sectionHeader>
<bodyText confidence="0.997336714285714">
geben sei ein Graph G = (V, E), bestehend aus einer Menge V = {v1, v2, ... , vn} von
Knoten und einer Menge E von Kanten. Weiters bezeichne eij eine Kante von vi nach
vj und cij deren Kosten. Der Algorithmus von Dijkstra berechnet in diesem Graph
den jeweils kürzesten Weg von einem Knoten vstart ∈ V zu allen anderen Knoten
v ∈ V .
Anfangs wird für jeden Knoten im Graph dessen initial bekannte Distanz zum An-
fangsknoten mit
</bodyText>
<equation confidence="0.999596">
w(Vstart) = 0 und
w(Vi) = ∞ Vi ∈ V, i =6 start
</equation>
<bodyText confidence="0.987271">
festgehalten. Ausgehend vom ersten Knoten Vstart des Weges und beginnend mit die-
sem wird nun jeweils immer ein Knoten Vf ”fixiert“ und alle direkten Nachfolger zur
Fixierung vorgemerkt, also ”markiert“. Dabei wird für jeden Knoten Vi die Distanz
w(Vi) aktualisiert mit
</bodyText>
<equation confidence="0.988704">
w(Vi) = min{w(Vi), w(Vf) + cif }
</equation>
<bodyText confidence="0.975993133333333">
und damit bestimmt, ob ein kürzerer Weg bis zum Knoten Vi existiert. Wenn alle
Nachfolger von Vf in dieser Form bearbeitet wurden, wird der näheste davon fixiert
und dessen Nachfolger untersucht. Ein Knoten, der bereits fixiert wurde, wird nicht
mehr aktualisiert. Durch dieses Vorgehen nähert man sich Schritt für Schritt dem
Zielknoten. Sobald dieser fixiert wird, hat man das Ende erreicht und einen optimalen
Weg gefunden. Die Rekonstruktion des Weges ist durch Rückverfolgung über die
Gleichung
w(Vi) + cij = w(Vj)
einfach möglich, womit sich natürlich auch mehrere mögliche kürzeste Wege ergeben
können.
Anhand dieses ursprünglich von Dijkstra vorgestellten Algorithmus ist es daher
möglich, durch schrittweises Lösen voneinander abhängiger Teilprobleme in einem
Graphen den kürzesten Weg zwischen zwei Knoten zu bestimmen, sofern dieser exis-
tiert.
Die Dynamische Programmierung folgt also einer einfachen Strategie:
</bodyText>
<listItem confidence="0.988509">
1. Aufteilung des Problems in kleinere, voneinander abhängige Probleme
2. Finden einer optimalen Lösung für die Teilprobleme
3. Kombinieren der optimalen Teillösungen zur Berechnung der optimalen Lösung
für das Gesamtproblem
</listItem>
<bodyText confidence="0.9852">
Es sei hier nochmals auf den wesentlichen Aspekt der Abhängigkeit von Teilproble-
men hingewiesen, welcher etwa bei Divide &amp; Conquer nicht Teil des Konzepts ist.
</bodyText>
<page confidence="0.950876">
16
</page>
<sectionHeader confidence="0.985339" genericHeader="method">
5 Variable Nachbarschaftssuche
</sectionHeader>
<bodyText confidence="0.97515968">
Variable Nachbarschaftssuche (VNS) ist eine vergleichsweise junge Metaheuristik, die
ihren Ursprung um das Jahr 1995 hat, in dem sie erstmalig vorgestellt wurde (siehe
[16] und [11]).
Grundsätzlich kann ein Optimierungsproblem allgemein formuliert werden als
min {f (x)|x E X, X C Z}. (5.1)
Z, X, x und f bezeichnen dabei den Lösungsraum, die Menge der gültigen Lösungen,
eine konkrete Lösung und eine Funktion, die jeder Lösung x E X einen reellen
Zielfunktionswert zuordnet. Meist ist eine explizite Durchsuchung von X auf Basis
von (vollständigen) Enumerationsverfahren nicht applikabel. Zudem sind viele der in
der Praxis relevanten Probleme NP-schwer, was impliziert, dass die Existenz eines
polynomiellen Algorithmus zur Lösung dieser Probleme höchst unwahrscheinlich ist.
Daher kommen häufig (Meta-)Heuristiken zum Einsatz.
VNS bietet dabei ein sehr einfach gehaltenes Verfahren mit vielen Ausbaumöglich-
keiten und folgt dem einfachen Prinzip, bereits vorhandene Lösungen einer leichten
Veränderung zu unterziehen, um somit neue, möglicherweise bessere, Lösungen zu
erhalten. Um dabei systematisch vorgehen zu können, werden so genannte Nachbar-
schaften definiert, welche im Wesentlichen auf Rechenvorschriften basieren, wie eine
vorhandene Lösung abzuändern ist, um neue, möglicherweise bessere, zu erreichen.
Sei N = {N1, ... , Nkmax}, kmax &gt; 1, als endliche Menge vorgegebener Nachbar-
schaftsstrukturen, sowie Nk(x) als Menge der Lösungen der k-ten Nachbarschaft von
x definiert. Als globales Optimum wird jene Lösung x„pt bezeichnet, für die
x„pt = min {f (x)|x E X, X C Z}
gilt. Ein lokales Minimum x&apos; E X in Bezug auf Nk ist gegeben, wenn es keine Lösung
x E Nk(x&apos;) C X mit f (x) &amp;lt; f (x&apos;) gibt.
Die Variable Nachbarschaftssuche beruht auf folgenden drei einfachen Tatsachen [12]:
</bodyText>
<listItem confidence="0.78690425">
(i) Ein lokales Minimum bezüglich einer Nachbarschaftsstruktur ist nicht notwen-
digerweise auch ein lokales Minimum bezüglich einer anderen.
(ii) Ein globales Minimum muss gleichzeitig ein lokales Minimum bezüglich aller
Nachbarschaftsstrukturen sein.
</listItem>
<page confidence="0.853127">
17
</page>
<figure confidence="0.585011875">
5 Variable Nachbarschaftssuche
f(X)
Xi xstart Xj
Abbildung 5.1: Lokale Optima und globales Optimum im Verlauf der Zielfunktion
(iii) Sehr viele Probleme bieten die Eigenschaft, dass lokale Optima nahe beieinan-
der liegen.
Der letzte Punkt basiert auf vorhandenen Erfahrungswerten und lässt in vielen Fällen
Rückschlüsse von einem lokalen auf das globale Optimum zu.
</figure>
<subsectionHeader confidence="0.993712">
5.1 Lokale Suche und Shaking
</subsectionHeader>
<bodyText confidence="0.9968200625">
Lokale Suche mittels Variable Neighborhood Descent Unter lokaler Suche ver-
steht man ein Verfahren, bei dem der Lösungsraum in einem begrenzten Bereich in
der Umgebung einer gültigen Lösung durchsucht wird. Der zu durchsuchende Bereich
wird durch die Nachbarschaft dieser Lösung vorgegeben. Das bedeutet, dass durch
festgelegte Rechenvorschriften Adaptionen der Ausgangslösung vorgenommen wer-
den und auf diesem Weg neue Lösungen erreicht werden. Um entscheiden zu können,
ob eine Lösung besser oder schlechter ist, wird eine Bewertungsfunktion verwendet.
In Abb. 5.1 ist der Verlauf einer möglichen Zielfunktion dargestellt, sowie die Posi-
tion xstart einer Startlösung markiert, von welcher ausgehend innerhalb einer Nach-
barschaft Ni beispielsweise alle Lösungen im Intervall [xi; xstart] oder innerhalb ei-
ner Nachbarschaft Nj alle Lösungen im Intervall [xstart; xj] erreichbar sind und die
markierten lokalen Optima hierbei jeweils die besten Lösungen der Nachbarschaften
darstellen.
Bei der konkreten Umsetzung der lokalen Suche durch den Variable Neighborhood
Descent (VND) wird der Lösungsraum über alle Nachbarschaftsstrukturen determi-
nistisch durchsucht. Ausgangspunkt sind eine vorhandene Startlösung sowie die vor-
</bodyText>
<figure confidence="0.916831333333333">
lokale Optima
globales Optimum
X
</figure>
<page confidence="0.877241">
18
</page>
<subsectionHeader confidence="0.662105">
5.1 Lokale Suche und Shaking
</subsectionHeader>
<bodyText confidence="0.999983317073171">
definierte Reihenfolge der verfügbaren Nachbarschaftsstrukturen. Beginnend bei der
ersten Nachbarschaft der Startlösung wird nun nach einer besseren Lösung gesucht,
um auf Basis dieser die Suche fortzusetzen. Die Reihenfolge in der die Nachbarschaf-
ten einer Lösung durchsucht werden hängt davon ab, ob Verbesserungen gefunden
werden können oder nicht. Wird Nachbarschaft Ni durchsucht und konnte eine Ver-
besserung erzielt werden, so wird die Suche mit Nachbarschaft N1 fortgesetzt. Kann
in Ni keine Verbesserung erzielt werden, so kommt Nachbarschaft Ni+1 zum Einsatz.
Der Algorithmus terminiert also erst, wenn keine weiteren Verbesserungen erzielt
werden können. Auf diesem Weg werden alle Nachbarschaften durchsucht, wobei am
Beginn der Kette üblicherweise jene Strukturen stehen, deren Definition ein schnel-
leres Durchsuchen erlaubt als bei später gereihten. In diesem Zusammenhang seien
zwei Strategien erwähnt, anhand derer entschieden werden kann, wann das Durch-
suchen einer Nachbarschaft beendet werden soll. Wird Best Improvement (für die
beste Lösung einer Nachbarschaft) gewählt, dann werden die Nachbarschaften, wie
eben beschrieben, komplett durchsucht. Unter Verwendung von Next Improvement
(für die nächst bessere Lösung einer Nachbarschaft) wird die Suche innerhalb einer
Nachbarschaft abgebrochen, sobald eine bessere Lösung gefunden werden konnte.
Der erste Eindruck mag vermitteln, dass es für die Lösungsverbesserung über alle
Nachbarschaften besser wäre diese stets komplett zu durchsuchen. Tatsächlich ist es
aber schwierig zu beurteilen welche Lösung für nachfolgende Nachbarschaften größe-
res Optimierungspotential bietet. Sicher jedoch kann behauptet werden, dass Next
Improvement kürzere Laufzeit hat als Best Improvement, sofern mindestens einmal
abgebrochen werden kann, bevor eine Nachbarschaft komplett durchsucht wurde.
In Alg. 1 ist der Ablauf von VND dargestellt. Natürlich ist zu beachten, dass sich
abhängig von der Anzahl der definierten Nachbarschaftsstrukturen auch die Laufzeit
verändert. Eine größere Anzahl an Nachbarschaftsstrukturen erhöht den notwendigen
Zeitaufwand, steigert aber gleichzeitig auch die Chance eine bessere Lösung zu finden.
Shaking Zusätzlich zur lokalen Suche kann der Einsatz von zufälligen Komponenten
positiven Einfluss auf die Effizienz eines Algorithmus haben. Dies kann durch einen
so genannten Shaking-Mechanismus erreicht werden, also einem zufälligen ”Durch-
schütteln“, wodurch zufällige Veränderungen einer Lösung eine neue Lösung erzeu-
gen. Angenommen alle vorhandenen Nachbarschaftsstrukturen alleine ermöglichen
lediglich von der in Abb. 5.1 markierten Startlösung xstart aus innerhalb des In-
tervalls [xi; xj] neue Lösungen zu finden, so würde dies bedeuten, dass die besten
auffindbaren Lösungen die beiden gekennzeichneten lokalen Optima wären. Durch
das Shaking kann man allerdings erreichen, dass dieses Intervall verschoben wird
und somit in einem neuen Bereich der Zielfunktion nach Optima gesucht werden
kann, womit die Wahrscheinlichkeit steigt, das globale Optimum zu finden.
Bei der lokalen Suche handelt es sich also um einen Prozess, der innerhalb eines
definierten Teilbereichs des gesamten Lösungsraumes nach besseren Lösungen sucht.
Die Definition von zu durchsuchenden Teilbereichen (Nachbarschaften) ist allerdings
</bodyText>
<page confidence="0.950685">
19
</page>
<figure confidence="0.525901666666667">
5 Variable Nachbarschaftssuche
Algorithmus 1 : VND
Input : eine Startlösung xstart für das Optimierungsproblem
Output : die beste gefundene (lokale) Lösung x
Data : sei N&apos; eine endliche Menge vorgegebener Nachbarschaftsstrukturen
begin
</figure>
<equation confidence="0.977812692307692">
k &amp;lt;-- 1 ;
x &amp;lt;-- xstart ;
repeat
Suche nach bestem Nachbarn x&apos; der Lösung x innerhalb der k-ten
Nachbarschaft (x&apos; E N&apos;k(x)) ;
if f (x&apos;) &amp;lt; f (x) then
x &amp;lt;-- x&apos; ;
k &amp;lt;-- 1 ;
else
k &amp;lt;-- k + 1 ;
until k = k&apos;max ;
return x ;
end
</equation>
<bodyText confidence="0.999930166666667">
abhängig von der aktuellen Lösung. Somit stellt sich natürlich stets die Frage, ob
mit den zur Verfügung gestellten Nachbarschaften der gesamte Lösungsraum erreicht
werden kann, beziehungsweise vor allem die optimale Lösung. Um nun auch mögli-
cherweise nicht abgedeckte Bereiche des Lösungsraumes erreichen zu können, wird
Shaking eingesetzt. Erzeugt werden diese Veränderungen durch zufälliges Generieren
von Lösungen aus einer der Nachbarschaften der aktuellen Lösung.
</bodyText>
<subsectionHeader confidence="0.996251">
5.2 Genereller Ansatz für die Variable
Nachbarschaftssuche
</subsectionHeader>
<bodyText confidence="0.999884125">
Aus der Kombination von lokaler Suche und Shaking lässt sich nun der generelle
Ansatz für VNS aufbauen. Dabei wird die lokale Suche eingebettet in einen wieder-
kehrenden Ablauf von Shaking und der Entscheidung darüber, ob mit einer neuen
und besseren Lösung fortgesetzt wird, oder keine Verbesserung innerhalb der lokalen
Suche möglich war. Diese Vorgehensweise wird in Alg. 2 gezeigt. Es handelt sich hier
um die Grundstruktur einer VNS, wobei die allgemein als lokale Suche bezeichnete
Phase durch VND abgedeckt wird. Darüber hinaus bildet dieser Ablauf zugleich das
Grundgerüst der in dieser Arbeit angewandten Nachbarschaftssuche.
</bodyText>
<page confidence="0.601709">
20
</page>
<figure confidence="0.404588833333333">
5.2 Genereller Ansatz für die Variable Nachbarschaftssuche
Algorithmus 2 : Genereller VNS-Ansatz
Input : eine Startlösung xstart für das Optimierungsproblem
Output : die beste gefundene Lösung x
Data : sei N&apos; eine endliche Menge vorgegebener Nachbarschaftsstrukturen
begin
</figure>
<equation confidence="0.9492248125">
k &amp;lt;-- 1 ;
x &amp;lt;-- xstart ;
repeat
// Shaking: Erzeuge eine zufällige Lösung x&apos; aus x
innerhalb der k-ten Nachbarschaft (x&apos; ∈ N &apos;k(x))
x&apos; &amp;lt;-- shake(x, k) ;
// Führe lokale Suche mittels VND durch
x&apos; &amp;lt;-- V ND(x&apos;) ;
if f (x&apos;) &amp;lt; f (x) then
x &amp;lt;-- x&apos; ;
k &amp;lt;-- 1 ;
else
k &amp;lt;-- k + 1 ;
until k = k&apos;max ;
return x ;
end
</equation>
<page confidence="0.9763175">
21
22
</page>
<sectionHeader confidence="0.98481" genericHeader="method">
6 Ein hybrides Verfahren
</sectionHeader>
<bodyText confidence="0.999982736842105">
Die vorliegende Problemstellung macht es unmöglich ein konstruktives Verfahren zu
entwickeln, dass in polynomieller Zeit zur optimalen Lösung führt, weshalb eine Alter-
native gefunden werden muss. Die Herausforderung dabei stellen die Probleminstan-
zen dar, durch welche bei einer Größenordnung, die im Echtbetrieb vorstellbar wäre,
die Anzahl der gültigen Lösungen sehr groß wird. Würde man alle möglichen Lösun-
gen untersuchen wollen oder mit exakten Verfahren wie Branch &amp; Bound arbeiten,
so würde dies zu nicht akzeptablen Rechenzeiten führen. Man kann davon ausgehen,
dass es sich dabei um mehrere Stunden handeln würde, man im Echtbetrieb je nach
Situation aber bei einer vertretbaren Zeitspanne im Bereich von Sekunden bis zu
maximal wenigen Minuten liegen muss.
Aus diesem Grund schien es sinnvoll zu sein, metaheuristische Verfahren in Kom-
bination mit exakten Methoden zur Lösung von Teilaufgaben beziehungsweise zur
Bewertung von konkreten Lösungen zu verwenden. Durch den Einsatz von VNS als
Metaheuristik ist es möglich in kurzer Zeit sehr viele unterschiedliche Lösungen zu er-
zeugen. Dabei werden zunächst gewisse Parameter ermittelt, die eine konkrete Lösung
definieren. Allerdings muss diese auch bewertet werden, um deren Güte bestimmen
zu können. Dies geschieht mittels Dynamischer Programmierung in einem weiteren
Schritt des Algorithmus, in welchem auf Basis der durch die VNS vorgegebenen Pa-
rameter einer Lösung eine passende konkrete Tour durch das Lager berechnet wird.
</bodyText>
<subsectionHeader confidence="0.999903">
6.1 Der grundsätzliche Ablauf
</subsectionHeader>
<bodyText confidence="0.999821">
Der in dieser Arbeit entwickelte Algorithmus kann im Wesentlichen in vier Teilberei-
che gegliedert werden, welche so lange wiederholt werden bis keine zu bearbeitenden
Bestellungen mehr vorhanden sind:
</bodyText>
<listItem confidence="0.99207775">
1. Partitionierung vorhandener Bestellungen - Der erste Schritt soll aus al-
len vorhandenen Bestellungen jene auswählen, die im Weiteren bearbeitet wer-
den. Dabei wird einerseits berücksichtigt welche Priorität eine Bestellung auf
Basis ihres Liefertermins hat und andererseits welche Kapazitätsbeschränkun-
gen in der Verdichtungszone vorherrschen. Es soll bereits durch diesen Schritt
sichergestellt sein, dass Artikel aus einer Bestellung stets im selben Bereich der
Verdichtungszone gelagert werden (siehe auch Kapitel 2).
2. Berechnung von Artikelauswahlen - In einem zweiten Schritt werden dann
</listItem>
<page confidence="0.866085">
23
</page>
<sectionHeader confidence="0.533938" genericHeader="method">
6 Ein hybrides Verfahren
</sectionHeader>
<bodyText confidence="0.9998228">
die einzusammelnden Artikel in so genannte Artikelauswahlen zerlegt. Das heißt
es werden Listen von Artikeln erstellt, die dazu dienen, die innerhalb einer
Tour abzuarbeitenden Artikel zu definieren. Dieser Schritt wird durch eine VNS
abgedeckt, die viele verschiedene solcher Artikelauswahlen erzeugt, um später
konkrete Touren daraus zu berechnen.
</bodyText>
<listItem confidence="0.795246">
3. Berechnung von Kommissionierungstouren - Wie bereits im vorange-
gangenen Schritt beschrieben, geht es hierbei um das Finden konkreter Tou-
</listItem>
<bodyText confidence="0.943568047619047">
ren durch das Lager. Für jede einzelne Artikelauswahl kann nun mittels eines
Dynamischen Programms sehr schnell die optimale Tour in Bezug auf deren
Länge berechnet werden. Die Summe der Längen aller Touren stellt dabei die
Güte der gesamten Lösung in dieser Konstellation dar. Sobald dieser Schritt
abgeschlossen ist, kann entschieden werden, ob das vorhandene Ergebnis an
die Lagerarbeiter übergeben werden soll, oder nochmals zum vorigen Schritt
zurückgegangen werden soll, um durch neue Artikelauswahlen ein möglicher-
weise besseres Gesamtergebnis erzielen zu können.
4. Zuweisen der Touren zu Arbeitern - Im letzten Schritt werden die vor-
handenen Touren an die verfügbaren Lagerarbeiter vergeben. Hier wird wieder
mittels einer weiteren VNS versucht eine möglichst optimale Aufteilung zu er-
reichen, damit die letzte Tour zum frühest möglichen Zeitpunkt beendet werden
kann. Sollten nach diesem Schritt noch weitere Bestellungen im System vor-
handen sein, beginnt einfach ein neuer kompletter Durchlauf des Algorithmus.
Zur Veranschaulichung dieses Ablaufs dienen sowohl die schematische Darstellung in
Abb. 6.1, als auch die Skizzierung durch Alg. 3. Dabei ist zu beachten, dass die Aus-
wertung der Zielfunktion des ersten Schritts abhängig ist von den Berechnungen des
zweiten Schritts, wodurch ein starkes Zusammenspiel dieser beiden Phasen gegeben
ist. Das endgültige Ergebnis aller Berechnungen soll allen verfügbaren Arbeitern des
Lagers Touren so zuweisen, dass der Endzeitpunkt aller Touren so früh wie möglich
ist.
</bodyText>
<subsectionHeader confidence="0.999043">
6.2 Variable Nachbarschaftssuche und Dynamische
Programmierung
</subsectionHeader>
<bodyText confidence="0.99986925">
Wie bereits erwähnt, handelt es sich bei dem Algorithmus um einen hybriden Ansatz,
bestehend aus VNS und Dynamischer Programmierung. Dabei wird der durchsuchte
Lösungsraum über die zuvor angesprochene Einteilung in Artikelauswahlen definiert
und dieser Schritt des Algorithmus auf Basis von VNS durchgeführt. Ausgehend
von einer ersten Auswahl werden also alle weiteren auf bessere Zielfunktionswerte
hin untersuchten Artikelzusammenstellungen durch stete leichte Abänderungen, defi-
niert durch das System an Nachbarschaften, generiert. Hierbei kann eine geringfügige
Veränderung einer Artikelzusammenstellung gleichzeitig große Auswirkungen auf die
</bodyText>
<page confidence="0.950828">
24
</page>
<figure confidence="0.904767266666667">
6.2 Variable Nachbarschaftssuche und Dynamische Programmierung
Abbildung 6.1: Schematische Darstellung des grundsätzlichen Ablaufs
Berechnung von
Artikelauswahlen
Bestellungen durch
Kunden
!
Berechnung von
Kommissionierungstouren
Partitionierung
vorhandener
Bestellungen
Zuweisen der Touren
zu Arbeitern
Algorithmus 3 : Grundsätzlicher Algorithmus
Input : Bestellungen mit Listen aller einzusammelnder Artikel
Output : Eine Zuordnung von Arbeitern zu fertigen Touren
begin
repeat
Erstelle Partitionierung vorhandener Bestellungen ;
repeat
Berechne Zuordnung von Artikeln zu Touren ;
Berechne optimale Touren für die oben erstellte Zuordnung ;
until keine Verbesserung konnte erzielt werden ;
(4) Erstelle eine Zuordnung von Touren zu Arbeitern ;
return die Zuordnung von Touren zu Arbeitern ;
until keine weiteren Bestellungen sind abzuarbeiten ;
end
25
6 Ein hybrides Verfahren
</figure>
<bodyText confidence="0.998537111111111">
dadurch erhaltene Lösung haben. Das bedeutet, dass eine schlechte Lösung durch
kleine Adaptionen schnell zu einer sehr guten Lösung werden kann.
Da dies alleine noch nicht ausreicht um die notwendigen Kommissionierungstouren
bereitzustellen, ist als weiterer Bestandteil die Berechnung von optimalen Touren
notwendig. Zu diesem Zweck schien es aufgrund der eingrenzbaren Möglichkeiten für
einzelne Wegstrecken innerhalb des Lagers sinnvoll, mittels Dynamischer Program-
mierung nach einer Lösung zu suchen. Dabei werden für Auswahlen von zu besu-
chenden Lagergängen optimale Teiltouren berechnet, auf deren Basis die kürzeste
Gesamttour erstellt werden kann.
</bodyText>
<page confidence="0.939068">
26
</page>
<sectionHeader confidence="0.97746" genericHeader="method">
7 Der Algorithmus im Detail
</sectionHeader>
<bodyText confidence="0.99996775">
Die in Kapitel 6 beschriebene Struktur des in dieser Arbeit entwickelten Verfahrens
verlangt nun noch nach einer konkretisierten Beschreibung. In diesem Kapitel möchte
ich nun die genaue Funktionsweise des Algorithmus vorstellen und im Detail auf die
zuvor vorgestellten einzelnen Schritte eingehen.
</bodyText>
<subsectionHeader confidence="0.99947">
7.1 Partitionierung vorhandener Bestellungen
</subsectionHeader>
<bodyText confidence="0.999975866666667">
Wie bereits erwähnt wurde, handelt es sich bei diesem Teil des Ablaufs um eine erste
Auswahl aus den vorhandenen Bestellungen. Es gibt also sozusagen einen Contai-
ner, der mit Bestellungen von Seiten der Kunden befüllt wird. Aus diesem werden
dann jeweils die nächsten zu bearbeitenden ausgesucht und an die folgenden Phasen
übergeben. Um die Anforderungen an die möglichst kurz zu haltenden Lieferzeiten
einhalten zu können, werden die verfügbaren Bestellungen nach deren Lieferdatum
geordnet. Zusätzlich wird berücksichtigt, dass Artikel einer Bestellung im selben Be-
reich der Verdichtungszone abgelegt werden müssen und die damit verbundenen Ka-
pazitätsbeschränkungen einzuhalten sind. Die Auswahl wird daher so getroffen, dass
eine Partitionierung in ihrer Gesamtheit einen einzigen Bereich der Verdichtungszo-
ne erreicht. Es ist natürlich ersichtlich, dass es sich bei dieser Vorgehensweise nur
um einen möglichen Ansatz handelt, mit diesen Randbedingungen beziehungsweise
mit im Verlauf des Arbeitstages eintreffenden Bestellungen umzugehen. Es wird hier-
bei kein Anspruch auf Optimalität des Verfahrens gestellt, alle Nebenbedingungen
werden dabei allerdings erfüllt.
</bodyText>
<subsectionHeader confidence="0.998759">
7.2 Zuordnung von Artikeln zu Touren
</subsectionHeader>
<bodyText confidence="0.999854428571429">
Obwohl dieser Schritt des Algorithmus hauptsächlich die Entscheidung trifft welche
der bestellten Artikel innerhalb einer Tour eingesammelt werden sollen, erfolgt die
Bewertung dessen auf Basis der Länge von konkreten Touren und das macht be-
reits hier die Berücksichtigung mehrerer Einschränkungen notwendig. So auch bei
Artikeln mit mehreren Lagerplätzen. Hier muss entschieden werden welche Menge
von welchem Platz abgeholt werden soll, wobei natürlich auch die Kapazität der
Kommissionierungswagen nicht überschritten werden darf.
</bodyText>
<page confidence="0.94491">
27
</page>
<sectionHeader confidence="0.442392" genericHeader="method">
7 Der Algorithmus im Detail
</sectionHeader>
<bodyText confidence="0.987265">
Eine Lösung x für die Zuordnung von Artikeln zu Touren muss also mehrere Infor-
mationen beinhalten, welche über die Menge S der Zuordnungen von Artikeln zu
Touren bestimmt sind. Das ist zunächst die Information, welche Mengen
</bodyText>
<equation confidence="0.849863">
(k1,..., kj) ⊆ Nj
</equation>
<bodyText confidence="0.984973333333333">
für jeden Artikel aj ∈ A einzusammeln sind, wobei A die Menge der Artikel bezeich-
net (|A |= j) und j maximal gleich der Anzahl an unterschiedlichen Lagerplätzen
für den Artikel aj sein kann. Weiters wird definiert von welchen Lagerplätzen
</bodyText>
<equation confidence="0.880711">
(l1,..., lj) ⊆ Lj
</equation>
<bodyText confidence="0.95685025">
diese entnommen werden sollen, wobei L die Menge der Lagerplätze beschreibt. Die
sich daraus ergebende Anzahl an Touren, um alle Artikel einzusammeln, soll mit
m = |S |bezeichnet werden.
Dies wiederum lässt folgende formale Definition zu:
</bodyText>
<equation confidence="0.885632">
S = Um {Si} (7.1)
i=1
Si = {1, ... , si}, mit i &gt; 1 (7.2)
sj = (aj, (l1, ... , lj) , (k1, ... , kj)) , mit j &gt; 1 (7.3)
Zusätzlich sei Ti definiert als ein konkreter Weg durch das Lager, auf welchem die
durch Si implizierten Lagerplätze besucht werden. Die Menge
T = Um {Ti} (7.4)
i=1
</equation>
<bodyText confidence="0.99318">
bildet dann die Menge aller Touren Ti.
</bodyText>
<subsectionHeader confidence="0.503956">
7.2.1 Konstruktionsheuristiken
</subsectionHeader>
<bodyText confidence="0.9999284">
Aufgrund der Tatsache, dass der Algorithmus ausgehend von einer Startlösung vie-
le unterschiedliche Lösungen erzeugen und untersuchen soll, ist es notwendig einen
schnellen Startpunkt zu generieren, was mittels Initialisierung per Konstruktionsheu-
ristiken geschieht. Ausgehend davon kann dann in der Folge die vorhandene Lösung
weiter verbessert werden. Da die Anzahl der gegebenen und zu erfüllenden Nebenbe-
dingungen groß ist, bot sich die Entwicklung zweier unterschiedlicher Konstruktions-
heuristiken an, von denen beide jeweils unterschiedliche Mengen von Einschränkun-
gen abdecken.
Die erste dieser Heuristiken, die so genannte Collision Avoiding Heuristic (CAH),
baut auf der Idee auf eine Menge von Touren erzeugen zu können, die nicht über-
</bodyText>
<page confidence="0.977251">
28
</page>
<table confidence="0.537820666666667">
7.2 Zuordnung von Artikeln zu Touren
Algorithmus 4 : CollisionAvoidingHeuristic
Input : eine Liste bestellter Artikel; Anzahl der Zonen m
Output : eine Menge von Mengen bestehend aus einzusammelnden Artikeln
innerhalb von m Touren
Data : Menge S von Mengen Si, mit i = 1 ... m, von einzusammelnden
Artikeln
begin
foreach Si ∈ S do
</table>
<equation confidence="0.80173875">
Si ← ∅ ;
füge alle in Zone Zi bestellten Artikel zu Si hinzu ;
return S ;
end
</equation>
<bodyText confidence="0.999809535714286">
lappen. Es sollen dabei also keine Kreuzungen auftreten, sodass Arbeiter auf ihrem
Weg durch das Lager nicht kollidieren. Um das zu erreichen, wird das Lager in m
(physisch) nicht überlappende Zonen Zi, mit i = 1, ... , m, eingeteilt. Nun wird für
jede solche Zone Zi eine Tour Ti errechnet, um alle Artikel einzusammeln, welche
in Zone Zi gelagert sind. Der Parameter m kann nach Belieben gewählt werden, es
bietet sich aber durchaus an ihn mit der Anzahl der verfügbaren Lagerarbeiter zu
initialisieren. Der Ablauf dieser Heuristik wird in Alg. 4 skizziert.
Die zweite Konstruktionsheuristik, Time Saving Heuristic (TSH) genannt, versucht
anhand der streng einzuhaltenden Liefertermine entsprechende Zuordnungen zu fin-
den. Erreicht wird dies hierbei, indem zunächst eine Reihung der Bestellungen nach
deren spätest möglichen Lieferzeitpunkten erstellt wird, um anschließend mittels
First-Fit Verfahrens Touren Ti, mit i = 1, ... , m, zu berechnen, sodass die ersten
benötigten und auszuliefernden Artikel in Tour T1 eingesammelt werden. Erst wenn
die Kapazität des ersten Kommissionierungswagens nicht mehr ausreichen sollte,
wird eine zweite Tour T2 für weitere Artikel erzeugt. Analog dazu entstehen eventu-
ell benötigte weitere Touren T3, ... , Tm. Der Pseudo-Code für diesen Ablauf wird in
Alg. 5 gezeigt.
Es ist offensichtlich, dass diese beiden Heuristiken alleine noch nicht ausreichen, um
zulässige Lösungen des Problems zu produzieren. Bei CAH kann nicht zugesichert
werden, dass etwa Lieferzeiten eingehalten werden und darüber hinaus werden die Ka-
pazitäten der Kommissionierungswagen nicht beachtet. Andererseits kann bei TSH
nicht garantiert werden, dass die Touren nicht überlappen. Daher kann nur dann
mit diesen Methoden gearbeitet werden, wenn zusätzlich Reparaturalgorithmen zum
Einsatz kommen. Trotzdem soll angenommen werden, dass die vorerst gefundenen
Lösungen als ad hoc-Antwort durchaus akzeptabel sind, etwa wenn das System im
Betrieb morgens gestartet wird. Der Hintergedanke dabei ist, dass für jeden einzelnen
Mitarbeiter zunächst nur die Information über den nächsten zu holenden Artikel von
Bedeutung ist. Alle weiteren Artikel können bestimmt werden während der Mitar-
</bodyText>
<page confidence="0.972964">
29
</page>
<figure confidence="0.967015625">
7 Der Algorithmus im Detail
Algorithmus 5 : TimeSavingHeuristic
Input : eine Liste L bestellter Artikel ai
Output : eine Menge von Mengen bestehend aus einzusammelnden Artikeln
innerhalb von m Touren
Data : Menge S von Mengen Si, mit i = 1 ... m, von einzusammelnden
Artikeln; m wird durch diesen Algorithmus bestimmt
begin
</figure>
<bodyText confidence="0.719692">
sortiere die Elemente in L nach dem spätesten Lieferdatum;
</bodyText>
<equation confidence="0.987205083333333">
S &amp;lt;-- 0 ;
i &amp;lt;-- 1 ;
Si &amp;lt;-- 0 ;
foreach a E L do
if a passt nicht in Si then
S &amp;lt;-- S u {Si} ;
i &amp;lt;-- i + 1 ;
Si &amp;lt;-- 0 ;
füge a zu Si hinzu ;
S &amp;lt;-- S u {Si} ;
return S ;
end
</equation>
<bodyText confidence="0.999936571428572">
beiter mit den ersten Artikeln beschäftigt ist. Damit hat das System Zeit, um weitere
Rechenschritte durchzuführen und verbesserte Lösungen für die übrigen Routen zu
finden. Artikel, die bereits eingesammelt wurden, müssen fix in den jeweiligen Touren
eingeplant bleiben und nur nachfolgende Artikel sind in der Reihenfolge der Abholung
noch variabel.
Auch wenn die Lösung x, gefunden von CAH oder TSH, gültig ist, heißt das noch
nicht, dass deren Güte f (x), im Speziellen also die Länge aller dadurch errechneten
Touren insgesamt, die bestmögliche ist. Generell kann man aber davon ausgehen,
dass dermaßen erzeugte Lösungen relativ schlechte Bewertungen haben werden. Der
Grund dafür sind die Bestrafungen, die durch ein Überfüllen von Kommissionierungs-
wagen entstehen. Sobald die Kapazitätsgrenze eines solchen erreicht wird, bestraft
der Algorithmus dies so stark, dass es auf alle Fälle eine günstigere Lösung ist einen
zusätzlichen Wagen zu verwenden. Es wird also unerlässlich sein mit Verbesserungs-
heuristiken weiterzuarbeiten.
</bodyText>
<subsubsectionHeader confidence="0.470181">
7.2.2 Reparatur- und Verbesserungsheuristik
</subsubsectionHeader>
<bodyText confidence="0.782912666666667">
Zentraler Bestandteil des Programms ist die Umsetzung einer Variablen Nachbar-
schaftssuche (VNS) [12] mit Verwendung des Variable Neighborhood Descent (VND)
als lokale Verbesserungskomponente, welche sowohl als Reparatur- als auch als Ver-
</bodyText>
<page confidence="0.924791">
30
</page>
<subsectionHeader confidence="0.883923">
7.2 Zuordnung von Artikeln zu Touren
</subsectionHeader>
<bodyText confidence="0.999731923076923">
besserungsheuristik eingesetzt werden kann. Zur Reparatur ist das Verfahren ein-
setzbar, weil durch hohe Bestrafung von ungültigen Lösungen stets eine bessere, also
kostengünstigere und gleichzeitig vor allem gültige Lösung gefunden werden kann.
Wesentlich hierbei ist die Veränderung der Artikelauswahlen, die in weiterer Folge
erst die Tourberechnung beeinflusst. Die nachfolgende Auflistung bezieht sich also
stets auf eine Adaptierung von Artikelauswahlen.
Folgend den bereits in Kapitel 5 dargelegten Erläuterungen, kommen die anschließend
vorgestellten Nachbarschaftsstrukturen zum Einsatz. Da diese Strukturen auf Basis
von grundlegenden Moves definiert werden, folgt zuvor eine Auflistung eben dieser:
SwapMove(i, j, k, l) Dieser Schritt tauscht die Artikel k E Si und l E Sj, mit Si, Sj E
S, 1 &amp;lt; i &amp;lt; j &amp;lt; m und k =6 l. Das bedeutet, dass nach Anwendung dieses
Schrittes Artikel k von Tour Si entfernt und Artikel l eingefügt wurde. Analog
wurde Artikel l von Tour Sj entfernt und Artikel k eingefügt.
ShiftMove(i, j, k) Wird dieser Schritt durchgeführt, so bedeutet dies, dass Artikel
k E Si aus Si entfernt und in Sj eingefügt wird, wobei 1 &amp;lt; i, j &amp;lt; m und i =6 j.
MergeMove(i, j) Bei diesem Schritt werden zwei Touren Si und Sj zu einer neuen
Tour Si, zusammengeführt. Es werden also all jene Artikel, die zuvor von Si
und Sj eingesammelt wurden, von einer neuen Tour bearbeitet, wodurch Si und
Sj aus der Menge S entfernt werden können und stattdessen Si, in S eingefügt
wird. Es vermindert sich dadurch also die Anzahl der Touren um eins.
SplitMove(i, R) Die Anwendung dieses Schrittes bringt die Tour Si zu einer Auftei-
lung in zwei neue Touren Si und Si,, indem alle in R enthaltenen Artikel von Si
nach Si, verschoben werden. Si, muss dann natürlich zu S hinzugefügt werden
und somit erhöht sich die Gesamtzahl an Touren um eins.
Formal betrachtet hat man hier 2s Möglichkeiten die ursprüngliche Tour zu
zerlegen, wenn die Anzahl an Elementen in Si mit s bezeichnet wird, also |Si |=
s. Die Zerlegungen berechnen sich dann aus der Potenzmenge von Si, nämlich
P(Si), beziehungsweise ergibt das |P(Si) |= 2s verschiedene Möglichkeiten.
SwapPositionMove(i, k, l) Dieser Move nützt die Tatsache aus, dass Artikel an
mehr als nur einer Position im Lager verfügbar sein können. Sollte an einer
weiteren Position im Lager ein bestimmter Artikel in der benötigten Menge
vorhanden sein, so kann die Position vertauscht werden. Es wird dann der Ort
des Artikels k E Si auf den neuen Ort l geändert. Um den Ablauf hierbei ein-
fach zu halten, wird der Artikel aus der Tour Si entfernt und eine neue Tour
S&apos;i gebildet, die zunächst nur diesen einen Artikel k mit der neuen Lagerplatz-
information enthält. Durch die spätere Anwendung eines MergeMove könnte
diese Tour mit einer anderen wieder zusammengelegt werden.
SplitPositionMove(i, k, l, q) Dieser Schritt ermöglicht es in etwas anderer Form als
bei den beiden bisherigen Varianten einen Artikel von anderer Stelle einzusam-
</bodyText>
<page confidence="0.996136">
31
</page>
<sectionHeader confidence="0.459513" genericHeader="method">
7 Der Algorithmus im Detail
</sectionHeader>
<bodyText confidence="0.99971085">
meln. Es ist generell natürlich nicht nur möglich die komplette Menge eines
angeforderten Artikels von einem anderen Lagerplatz zu holen, sondern bei
Bedarf auch nur eine Teilmenge davon. Diese Tatsache erlaubt die Definiti-
on eines Moves, durch den aus der Tour Si eine bestimmte Teilmenge q für
den Artikel k von einer zusätzlichen Position l im Lager innerhalb einer neuen
Tour S&apos;i eingesammelt wird und gleichzeitig eine bleibende Restmenge von der
ursprünglichen Position zu holen bleibt.
Aus diesen grundlegenden Moves werden nun folgende Nachbarschaftsstrukturen de-
finiert, wobei S die Menge an Selektionen (Touren) bezeichnet, smax die maximale
(größte vorkommende) Anzahl an Artikeln einer Tour angibt und lmax für die maxi-
male (größte vorkommende) Anzahl an alternativen Lagerplätzen eines Artikels aus
dem Lager steht:
Swap Grundlage für diese Nachbarschaftsstruktur ist der zuvor eingeführte Swap-
Move. Ausgehend von einer konkreten Lösung sind dadurch alle Lösungen defi-
niert, welche mittels eines SwapMoves erreichbar sind. Sollen also Artikel zwi-
schen je zwei Touren vertauscht werden, so liegt die Anzahl an Möglichkeiten
dafür in O(|S|2 · s2max).
Shift Diese Nachbarschaftsstruktur basiert auf dem ShiftMove und somit kann die
Anzahl an möglichen Alternativen zu einer konkreten Lösung mit O(|S|2 · smax)
abgeschätzt werden.
Merge Auch diese Struktur leitet sich aus nur einem Move ab, nämlich dem Merge-
Move. Hier kommt man für eine Lösung auf O(|S|2) mögliche neue Lösungen.
In dieser Nachbarschaftsstruktur sind alle Lösungen enthalten, die aus einer ge-
gebenen Lösung durch Anwendung eines MergeMoves erzeugt werden können.
Split In der Anwendung hat es sich bewährt bei dieser auf dem SplitMove basieren-
den Nachbarschaftsstruktur beim Durchsuchen auf eine komplette Abdeckung
zu verzichten. Die insgesamt möglichen Adaptierungen können mit O(|S|·2smax)
abgeschätzt werden. Tatsächlich werden nur jene Fälle berücksichtigt, bei denen
die Anzahl an Artikeln in einer Tour auf die Hälfte reduziert werden. Bei einer
geraden Anzahl an Artikeln kann genau in die Hälfte geteilt werden, bei unge-
rader Anzahl entsteht dementsprechend eine Tour mit einem Artikel mehr als
bei der anderen. Somit bleibt ein stark verminderter Umfang von O(|S |· smax)
übrig.
SwapPosition Diese Nachbarschaftsstruktur stützt sich auf den vorgestellten Swap-
PositionMove und umfasst daher eine geschätzte Anzahl von O(|S |· smax · lmax)
möglicher Nachbarlösungen zu einer konkreten Lösung.
SwapPositionMerge Hier handelt es sich um eine Struktur, die ähnlich wie Swap-
Position aufgebaut ist. Allerdings wird versucht eine jeweils durch einen Swap-
PositionMove neu entstehende Tour mit den übrigen verfügbaren Touren zu
kombinieren. Es kommt hierbei zur Kombination mit einem MergeMove. Da-
</bodyText>
<page confidence="0.961591">
32
</page>
<subsectionHeader confidence="0.874656">
7.2 Zuordnung von Artikeln zu Touren
</subsectionHeader>
<bodyText confidence="0.9980744">
her entsteht eine Größe des in Frage kommenden Lösungsraumes von O(|S|2·
smax · lmax).
SplitPositionMerge Grundlage für diese Nachbarschaftsstruktur bilden der Split-
PositionMove sowie der MergeMove, welche nacheinander angewendet werden.
Konkret wird versucht etwa die Hälfte der angeforderten Menge eines Artikels
von einem alternativen Lagerplatz zu holen. Dabei entstehen für eine Lösung
durch O(|S|2 · smax · lmax) beschränkte weitere gültige Lösungen.
Die nun aufgelisteten Nachbarschaftsstrukturen sind im Wesentlichen aus mehreren
Moves (deren Anzahl wird im Folgenden mit m bezeichnet) zusammengesetzt und
benötigen daher weit mehr Rechenzeit, um durchsucht zu werden. Um dem entge-
genzuwirken, wurde der durchsuchte Bereich teilweise eingeschränkt beziehungsweise
mit einer vorgegebenen Anzahl an zufällig erzeugten Lösungen innerhalb der Struktu-
ren gearbeitet. Daher gibt es in solchen Fällen deutliche Unterschiede zwischen dem
theoretischen und dem praktisch durchsuchten Nachbarschaftsbereich einer Lösung.
Der Vorteil bei der Kombination von mehreren Moves ist, dass schlechtere Lösungen
vorerst beibehalten werden können und erst nachdem alle definierten Moves durch-
geführt wurden eine Bewertung erfolgt. Weiters ist auch zu beachten, dass die ein-
zelnen dabei verwendeten Moves in keiner Abhängigkeit zueinander stehen müssen,
nur Überschneidungen müssen beachtet werden. Es kann ein Artikel beispielsweise
nicht zweimal hintereinander aus einer Tour genommen werden. Die Strukturen sind
also wie folgt definiert:
DoubleShift Hier wird einfach die Anwendung von ShiftMoves aneinander gereiht
und somit zweimal verschoben, um eine neue Lösung zu erzeugen. Die Menge
an möglichen Lösungen hat dabei eine Mächtigkeit in der Größenordnung von
O(|S|4 · s2max). Durch die zufällige Generierung von entsprechenden Moves und
einer fix vorgegebenen Anzahl an Versuchen ergibt sich eine Laufzeitkomple-
xität von O(1).
Dieser markante Unterschied entsteht hier, da entschieden wurde jeweils 1000
zufällig generierte Lösungen zu testen, um die Komplexität der Nachbarschafts-
struktur zu umgehen. Das komplette Durchsuchen dieser, wie auch einiger der
folgenden Nachbarschaftsstrukturen würde zu lange dauern. Es schien durchaus
vertretbar an dieser Stelle mit einer Zufallskomponente zu arbeiten.
MultipleShift Ähnlich wie beim zuvor beschriebenen DoubleShiftMove, ist auch hier
eine Aneinanderreihung von Elementen aus ShiftMoves Gegenstand der Defini-
tion, allerdings ist die Anzahl an Verschiebungen hier frei definierbar. Dement-
sprechend definiert sich die Größenordnung der möglichen Lösungen hier als
O((|S|2 · smax)m), die Laufzeit liegt aber auch hier wieder in O(1) (siehe auch
bei DoubleShift).
MultipleSwap Hierbei handelt es sich um die Kombination mehrerer SwapMoves,
welche in ihrer Gesamtheit dann zu mehrfachen Vertauschungen von Artikeln
</bodyText>
<page confidence="0.971531">
33
</page>
<sectionHeader confidence="0.453933" genericHeader="method">
7 Der Algorithmus im Detail
</sectionHeader>
<bodyText confidence="0.999631125">
innerhalb einer gesamten Veränderung führen. Ein Lösungsraum der Größe
O((|S|2 · s2max)m) steht hier einem durchsuchten Raum der Größe O(1) ge-
genüber (siehe auch bei DoubleShift).
MultipleSplit Wie der Name bereits andeutet, werden hier einige SplitMoves mit-
einander verknüpft, was die Aufspaltung mehrerer Touren auf einmal zur Folge
hat. Hier bewegen wir uns bei der Anzahl der möglichen Alternativen im Be-
reich von O((|S |· 2smax)m). Durch die auch hier wieder gewählte Beschränkung
auf zufällig erzeugte Kombinationen ergibt sich eine Laufzeit von O(1) (siehe
auch bei DoubleShift).
ShiftSplit Dieser Schritt soll die Vorzüge eines SplitMoves mit denen eines Shift-
Moves kombinieren. Dem Verschieben eines Artikels folgt hier unmittelbar die
Zerlegung einer Zuordnung. Damit ergeben sich O(|S|3 · s2max) Möglichkeiten,
die wiederum in O(1) durchsucht werden (siehe auch bei DoubleShift).
SwapSplit Wie auch hier bereits aus dem Namen hervorgeht, wird zuerst ein Swap-
Move durchgeführt und anschließend eine Zuordnung durch einen SplitMove
zerlegt. Hierbei ergibt sich ein Ausmaß an Lösungen von O(|S|3· s3max), das
Durchsuchen selbst ist wieder auf O(1) reduziert (siehe auch bei DoubleShift).
SplitMerge Diese Nachbarschaftsstruktur wurde in der Form umgesetzt, dass sie
in Anlehnung an den SplitMove entsprechend durchsucht wird und nach ei-
ner Aufsplittung versucht wird beide neu erzeugten Touren mit allen anderen
verfügbaren zu kombinieren. Dies geschieht in mehreren Schritten. Zunächst
wird versucht den ersten Teil der Tour mit allen weiteren verfügbaren Touren
zu kombinieren. Anschließend wird dies auch mit dem zweiten Teil probiert.
Ein weiterer Schritt versucht den ersten und zweiten Teil gleichzeitig mit je-
weils unterschiedlichen Touren zu kombinieren. Es entstehen hier also gleich
drei unterschiedliche Ansätze pro Aufsplittung. Die Vorgehensweise unterliegt
dabei weitaus weniger dem Zufall, viel eher wird versucht eine komplette Abde-
ckung zu erreichen. Lediglich das Aufsplitten von Touren erfolgt nach wie vor
eingeschränkt, da sonst für ein geringes Maß an Verbesserung ein unverhält-
nismäßig hoher Aufwand betrieben werden müsste. Außerdem sind bei dieser
Nachbarschaftsstruktur die einzelnen Moves abhängig voneinander. Es ergibt
sich hier eine Komplexität von O(|S|2 · smax).
Manche Situationen machen es nötig, eine schnelle Verbesserung einer gegebenen
Lösung x zu errechnen, zum Beispiel wenn ein einzusammelnder Artikel nicht an
der zugeteilten Stelle aufzufinden ist, weshalb die standardmäßige Abfolge bei VND
durch eine Laufzeitbeschränkung limitiert wurde. Es kann dann nach Bedarf eine
zeitliche Grenze geben, nach deren Erreichen keine neue Nachbarschaft durchsucht
wird. Der Pseudo-Code in Alg. 6 soll diese Umsetzung andeuten.
Wie bereits zuvor erwähnt, kann dieser hier vorgestellte VND Ansatz als Reparatur-
und auch als Verbesserungsverfahren verwendet werden. Dies erfordert die Bewer-
</bodyText>
<page confidence="0.959816">
34
</page>
<figure confidence="0.24032">
7.2 Zuordnung von Artikeln zu Touren
Algorithmus 6 : VND mit zeitlicher Einschränkung
Input : eine Startlösung x
Data : Zähler l, Anzahl lma„ der zu untersuchenden Nachbarschaften
begin
</figure>
<equation confidence="0.969716">
l &amp;lt;-- 1 ;
repeat
x&apos; &amp;lt;-- durchsuche Nachbarschaft Nl(x) ;
if f (x&apos;) &amp;lt; f (x) then
x &amp;lt;-- x&apos; ;
l &amp;lt;-- 1 ;
else
l &amp;lt;-- l + 1 ;
until l &gt; lma„ oder eine vordefinierte Zeit wurde erreicht ;
end
</equation>
<bodyText confidence="0.999336714285714">
tung einer Lösung x und einer daraus abgeleiteten möglichen Verbesserung x&apos;. Da
die Güte einer Lösung im Wesentlichen von der Summe der Längen aller Touren
abhängt, ist es also hier von Bedeutung sämtliche benötigte Touren einer Lösung so
zu berechnen, dass diese auf kürzestem Weg durch das Lager führen. Kapitel 7.3 wird
zeigen wie es möglich ist entsprechende Touren unter Berücksichtigung der speziellen
Eigenschaften des Lagers in polynomieller Zeit zu berechnen.
Die Nachbarschaftsstrukturen zur Durchführung von Shaking-Phasen (also zufälligen
Veränderungen einer Lösung) basieren auf den zuvor vorgestellten, jedoch werden
hierbei anstelle eines Schrittes mehrere zufällig ausgewählte Schritte auf die entspre-
chende Lösung angewendet. In der letzten Version des Algorithmus kam dafür Swap
zum Einsatz. Die zufälligen Veränderungen aus der Nachbarschaft N &apos;k(x) in Alg. 2
kommen daher jeweils nur aus Swap. Gleichermaßen wäre aber auch die Verwendung
von Shift, Split oder Merge sowie jede Kombination dieser möglich gewesen, jedoch
konnten keine klaren Vorteile für eine der Varianten im Vorfeld ausgemacht werden.
</bodyText>
<subsectionHeader confidence="0.717372">
7.2.3 Durchsuchen der Nachbarschaften
</subsectionHeader>
<bodyText confidence="0.999930666666667">
Beim Durchsuchen der einzelnen Nachbarschaften unterscheidet man zwei Methoden
zur Übernahme einer neuen und besseren Lösung, nämlich Next Improvement und
Best Improvement (siehe auch Kapitel 5). Wird Next Improvement verwendet, so ist
das gleichbedeutend mit einem Abbruch der Suche, sobald eine bessere Lösung gefun-
den wurde. Konkret auf ShiftMove bezogen wird also die Nachbarschaft systematisch
durchsucht und beginnend mit dem ersten bis zum letzten Artikel versucht diesen
einer anderen Tour zuzuordnen. Bei diesem Vorgehen sind aber jene Artikel klar
bevorzugt, welche in der Liste am Anfang stehen. Daher wurde eine zufällige Durch-
suchungsreihenfolge implementiert, sodass jede Lösung im Nachbarschaftsraum mit
</bodyText>
<page confidence="0.985095">
35
</page>
<sectionHeader confidence="0.231053" genericHeader="method">
7 Der Algorithmus im Detail
</sectionHeader>
<bodyText confidence="0.533728">
gleicher Wahrscheinlichkeit zu einer Verbesserung beitragen kann.
</bodyText>
<subsectionHeader confidence="0.5168">
7.2.4 Dynamische Reihenfolge der Nachbarschaften
</subsectionHeader>
<bodyText confidence="0.998851833333333">
Eine große Herausforderung bei der Umsetzung mittels VNS stellt die Reihung der
definierten Nachbarschaftsstrukturen dar. Nachdem die Anwendung einer Nachbar-
schaftsstruktur durchaus auch Auswirkungen auf die Effizienz nachfolgender Nach-
barschaftsstrukturen hat, ist diese Entscheidungsfindung nicht trivial. Aus diesem
Grund wurde entschieden, eine Adaptierung der in [14] vorgestellten Methode zur
dynamischen Reihung vorzunehmen. Im Folgenden gilt es stets eine Permutation
</bodyText>
<equation confidence="0.902079">
λ = (λ1, ... , λk) der Nachbarschaftsstrukturen {N1, ... , Nk}
</equation>
<bodyText confidence="0.999899125">
zu berechnen, wobei der Nachbarschaftsstruktur Ni, i = 1, ... , k, ein Prädikat wi &gt; 0
zugeordnet wird, welches zu Beginn mit einem konstanten Wert W belegt wird.
Während nun die Nachbarschaft Nλi(x) einer Lösung x durchsucht wird, wird wλi in
Abhängigkeit von Rechenzeit tλi und Sucherfolg aktualisiert. Wurde eine verbesserte
Lösung gefunden, so wird wλi halbiert und tλiα hinzugefügt, wobei α ein Parameter
ist, der den Einfluss der Auswertung auf die eigentliche Rechenzeit repräsentiert.
Sollte keine bessere Lösung gefunden werden, so wird die Nachbarschaftsstruktur
durch Hinzufügen der unverminderten Rechenzeit tλi zum bestehenden Wert wλi mit
höheren Kosten belastet. Die Permutation λ wird erst neu erzeugt, wenn ein gerade
aktualisierter Wert w&apos;λi kleiner als das bisher kleinste, minj=1,...,k wj, oder größer
als das bisher größte, maxj=1,...,k wj, solcher Prädikate ist. Dann wird anhand der
aufsteigenden Werte wi eine neue Reihenfolge bestimmt.
Das Konzept ist in Alg. 7 ersichtlich, wobei eine kleine Anpassung zum in [14] vor-
gestellten Algorithmus durchgeführt wurde, um zu vermeiden, dass Nachbarschaften
ausgelassen werden können. Das kann vorkommen, da dort vor jeder Umreihung ge-
speichert wird mit welcher Nachbarschaft fortgesetzt werden soll und diese dann wei-
ter hinten gereiht werden könnte als andere noch nicht besuchte. Außerdem soll ver-
hindert werden, dass die Nachbarschaften ständig umgereiht werden. Dies geschieht
im ursprünglich vorgestellten Verfahren viel häufiger, da auch dann eine Umreihung
passieren kann, wenn keine Verbesserung der Lösung erzielt wurde. Der tatsächlich
verwendete Algorithmus verändert die Reihenfolge der Nachbarschaften erst dann,
wenn gerade eine verbesserte Lösung gefunden werden konnte.
Getestet wurde der gesamte Algorithmus sowohl mit dynamischer als auch mit stati-
scher Nachbarschaftsreihenfolge. Die Ergebnisse dazu werden in Kapitel 8 präsentiert.
</bodyText>
<page confidence="0.958351">
36
</page>
<note confidence="0.400846">
7.2 Zuordnung von Artikeln zu Touren
</note>
<equation confidence="0.923138714285714">
Algorithmus 7 : VND mit dynamischer Nachbarschaftsreihenfolge
Input : eine Startlösung x
Data : Zähler i, Anzahl k der zu untersuchenden Nachbarschaften
begin
w1 &amp;lt;-- w2 &amp;lt;-- ... &amp;lt;-- wk &amp;lt;-- W ;
wmin &amp;lt;-- wmax &amp;lt;-- W ;
λ = (1, 2,..., k) ;
i &amp;lt;-- 1 ;
repeat
x&apos; &amp;lt;-- durchsuche Nachbarschaft Ni(x) mit Zeitaufwand tλi ;
if f (x&apos;) &amp;lt; f (x) then
x &amp;lt;-- x&apos; ;
wλi &amp;lt;-- wλi 2 + tλi α ;
if (wλi &amp;lt; wmin) V (wλi &gt; wmax) then
Sortiere λ1, ... , λk, sodass wλ1 &amp;lt; wλ2 &amp;lt; ... &amp;lt; wλk ;
wmin &amp;lt;-- wλ1 ;
wmax &amp;lt;-- wλk ;
i &amp;lt;-- 1 ;
else
wλi ← wλi + tλi ;
i &amp;lt;-- i + 1 ;
until i &gt; k ;
end
37
7 Der Algorithmus im Detail
Algorithmus 8 : Berechnung einzelner Touren
Input : Menge an Zuordnungen S
Data : m = |S|
Output : Menge von Touren T
begin
foreach Si E S do
Ti &amp;lt;-- kürzeste Tour für Si ;
T &amp;lt;-- T u {Ti} ;
return T ;
end
</equation>
<subsectionHeader confidence="0.997932">
7.3 Berechnung einzelner Touren
</subsectionHeader>
<bodyText confidence="0.999966666666667">
Die nachfolgende Phase des Algorithmus, wie in Alg. 3 vorgestellt, betrifft das Auffin-
den von Touren ausgehend von den zuvor festgelegten Artikelzuordnungen. Weiters
ist die Berechnung von kürzesten Wegen ein Teilproblem des VNS, wie in Kapi-
tel 7.2.2 beschrieben.
Zur effizienten Berechnung dieser Touren ist es zunächst notwendig das Lager in eine
passende Struktur zu dessen Repräsentation zu bringen, was durch einen ungerichte-
ten, zusammenhängenden Graphen G = (V, E) passiert. Ausgehend davon kann nun
ein Verfahren basierend auf Dynamischer Programmierung nach optimalen Touren
suchen. Die dabei entscheidende Idee ist die Definition so genannter Module, wel-
che entsprechend ihrer Verbindungsmöglichkeiten aneinander angeschlossen werden
können. Der nun im Detail erläuterte Algorithmus berechnet für jede Zuordnung Si
eine konkrete Tour Ti. Diese Vorgehensweise ist im Pseudo-Code in Alg. 8 ersichtlich.
</bodyText>
<subsectionHeader confidence="0.852821">
7.3.1 Repräsentation als Graph
</subsectionHeader>
<bodyText confidence="0.998512333333333">
Die Repräsentation des Lagers geschieht also mittels eines ungerichteten, zusam-
menhängenden Graphen G = (V, E), wobei die Kantenmenge E die Gänge innerhalb
des Lagers bildet. Unterschieden werden dabei Regalgänge und Hauptgänge. Während
erstere jene Gänge sind, die sich zwischen den Lagerregalen befinden und parallel zu
diesen sind, verbinden zweitere Regalgänge und wieder andere Hauptgänge miteinan-
der (siehe auch Abb. 1.1 in Kapitel 1). Jeder Knoten v E V entspricht einem Punkt
mit speziellen Eigenschaften. Das können die Verdichtungszone (VZ), Kreuzungen
von Gängen und Positionen innerhalb von Regalen sein. Es kommt sehr häufig vor,
dass mehrere Positionen im Lager (Lagerplätze) übereinander liegen, solche Vorkom-
men werden dann aber zusammengefasst in einem Knoten, der darüber hinaus den
gesamten Regalgang enthält.
Man kann nun sehen, dass jeder Knoten v E V höchstens vier Nachbarn hat, das
</bodyText>
<page confidence="0.988382">
38
</page>
<figure confidence="0.968186">
7.3 Berechnung einzelner Touren
(a)
(b)
</figure>
<figureCaption confidence="0.724076">
Abbildung 7.1: Lagerrepräsentation (a) als Graph (b)
</figureCaption>
<bodyText confidence="0.9998063">
heißt, der Grad jedes Knotens ist von oben mit vier beschränkt. Weiters besitzen
Knoten, die einen Lagerplatz bezeichnen, höchstens zwei Nachbarn. Das heißt, all
jene Knoten innerhalb eines Regalganges können als lineare Liste betrachtet werden.
Da dem Graph ein typisches Lager zugrunde liegt, ist er planar, also ohne Kreuzungen
von Kanten zeichenbar.
Unter Ausnützung dieser Eigenschaften kann man den Graphen G einschränken und
die Anzahl an Knoten stark reduzieren, indem für jeden Gang höchstens drei Knoten
existieren (siehe Abb. 7.1). Dort repräsentiert der Knoten in der Mitte die (lineare
Liste der) Lagerplätze und die beiden Knoten am Beginn und am Ende des Ganges
bezeichnen die Kreuzungspunkte mit dem jeweiligen Hauptgang.
</bodyText>
<subsectionHeader confidence="0.859324">
7.3.2 Ein Dynamisches Programm
</subsectionHeader>
<bodyText confidence="0.999825125">
Ohne Einschränkung der Allgemeinheit und mit Bezug auf Abb. 7.1 soll angenommen
werden, dass Regalgänge und Hauptgänge orthogonal zueinander liegen. Hauptgänge
verlaufen hierbei von oben nach unten, Regalgänge stets von links nach rechts. Eine
Menge von zwei Hauptgänge gemeinsam mit den dazwischen liegenden Regalgängen
wird weiters auch als Block bezeichnet.
Im Folgenden wird ein Algorithmus aufbauend auf Dynamischer Programmierung
gezeigt, welcher in polynomieller Zeit die Berechnung kürzester Touren über alle
Knoten von Interesse, also all jene Lagerplätze mit einzusammelnden Artikeln, in-
</bodyText>
<page confidence="0.991651">
39
</page>
<figure confidence="0.993864">
7 Der Algorithmus im Detail
(a) (b) (c) (d) (e)
</figure>
<figureCaption confidence="0.5860035">
Abbildung 7.2: Grundlegende Gangoperationen.
Abbildung 7.3: Grundlegende Zwischen-Gangoperationen.
</figureCaption>
<bodyText confidence="0.994670434782609">
nerhalb eines Blocks durchführt.
Zu diesem Zweck werden so genannte Gangoperationen, sowie Zwischen-Gangopera-
tionen eingeführt. Gangoperationen werden herangezogen, um die Möglichkeiten für
Wege innerhalb eines Regalganges abzudecken, wohingegen Zwischen-Gangoperati-
onen Bewegungen innerhalb der Hauptgänge beschreiben.
Gangoperationen In Abb. 7.2 ist die Menge an grundlegenden Gangoperationen,
welche von Arbeitern durchgeführt werden können, grafisch dargestellt. Es ist offen-
sichtlich, dass Gänge entsprechend von links oder rechts betreten werden können (sie-
he Abb. 7.2a–7.2d), aber auch komplett ausgelassen werden können (siehe Abb. 7.2e).
Ein Gang kann natürlich nur dann ausgelassen werden, wenn keine Artikel daraus
benötigt werden. In diesem Fall ist eine solche Operation also auch gültig. Im im-
plementierten Algorithmus kommt diese Operation nicht direkt zum Einsatz, da hier
Gänge weggelassen werden, wenn sie nicht betreten werden müssen. Es werden dann
einfach die Gänge davor und danach direkt miteinander verbunden.
Zwischen-Gangoperationen Zusätzlich zu den eingeführten grundlegenden Gang-
operationen werden Zwischen-Gangoperationen benötigt. Diese wiederum beschrei-
ben welche Möglichkeiten für die Arbeiter bestehen, um sich zwischen zwei aufein-
ander folgenden Gängen zu bewegen (siehe Abb. 7.3). Diese Aktionen lassen einen
Wechsel über die Hauptgänge zu (siehe Abb. 7.3a–7.3d). Natürlich kann es auch vor-
kommen, dass kein weiterer Gang besucht werden muss, dann ist kein Gangwechsel
mehr nötig, wie in Abb. 7.3e zu sehen ist. Die Umsetzung im Programm erfolgt auch
hier durch Weglassen nicht benötigter Gänge, die theoretisch gültigen Gangoperati-
onen sind dann nicht nötig.
</bodyText>
<figure confidence="0.754046">
(a) (b) (c) (d) (e)
</figure>
<page confidence="0.885046">
40
</page>
<subsectionHeader confidence="0.887167">
7.3 Berechnung einzelner Touren
</subsectionHeader>
<bodyText confidence="0.995887371428571">
Abbildung 7.4: Gültige und ungültige Module.
Gangmodule Letztlich ist es hiermit möglich eine Menge an so genannten Gang-
modulen zu definieren, welche wiederum auf den vorgestellten grundlegenden Ope-
rationen aufbauen. Daraus kann man nun jede erdenkliche Kombination erstellen,
jedoch ist nicht jede davon auch gleichzeitig gültig. Abb. 7.4a und 7.4b zeigen zwei
gültige Module. Das in Abb. 7.4c gezeigte Modul ist jedoch von vornherein ungültig,
da der rechte Knoten, der die Kreuzung von Regalgang und Hauptgang repräsentiert
zweimal verlassen aber nur einmal betreten wird. Das Modul in Abb. 7.4d ist im
Prinzip gültig, aber vom Programm zu verwerfen, weil die Lagerplätze, von denen
Artikel eingesammelt werden sollen (in der Abb. dunkelgrau markiert), gar nicht
besucht werden.
Es sei nun definiert, dass zwei Module j und j&apos; für die Gänge i und i&apos; unterein-
ander kompatibel sind, wenn die Module j und j&apos; basierend auf ihren Zwischen-
Gangoperationen verbunden werden können. Weiters ist Modul j&apos; mit Modul j ”von
oben“ kompatibel, wenn die Zwischen-Gangoperationen von j um ”nach unten“ be-
ziehungsweise ”nach oben“ zu gehen mit den entsprechenden Zwischen-Gangoperatio-
nen von j&apos; zusammenpassen. Im Folgenden bezeichnet Mkomp(j) die Menge aller
Module j&apos;, die ”von oben“ kompatibel mit j sind.
Einige Beobachtungen Generelles Ziel ist immer noch das Einsammeln aller ange-
forderten Artikel. Nachdem bereits Selektionen an Artikeln getroffen wurden, welche
jeweils innerhalb einer Tour einzusammeln sind, wird mit dem Berechnen jeder dieser
Touren ein Teilziel erreicht. Zusätzlich dazu suchen wir aber nach Touren durch das
Lager, die insgesamt ein Minimum an Zeit benötigen sollen, weshalb eine entspre-
chende Bewertung jeder Tour erfolgen muss. Diese Bewertung kann auf den zuvor
eingeführten Modulen zur Tourkonstruktion passieren, indem die Kosten ci(j) &gt; 0
für jedes Modul j basierend auf den Aktionen, die ein Arbeiter in Gang i durchführt,
berechnet werden. Transformiert auf den erwähnten Dekodierungsgraph G&apos; bedeutet
das eine einfache Umlegung auf die Kosten für jede einzelne Kante e ∈ E&apos; gemäß den
jeweiligen Längen derselben.
In Bezug auf die Anzahl von Modulen, die zur Zusammenstellung einer Tour relevant
sein können, muss zum einen nocheinmal erwähnt werden, dass nicht alle Kombina-
tionen an Gangoperationen und Zwischen-Gangoperationen gültige Module bilden.
Zum anderen ist es aber darüber hinaus wesentlich zu beachten, dass auch gültige
Module teilweise auszuschließen sind beziehungsweise manche gültige Module durch
weitaus effizientere Module mit gleichen Möglichkeiten ersetzt werden können. Als
</bodyText>
<figure confidence="0.954386866666667">
(a) (b) (c) (d)
41
7 Der Algorithmus im Detail
Abbildung 7.5: Ein gültiges Modul (a) kann durch ein effizienteres Modul (b) ersetzt
werden.
(a) (b)
T3
T2
VZ T1 v T4 w
T3
T2
VZ T1 v T4 w
T5
T5
(a) (b)
</figure>
<bodyText confidence="0.993906714285714">
Abbildung 7.6: Konstuktion einer Tour T&apos; aus einer Tour T unter der Annahme, dass
T zweimal Knoten w direkt nach v besucht.
Beispiel für einen solchen Austausch im Sinne der Effizienzsteigerung soll Abb. 7.5
dienen. Dort verlangt Modul 7.5a das Erreichen und sofortige Verlassen des Ganges
von links oben, weshalb diese beiden Kanten und damit auch nicht notwendiger Weg
eingespart werden könnten.
Zu beachten ist außerdem, dass eine Tour, wie sie im Rahmen dieser Arbeit ver-
standen wird, sich von Touren in Zusammenhang mit dem Travelling Salesman Pro-
blem oder dem Vehicle Routing Problem unterscheidet. Die etwas andere Auffassung
kommt daher, dass Knoten, wie zum Beispiel Kreuzungspunkte von Gängen oder die
Verdichtungszone, mehr als nur einmal besucht werden dürfen. Das ist notwendig, da
meistens keine direkte Verbindung zwischen zwei Knoten des Lagergraphs besteht.
Somit können Pfade zwischen zwei Knoten mehrfach zurückgelegt werden, allerdings
kann man die Anzahl an Verwendungen des selben Wegs von oben beschränken.
Theorem 7.3.1. Gegeben ist eine Tour T von kürzester Länge in Bezug auf eine
Menge an Punkten, die von T besucht werden. Weiters wird angenommen, es gibt
zwei adjazente Punkte v und w, welche in T zweimal unmittelbar hintereinander
besucht werden. Der Weg zwischen v und w wird dann in T einmal von v nach w
passiert und einmal umgekehrt.
Beweis. Angenommen der Weg zwischen v und w wird zweimal in der gleichen Rich-
tung durchlaufen, dann kann man die Tour T in fünf Teil-Touren T1, T2, T3, T4 und
T5 aufteilen, wie in Abb. 7.6a zu sehen, wobei VZ für die Verdichtungszone steht.
Man kann nun eine neue Tour T&apos; erzeugen, welche beginnend bei VZ entlang von T1
nach v verläuft, dann T3 von v nach w folgt, um schließlich T5 folgend von w aus zu
VZ zurückzukehren (siehe Abb. 7.6b). Da v und w adjazent sind, also kein anderer
Punkt auf dem Weg von v nach w passiert werden muss, besucht T&apos; dieselben Punkte
wie die Tour T. Weiters werden T2 und T4 innerhalb von T&apos; ausgelassen, wodurch
T&apos; kürzer ist als T und das wiederum einen Widerspruch zu der Annahme darstellt,
</bodyText>
<page confidence="0.984858">
42
</page>
<subsectionHeader confidence="0.606367">
7.3 Berechnung einzelner Touren
</subsectionHeader>
<bodyText confidence="0.774884625">
Abbildung 7.7: Sieben gültige und potentiell verwendete Gangoperationen.
Abbildung 7.8: 16 gültige und potentiell verwendete Zwischen-Gangoperationen.
dass T optimal ist.
Lemma 7.3.2. Gegeben ist eine optimale Tour T in Bezug auf eine Menge an Punk-
ten. Zwei adjazente Punkte v und w werden dann innerhalb von T höchstens zweimal
unmittelbar hintereinander besucht.
Beweis. Der Beweis dafür folgt direkt aus Theorem 7.3.1. Unter der Annahme, dass v
und w mehr als zweimal unmittelbar hintereinander besucht werden, müßte der Weg
von v nach w mindestens zweimal in derselben Richtung durchlaufen werden.
Ausgehend von Theorem 7.3.1 und Lemma 7.3.2 kann man schließen, dass es sieben
Kombinationen von Gangoperationen gibt, die in einer optimalen Tour Anwendung
finden können (siehe Abb. 7.7). Natürlich kann ein Gang auch passiert (ausgelassen)
werden, wenn keine Artikel entnommen werden müssen. Weiters kann die Anzahl
an möglichen Zwischen-Gangoperationen, die für eine optimale Tour Relevanz haben
können, von oben mit 16 eingeschränkt werden (siehe Abb. 7.8). Daher kann man mit
einer festen Anzahl an generell möglichen und verwendbaren Modulen für optimale
</bodyText>
<figure confidence="0.9987756">
(a) (b) (c)
(d) (e) (f) (g)
(a) (b) (c) (d) (e)
(f) (g) (h) (i) (j) (k)
(l) (m) (n) (o) (p)
</figure>
<page confidence="0.965104">
43
</page>
<sectionHeader confidence="0.25101" genericHeader="method">
7 Der Algorithmus im Detail
</sectionHeader>
<bodyText confidence="0.980005666666667">
Abbildung 7.9: Sind diese Module gültig oder ungültig?
Touren arbeiten. An dieser Stelle sei nochmals darauf hingewiesen, dass leere Opera-
tionen, wie in Abb. 7.7a und Abb. 7.8a, theoretisch Gänge repräsentieren sollen, die
nicht betreten oder erreicht werden müssen und im entwickelten Programm gar nicht
zum Einsatz kommen. In solchen Fällen werden diese Gänge behandelt als würden
sie für die jeweils konkrete Tour nicht existieren.
Obwohl nun ersichtlich ist, dass das Auffinden von Touren durch Auswahl geeigneter
Module bewerkstelligt werden kann, kann man beobachten, dass das Zusammenspiel
mancher Module zu letztlich ungültigen oder nicht rekonstruierbaren Touren führt
(siehe Abb. 7.9a). Hier ist zu sehen, dass durch die Kombination zweier Module
eigentlich zwei voneinander getrennte Touren entstehen würden. Wie in Abb. 7.9b
zu sehen ist, kann die Entscheidung, ob die Kombination von Modulen gültig ist,
nicht immer zu dem Zeitpunkt getroffen werden, zu dem ein Modul gewählt wird.
Manchmal bestimmt erst ein später hinzugefügtes Modul darüber, ob die Kombinati-
on gültig oder ungültig ist. Sei Mg(j) die Menge von Modulen j&apos; E Mkomp(j), wobei
die Verwendung von Modul j in einer gültigen (Sub-)Tour resultiert.
Rekursive Update Funktion Folgend aus den zuvor erwähnten Beobachtungen,
sollen zwei (n+ 1) x (ν) Matrizen σ und τ eingeführt werden, wobei n die Anzahl an
Gängen mit einzusammelnden Artikeln und ν die Anzahl an verwendbaren Modulen
sind. Ein Eintrag σij, mit 1 &amp;lt; i &amp;lt; n und 1 &amp;lt; j &amp;lt; ν, steht für die Länge einer gültigen
Tour T&apos;, welche alle Gänge 1, ... , i besucht, das heißt alle benötigten Artikel aus den
Gängen 1 bis i einsammelt und Modul j für Gang i verwendet. Analog dazu steht ein
Eintrag τij für die Länge einer Tour T&apos;&apos;, welche wiederum die Gänge 1, ... , i besucht
und Modul j für Gang i verwendet. Im Gegensatz zu Tour T&apos; besteht aber bei Tour
T&apos;&apos; die Möglichkeit durch Verwendung bestimmter Module in den Gängen i + 1 bis
n, ungültig zu werden.
Die Einträge für σ und τ berechnen sich mittels folgender rekursiver Funktion:
</bodyText>
<figure confidence="0.999164833333333">
(a)
(b)
gültig oder ungültig?
gültig oder ungültig?
gültig
ungültig
</figure>
<page confidence="0.978494">
44
</page>
<subsectionHeader confidence="0.854446">
7.3 Berechnung einzelner Touren
</subsectionHeader>
<equation confidence="0.998236416666667">
σ0µ = 0 (7.1)
τ0µ = 0 (7.2)
σ0j = ∞ für j ∈ {1, ... , ν} \ {µ} (7.3)
τ0j = ∞ für j ∈ {1, ... , ν} \ {µ} (7.4)
( )
{σi-1j, : j&apos; ∈ Mg(j)} ∪ für i ∈ {1, ... , n}
σij = ci(j) + min (7.5)
{τi-1j, : j&apos; ∈ Mg(j)} für j ∈ {1, ... , ν}
( )
{σi-1j, : j&apos; ∈ Mkomp(j)} ∪ für i ∈ {1, ... , n}
τij = ci(j) + min (7.6)
{τi-1j, : j&apos; ∈ Mkomp(j)} für j ∈ {1,..., ν}
</equation>
<bodyText confidence="0.967317">
In diesem Fall repräsentiert Modul µ die Verdichtungszone. Wenn ein Modul j für
Gang i nur ungültige Touren bilden oder nicht kompatibel nach unten sein würde,
so wird σij = ∞, beziehungsweise τij = ∞ gesetzt.
Dekodierung einer optimalen Tour Sind nun die beiden Matrizen σ und τ wie
beschrieben initialisiert worden, dann kann man die optimale Tour einfach daraus
ableiten. Zuerst muss das Modul für Gang n in der optimalen Tour gewählt werden,
welches jener Eintrag σnj repräsentiert, der minimal ist für alle j. Um die bereits
gemachten ¨Uberlegungen zu ergänzen, sind alle gültigen Module in Gang n solche,
die zwar mittels Zwischen-Gangoperationen zum Gang n − 1 verbinden, nicht aber
zu Gang n + 1.
Zur Vereinfachung nehmen wir an dieser Stelle an, dass σnJ das Modul für Gang n
in einer optimalen Tour bezeichnet. Es ist dann leicht zu zeigen, dass so ein Eintrag
existieren muss. Nun kann man einfach innerhalb der Matrix zurückverfolgen, dass
das Modul für Gang n − 1 jenes Modul j&apos; ist, für das die Gleichung (7.7) erfüllt ist:
( (7.7)
σi-1j,
σnJ − ci(j) =
τi-1j,
Für alle weiteren Gänge lässt sich die optimale Tour entsprechend ableiten. Sollte
der Fall eintreten, dass mehr als ein Modul die Gleichung (7.7) erfüllt, so ist das
gleichbedeutend damit, dass es mehrere optimale Touren gibt. Aus diesen Touren ist
dann eine beliebige wählbar.
</bodyText>
<subsectionHeader confidence="0.915599">
7.3.3 S-Shape-Heuristik
</subsectionHeader>
<bodyText confidence="0.949334333333333">
Wie bereits in Kapitel 3.4 erwähnt, gibt es Arbeiten, welche zur Berechnung von
Touren auf die so genannte S-Shape-Heuristik zurückgreifen. Das Verfahren folgt ei-
nem einfachen Prinzip, wonach sich die Arbeiter auf S-förmigen Touren durch das
</bodyText>
<page confidence="0.99131">
45
</page>
<sectionHeader confidence="0.183072" genericHeader="method">
7 Der Algorithmus im Detail
</sectionHeader>
<bodyText confidence="0.962168071428572">
Abbildung 7.10: Veranschaulichung der S-Shape-Heuristik
Lager bewegen. Dabei wird ein Gang durchquert sobald er betreten wurde. Natürlich
werden Gänge, aus denen kein Artikel geholt werden muss, ausgelassen. Zur Veran-
schaulichung dieser Vorgehensweise soll Abb. 7.10 dienen. Laut den bereits referen-
zierten Arbeiten [4] sowie [5] kann man auf diese Weise Lösungen finden, die für
viele Probleminstanzen nahe am Optimum liegen. Das ist der Grund dafür, weshalb
diese Heuristik in Kombination mit TSH im Rahmen dieser Arbeit als Referenzver-
fahren eingesetzt wurde. Damit kann man einen Vergleich zu den mittels des entwi-
ckelten hybriden Verfahrens berechneten Ergebnissen anstellen und deren Qualität
einschätzen. Hierbei sollte darauf hingewiesen werden, dass es sich bei den mittels S-
Shape-Heuristik gefundenen Werten nur um Richtwerte handelt. Im Gegensatz zum
vorgestellten Algorithmus werden keine Nebenbedingungen geprüft. Daher werden
beispielsweise weder Kollisionen vermieden und Artikel stets vom ersten gefundenen
Lagerplatz geholt anstatt nach alternativen Lagerplätzen zu suchen.
</bodyText>
<subsectionHeader confidence="0.999083">
7.4 Zuordnung von Arbeitern zu Touren
</subsectionHeader>
<bodyText confidence="0.894781142857143">
Zusätzlich zu den bisherigen Schritten ist es noch wichtig eine Aufteilung aller be-
rechneten Touren auf die verfügbaren Lagerarbeiter zu erstellen. Das bedeutet, dass
jedem Arbeiter eine Liste von Touren zugewiesen wird, die von diesem dann abgear-
beitet werden muss. Nachdem sich aber alle Arbeiter gleichzeitig im Lager bewegen,
müssen entsprechende Maßnahmen getroffen werden, um gegenseitige Behinderungen
auszuschließen.
VZ
</bodyText>
<page confidence="0.917103">
46
</page>
<figure confidence="0.73931375">
7.4 Zuordnung von Arbeitern zu Touren
Algorithmus 9 : Initiale Arbeiter-Zuordnung
Input : eine Menge T von Touren Ti, mit i = 1 ... m; die Anzahl an Arbeitern
w
Data : Menge W von Mengen Wi, mit i = 1 ... m, von abzuarbeitenden
Touren, Zähler l
begin
foreach Wi ∈ W do
</figure>
<equation confidence="0.9923206">
Wi &amp;lt;-- ∅ ;
j ← 1 ;
foreach Ti ∈ T do
W; &amp;lt;-- W; ∪ {Ti} ;
if l &amp;lt; m then
l &amp;lt;-- l + 1 ;
else
l &amp;lt;-- 1 ;
return W ;
end
</equation>
<bodyText confidence="0.999510545454545">
Eine Zuordnung von Arbeitern zu Touren soll also genau dann gültig sein, wenn es
zu keinem Zeitpunkt zu Kreuzungen der Touren zweier Arbeiter innerhalb von Re-
galgängen kommt. Des weiteren sind ¨Uberholmanöver in Gängen nicht zulässig. Um
das berücksichtigen zu können, muss die Geschwindigkeit der Kommissionierungswa-
gen genauso beachtet werden, wie auch die Zeit, die notwendig ist, um die jeweiligen
Artikel auszufassen.
Trotz all dieser formalen Überlegungen darf man nicht vergessen, dass immer noch
Menschen in diesem Lager arbeiten, weshalb man entsprechende Zeitpuffer einplanen
muss. Die Arbeitsgeschwindigkeit ist eben abhängig von sehr vielen Faktoren, wie
etwa Alter und Erfahrung der Arbeiter, oder äußeren Einflüssen aus dem Umfeld des
Lagers.
</bodyText>
<subsectionHeader confidence="0.904659">
7.4.1 Konstruktionsheuristik
</subsectionHeader>
<bodyText confidence="0.999191444444444">
Zur Erzeugung einer Startlösung für weitere Berechnungen muss zunächst eine in-
itiale Zuordnung von Arbeitern zu Touren erfolgen, indem die vorhandenen Touren
gleichmäßig auf alle Arbeiter verteilt werden. Der einfache Ansatz einer First-Fit
Heuristik wird zum Auffinden einer solchen Initiallösung herangezogen (siehe Alg. 9).
Jedenfalls stellt eine solche erste Lösung keinerlei Anspruch auf Korrektheit. Zum
einen können Kollisionen der Arbeiter innerhalb von Regalgängen auftreten, zum
anderen kann nicht garantiert werden, dass alle angeforderten Artikel innerhalb des
zulässigen Zeitrahmens zur Verdichtungszone gebracht werden. Es müssen also noch
weitere Schritte folgen, um eine Zuordnung gültig zu machen. Auch hier hilft wieder
</bodyText>
<page confidence="0.987641">
47
</page>
<bodyText confidence="0.6242125">
7 Der Algorithmus im Detail
die Umsetzung einer VNS weiter.
</bodyText>
<subsectionHeader confidence="0.601747">
7.4.2 Reparatur- und Verbesserungsheuristik
</subsectionHeader>
<bodyText confidence="0.952949827586207">
Zusätzlich zur Entscheidung, ob eine Zuordnung von Arbeitern zu Touren gültig ist,
wird versucht eine Aufteilung zu finden, bei der alle Arbeiter mit ihren Arbeitsschrit-
ten so früh wie möglich fertig werden. Zu diesem Zweck bietet sich eine Zielfunktion
an, die den letzten Endzeitpunkt aller Arbeiter auswertet.
Für ein sinnvolles VNS Verfahren muss nun noch eine Anzahl an Nachbarschaften
(hier anhand von Moves) definiert werden. Sei W = Uw
ordnungen Wi von Arbeitern zu Touren. Weiters nehme man an, dass T = Um
i=1{Wi} die Menge aller Zu-
i=1{Ti}
die Menge aller zuvor berechneter Touren beschreibt. Folgende Moves bilden die
Basis für die verwendeten Nachbarschaften:
WorkerSwapMove(i, j, k, l) Dieser Schritt definiert einfach den Austausch von Tour
k E Wi und l E W;, mit 1 &amp;lt; i &amp;lt; j &amp;lt; m und k =6 l. Das bedeutet schlicht, dass
zwischen zwei Arbeitern je eine Tour ausgetauscht wird.
WorkerShiftMove(i, j, k) Hier wird lediglich eine Tour k E Wi aus Wi entfernt und
in W; an letzter Stelle angefügt, wobei 1 &amp;lt; i, j &amp;lt; m und i =6 j. Das kommt
einem Verschieben einer Tour von einem Arbeiter zu einem anderen gleich.
WorkerShiftTourMove(i, j, k) Bei diesem Schritt wird Tour j, mit j E Wi, um k
Positionen verschoben, wobei lkl &amp;lt; lWil und 1 &amp;lt; j + k &amp;lt; lWil. Eine solche
Umreihung kann in Bezug auf die termingerechte Abwicklung hilfreich sein.
WorkerSplitMove(i, R) Bei der Anwendung dieses Schrittes werden alle Elemente
in R aus Wi entfernt und in eine neue Zuordnung Wi&apos; eingefügt, welche dann
einem neuen Arbeiter zugewiesen werden kann. Dieser Schritt kann natürlich
nur angewendet werden, solange noch freie Arbeiter zur Verfügung stehen.
Aus diesen Moves ergeben sich die Nachbarschaftsstrukturen WorkerSwap, WorkerS-
hift, WorkerShiftTour und WorkerSplit.
Nachdem das Hauptziel dieser VNS Prozedur das Auffinden einer gültigen Zuordnung
von Touren zu Arbeitern ist, werden nur Moves berücksichtigt, deren Resultat eine
gültige Lösung darstellt.
</bodyText>
<subsectionHeader confidence="0.981017">
7.5 Erweiterter Algorithmus
</subsectionHeader>
<bodyText confidence="0.999197">
Da die hier vorgeschlagenen Methoden insgesamt dafür ausgelegt sind in vergleich-
bar kurzer Zeit relativ gute Lösungen zu erzeugen, ist es durchaus wahrscheinlich,
dass die gefundenen Lösungen noch weiter verbessert werden könnten. Zudem sind
</bodyText>
<page confidence="0.992221">
48
</page>
<figure confidence="0.809721416666667">
7.5 Erweiterter Algorithmus
Algorithmus 10 : Erweiterter Algorithmus
Input : Bestellungen mit Listen aller einzusammelnder Artikel
Output : Eine Zuordnung von Arbeitern zu fertigen Touren
begin
repeat
Erstelle Partitionierung vorhandener Bestellungen ;
repeat
repeat
Berechne Zuordnung von Artikeln zu Touren ;
Berechne optimale Touren für die oben erstellte Zuordnung ;
until keine Verbesserung konnte erzielt werden ;
</figure>
<listItem confidence="0.4529952">
(4) Erstelle eine Zuordnung von Arbeitern zu Touren ;
return die aktuelle Zuordnung von Arbeitern zu Touren ;
until ein definiertes Abbruchkriterium ist erfüllt ;
until keine weiteren Bestellungen sind abzuarbeiten ;
end
</listItem>
<bodyText confidence="0.999646533333333">
zu dem Zeitpunkt, zu dem der Algorithmus zu arbeiten beginnt, noch nicht alle
Bestellungen bekannt, die im Laufe des Tages zu bearbeiten sein werden. Deshalb
empfiehlt es sich eine erweiterte Variante des Alg. 3 wie in Alg. 10 beschrieben zu
verwenden. Anstelle eines Abbruchs, sobald eine Zuordnung von Touren zu Arbeitern
gefunden wurde, soll der Algorithmus hier wieder von vorne beginnen, allerdings un-
ter Berücksichtigung von bereits bearbeiteten Aufteilungen. Das bedeutet etwa, dass
bereits eingesammelte Artikel natürlich nicht mehr vertauscht werden können, oder,
dass Arbeiter, die bereits auf dem Weg zu einem Artikel sind nicht mehr anders
geschickt werden können. Sonstige Änderungen können natürlich noch durchgeführt
werden, solange sie eine Verbesserung der Gesamtlösung bringen. Der Algorithmus
sollte dann arbeiten, bis alle Bestellungen anforderungsgemäß bearbeitet wurden.
Um den Algorithmus möglichst effizient zu gestalten, müssen natürlich auch die dar-
unterliegenden Datenstrukturen entsprechend gewählt werden und Bewertungsfunk-
tionen oder im Speziellen die Funktion zur Berechnung optimaler Touren möglichst
schnell arbeiten.
</bodyText>
<page confidence="0.996103">
49
50
</page>
<sectionHeader confidence="0.992078" genericHeader="method">
8 Testergebnisse
</sectionHeader>
<bodyText confidence="0.999973785714286">
Um die Verwendbarkeit der vorgestellten Methode im industriellen Umfeld abschät-
zen zu können, wurden zahlreiche Testläufe durchgeführt. Als Hardware wurde ein
zur Zeit aktuelles Arbeitsplatzsystem gewählt – konkret ein Dual Xeon mit 2.6 GHz
und 8 GB RAM. Leider war es nicht möglich Echtdaten zu bekommen, da zum
Zeitpunkt der Fertigstellung dieser Diplomarbeit noch keine hardwaremäßige Reali-
sierung im Ersatzteillager unseres Industriepartners vorgenommen wurde, weswegen
auf statistische Parameter, die im Laufe des vergangenen Jahres gesammelt wur-
den, zurückgegriffen werden musste, um zufällige Testinstanzen zu generieren. Hierzu
wurde das Lager modelliert und die einzusammelnden Artikel den Parametern ent-
sprechend zufällig im Lager verteilt. Zusätzlich wurden typische Kundenbestellungen
erzeugt. Variable Parameter waren dabei die Summe der insgesamt bestellten Arti-
kel und die Anzahl der Kundenbestellungen. Nach Rücksprache mit den Lagerleitern
wurde festgesetzt, dass Rechenzeiten bis 20 Minuten als akzeptabel gelten, weswegen
die maximal verfügbare Rechenzeit auf diese 20 Minuten gesetzt wurde.
</bodyText>
<subsectionHeader confidence="0.995574">
8.1 Wahl der Konstruktionsheuristik
</subsectionHeader>
<bodyText confidence="0.999985941176471">
In einem ersten Vortest wurde untersucht wie die beiden Konstruktionsheuristiken
zur Findung einer Ausgangslösung den gesamten Algorithmus beeinflussen. Die ver-
wendeten Testinstanzen sind nicht ident mit jenen der späteren Testläufe, da durch
die im Laufe der Entwicklung entstandenen Erweiterungen des Programms auch die
Testdaten überarbeitet werden mussten. Deshalb sind die Ergebnisse dieses Vortests
nicht direkt mit den späteren vergleichbar. In Tab. 8.1 sind die gesammelten Ergeb-
nisse ersichtlich. Sie zeigen die absoluten Werte der Summe aller Tourlängen für die
in Kapitel 7.2.1 vorgestellten Konstruktionsheuristiken CAH und TSH.
Natürlich sind diese Werte für sich noch nicht sehr aussagekräftig, vergleicht man
sie allerdings miteinander, so lassen sich gewisse Beobachtungen machen. Zunächst
fällt auf, dass die errechneten Werte der Tourlängen nicht in unmittelbarem Zu-
sammenhang mit der gewählten Methode zur Erzeugung einer Startlösung gebracht
werden können. Es gibt in beiden Fällen an manchen Stellen überdurchschnittlich
große Abweichungen. Abgesehen von wenigen Ausnahmen schwanken die Werte für
die Tourlängen im direkten Vergleich zwischen den beiden Konstruktionsheuristiken
kaum. Das legt die Vermutung nahe, dass die Wahl der Konstruktionsheuristik, wenn
überhaupt, nur einen vernachlässigbaren Einfluss auf die endgültige Lösung hat.
</bodyText>
<page confidence="0.989901">
51
</page>
<table confidence="0.914574615384615">
8 Testergebnisse
Tabelle 8.1: Absolute Werte der Tourlängen (Spalten CAH und TSH). Alle Werte
sind Durchschnittswerte über 20 Durchläufe (in Klammern sind jeweils die Standard-
abweichungen angeführt).
In Ar Vortest
TSH CAH
S1 50 9450.11 (68.94) 9428.10 (71.05)
S2 50 6961.53 (68.51) 6960.26 (48.91)
S3 50 8810.44 (30.38) 8812.79 (34.52)
S4 50 6587.15 (83.36) 7631.04 (3149.92)
S5 50 7003.12 (87.93) 7010.59 (64.48)
M1 100 15724.93 (95.96) 15747.49 (80.36)
M2 100 12266.77 (5159.42) 15229.84 (3113.72)
M3 100 10187.26 (114.72) 10188.83 (122.95)
M4 100 13872.25 (105.74) 13839.25 (131.25)
M5 100 14485.47 (5062.99) 16471.11 (4194.89)
L1 150 14772.86 (190.65) 14778.72 (174.84)
L2 150 15712.18 (162.93) 17217.15 (3677.97)
L3 150 18052.87 (3706.13) 19439.24 (200.45)
L4 150 18357.51 (167.09) 18287.73 (121.11)
L5 150 20216.30 (4847.74) 21540.72 (5330.36)
X1 200 22441.44 (4263.34) 23766.84 (5223.52)
X2 200 20354.92 (4331.64) 22260.29 (189.05)
X3 200 25609.66 (361.38) 29492.64 (5359.09)
X4 200 18393.69 (3773.50) 25555.01 (3443.50)
X5 200 19685.29 (211.60) 23847.93 (5303.58)
</table>
<page confidence="0.98054">
52
</page>
<subsectionHeader confidence="0.8380025">
8.2 Wahl von Berechnungsparametern
8.2 Wahl von Berechnungsparametern
</subsectionHeader>
<bodyText confidence="0.999996658536585">
Der erste durchgeführte Testlauf sollte nun zeigen, wie sich gewisse Berechnungspa-
rameter auf den Algorithmus auswirken. Zwei wesentliche Steuerungsmöglichkeiten
sind zum einen das Erlauben oder Verbieten des Umkehrens innerhalb von Gängen,
was bedeutet, dass ein Gang komplett durchquert werden muss, falls er betreten
wird. Zum anderen ist das die Verwendung von statischen oder dynamischen Rei-
henfolgen für die Nachbarschaften der VNS. Wie bereits in Kapitel 7.2.4 beschrieben
wurde, erfolgt bei dynamischer Nachbarschaftsreihenfolge laufend eine Umreihung
dieser Strukturen, um Lösungsverbesserungen durch normalerweise später durch-
suchte Nachbarschaften, die dann möglicherweise gar keine Verbesserungen erzielen,
schon früher zu ermöglichen. In Tab. 8.2 (ohne Artikel auf alternativen Lagerplätzen)
und Tab. 8.3 (mit Artikeln auf alternativen Lagerplätzen) sind die gesammelten
Ergebnisse des Testlaufs (Testlauf 1) zusammengefasst. Dabei wird die mittels S-
Shape-Heuristik (siehe Kapitel 7.3.3) gefundene Lösung als Referenz herangezogen.
Die berechneten Werte werden dann prozentuell dazu angegeben, sodass ein direk-
ter Vergleich möglich ist. Da alle Werte den Durchschnitt über 20 Durchläufe re-
präsentieren, wird auch die Standardabweichung angeführt. Zu beachten ist hierbei,
dass die mittels S-Shape-Heuristik erzielten Werte nur als Anhaltspunkt dienen und
keinerlei Nebenbedingungen berücksichtigt wurden. Zusätzlich sind noch die Durch-
schnittswerte für Laufzeit und Kapazitätsauslastung der Kommissionierungswagen
angegeben. Verwendet wurden die Nachbarschaften Split, Merge, Shift, Swap, Swap-
Position, SwapPositionMerge, SplitPositionMerge und DoubleShift. Diese Auflistung
entspricht gleichzeitig der Anfangsreihenfolge der Nachbarschaften.
Man kann nun beim Untersuchen der Tabellen einige interessante Entdeckungen ma-
chen. Zunächst möchte ich auf den Vergleich von statischer und dynamischer Nach-
barschaftsreihenfolge eingehen. Hier ist bei den kleinen Instanzen mit 25 Artikeln zu
sehen, dass die Werte der Zielfunktionen sehr nahe beisammen liegen, bei dynami-
scher Nachbarschaftsreihenfolge dennoch leicht bessere Werte vorliegen. Die Laufzeit
ist allerdings geringfügig länger, wenn auch nicht sehr viel. Interessant hingegen sind
die Instanzen mit 50 Artikeln, bei denen sowohl ein besseres Laufzeitverhalten, als
auch ein besserer Zielfunktionswert zu bemerken ist, wenn dynamische Nachbar-
schaftsreihenfolge verwendet wird. Auch bei jenen Instanzen mit 100 Artikeln bringt
die Berechnung mittels dynamischer Nachbarschaftsreihenfolge stets ein besseres Er-
gebnis in beiden Bereichen. Für die größeren Instanzen mit 200 Artikeln wiederum
muss man sagen, dass die dynamische Reihenfolge der Nachbarschaften keinen klaren
Vorteil bringt. Das mag aber möglicherweise daran liegen, dass bei so vielen Arti-
keln große Teile des Lagers durchlaufen werden müssen, also kaum Wege eingespart
werden können und somit die Optimierung weniger Optionen zur Verfügung hat.
Außerdem werden nach der gegebenen zeitlichen Beschränkung die Berechnungen
unterbrochen. Um die Auslastung der Kommissionierungswagen nicht außer Acht zu
lassen, sei erwähnt, dass die Durchschnittswerte eine durchwegs hohe Belegung zei-
gen, was deutlich für die Effizienz der Berechnungen spricht. Gesamt betrachtet lässt
</bodyText>
<page confidence="0.987368">
53
</page>
<figure confidence="0.978739772727273">
8 Testergebnisse
54
M1 50 3658.73 225.1 (433.63) 829.65 99.9 210.6 (520.43) 1117.14 99.9 200.9 189.0 68.9
(485.90) 649.32 99.9 (411.04) 985.47 99.9 73.2
(14.86) 1185.23 99.6 (9.42) &gt;max 99.6
75.7 75.6
L1 100 6461.82 (37.55) &gt;max 99.1 72.7 71.2 77.7 68.7
(26.68) &gt;max 99.1 (31.22) &gt;max 99.1 (13.48) &gt;max 99.1 (41.05) &gt;max 99.0 (21.73) &gt;max 99.0
X1 200 10820.65 102.7 (285.88) &gt;max 99.9 (532.23) 115.2 &gt;max 99.9 (507.35) 104.3 &gt;max 99.9 694.9
(43803.86) &gt;max 96.8 81.9
(54.59) &gt;max 99.7 382.8
(23561.90) &gt;max 98.4
94.5 82.1
L3 100 6581.63 (174.52) &gt;max 99.8 (142.52) 95.0 &gt;max 99.8 88.2 68.1
(153.86) 1188.82 99.8 (179.97) &gt;max 99.8 73.8
(40.10) &gt;max 99.6 (50.82) &gt;max 99.6
87.7 &gt;max 99.9 110.8 &gt;max 99.9 81.5 81.6 &gt;max 99.9 70.9 66.5
L2 100 6622.66 &gt;max 99.9 &gt;max 99.6 , �� &gt;max 99.6
L2 100 6622.66 87.7 &gt;max 99.9 110.8 &gt;max 99.9 81.5 &gt;max 99.9 81.6 &gt;max 99.9 70.9 &gt;max 99.6 66.5 &gt;max 99.6
(156.68) (607.07) (173.85) (157.74) (49.67) (46.18)
94.5 95.0 88.2 82.1 73.8 68.1
L3 100 6581.63 ,,,,, .,,� &gt;max 99.8 „ ,,, .,,� &gt;max 99.8 ,, .,, �„� 1188.82 99.8 ,,,,,, ,,,,� &gt;max 99.8 ,,,, ,,,� &gt;max 99.6 ,.,, ,„, &gt;max 99.6
L4 100 6740.34 104.8 &gt;max 99.8 115.3 &gt;max 99.8 95.2 102.1 &gt;max 99.8 72.0 67.4
&gt;max 99.8 &gt;max 99.6 &gt;max 99.6
L4 100 6740.34 104.8 &gt;max 99.8 115.3 &gt;max 99.8 95.2 &gt;max 99.8 102.1 &gt;max 99.8 72.0 &gt;max 99.6 67.4 &gt;max 99.6
(303.67) (310.36) (196.42) (307.57) (68.85) (43.64)
93.3 &gt;max 99.7 107.3 &gt;max 99.7 109.9 &gt;max 99.7 152.2 &gt;max 99.7 100.3 226.4
X4 200 11011.98 &gt;max 99.5 &gt;max 99.5
X4 200 11011.98 93.3 &gt;max 99.7 107.3 &gt;max 99.7 109.9 &gt;max 99.7 152.2 &gt;max 99.7 100.3 &gt;max 99.5 226.4 &gt;max 99.5
(177.47) (372.87) (1469.24) (5119.61) (1978.89) (10815.91)
M3 50 4325.10 133.8 (258.82) 832.84 99.8 (196.96) 127.8 1138.18 99.8 119.9 118.0 61.2
(152.27) 660.23 99.8 (149.04) 894.85 99.8 66.6
(13.52) 1137.23 99.6 (9.23) &gt;max 99.6
M2 50 3908.69 101.1 921.98 99.3 95.2 1158.00 99.3 98.1 87.4 957.56 99.3 71.9 68.1
638.38 99.3 1151.07 99.0 ,,, ,,,� &gt;max 99.0
M2 50 3908.69 101.1 921.98 99.3 95&apos;2 1158.00 99.3 98.1 638.38 99.3 87&apos;4 957.56 99.3 71&apos;9 1151.07 99.0 68&apos;1 &gt;max 99.0
(192.75) (143.38) (154.15) (126.26) (9.54) (6.47)
133.8 127.8 119.9 118.0 66.6 61.2
M3 50 4325.10 „� 832.84 99.8 „� 1138.18 99.8 � 660.23 99.8 894.85 99.8 � 1137.23 99.6 &gt;max 99.6
X3 200 10987.27 129.1 (332.14) &gt;max 99.9 (531.30) 148.6 &gt;max 99.9 (251.67) 121.5 &gt;max 99.9 335.7 72.9
(12189.38) &gt;max 99.8 83.3
(66.47) &gt;max 99.6 (65.01) &gt;max 99.6
84.0 &gt;max 99.5 93.8 &gt;max 99.5 147.9 103.9 &gt;max 99.5 80.3 118.7
X2 200 11049.59 &gt;max 99.5 &gt;max 99.3 &gt;max 99.3
X2 200 11049.59 84.0 &gt;max 99.5 93.8 &gt;max 99.5 147.9 &gt;max 99.5 103.9 &gt;max 99.5 80.3 &gt;max 99.3 118.7 &gt;max 99.3
(146.84) (344.94) (4458.14) (1926.03) (51.32) (5157.68)
129.1 148.6 121.5 335.7 83.3 72.9
X3 200 10987.27 � &gt;max 99.9 &gt;max 99.9 � &gt;max 99.9 �� &gt;max 99.8 &gt;max 99.6 &gt;max 99.6
M4 50 3886.14 106.3 791.38 99.2 93.4 1133.87 99.2 96.2 101.7 947.45 99.2 68.2 64.7
685.06 99.2 1153.65 99.0 &gt;max 99.0
M4 50 3886.14 106.3 791.38 99.2 93.4 1133.87 99.2 96.2 685.06 99.2 101.7 947.45 99.2 68.2 1153.65 99.0 64.7 &gt;max 99.0
(286.22) (191.30) (183.15) (230.13) (13.04) (6.59)
68.6 81.05 72.5 67.4 111.65 80.8 67.6 66.6 152.07 77.5 67.3 66.5
S2 25 2150.77 83.64 69.9 342.29 74.4 420.56 79.2
S2 25 2150.77 68.6 81.05 72.5 67.4 111.65 80.8 67.6 83.64 69.9 66.6 152.07 77.5 67.3 342.29 74.4 66.5 420.56 79.2
(8.27) (8.19) (1.92) (0.64) (0.56) (0.10)
75.2 74.8
S1 25 2135.47 (4.74) 92.05 80.4 72.6 72.5 74.7 72.6
(2.22) 119.63 87.1 (1.38) 105.77 80.6 (1.27) 156.23 86.1 (0.88) 300.90 86.9 (1.21) 401.12 86.7
73.0 70.1
S3 25 2368.25 (1.29) 108.64 85.6 (3.37) 70.2 135.41 85.6 72.9 69.5
(0.00) 119.23 85.6 (1.19) 148.48 85.6 70.9
(0.00) 270.27 86.2 (0.72) 381.24 80.2
S3 25 2368.25 73.0 108.64 85.6 70.2 135.41 85.6 72.9 119.23 85.6 70.1 148.48 85.6 70.9 270.27 86.2 69.5 381.24 80.2
68.5 89.24 72.7 68.0 104.24 72.7 68.3 67.8 129.77 72.7 67.6 67.6
S4 25 2320.21 90.77 72.7 241.96 74.2 299.53 68.2
S4 25 2320.21 68.5 89.24 72.7 68.0 104.24 72.7 68.3 90.77 72.7 67.8 129.77 72.7 67.6 241.96 74.2 67.6 299.53 68.2
(7.02) (1.04) (3.48) (0.66) (0.00) (0.00)
(3.53) 82.75 78.2 63.4
66.3 (6.85) 92.97 83.7 66.2 63.1 63.0
(3.37) 103.56 78.1 (2.56) 146.03 84.0 66.1
(0.63) 286.96 85.2 (1.26) 391.50 82.8
66.3 63.4 66.2 63.1 66.1 63.0
S5 25 2352.01 _ 82.75 78.2 _ 92.97 83.7 103.56 78.1 _ 146.03 84.0 286.96 85.2 391.50 82.8
(223.85) &gt;max 99.8 99.7
87.4 (433.03) &gt;max 99.8 85.9 79.6 67.4
(136.25) &gt;max 99.8 (180.27) &gt;max 99.8 71.7
(36.90) &gt;max 99.6 (26.39) &gt;max 99.6
87.4 99.7 85.9 79.6 71.7 67.4
L5 100 6560.45 � &gt;max 99.8 &gt;max 99.8 &gt;max 99.8 &gt;max 99.8 &gt;max 99.6 &gt;max 99.6
(258.96) &gt;max 100.0 122.5
114.9 (591.60) &gt;max 100.0 116.0 100.0 111.6
(703.96) &gt;max 100.0 (358.40) &gt;max 99.0 127.4
(5058.53) &gt;max 99.8 (4570.83) &gt;max 99.1
114.9 122.5 116.0 100.0 127.4 111.6
X5 200 11428.16 � &gt;max 100.0 &gt;max 100.0 &gt;max 100.0 &gt;max 99.0 � &gt;max 99.8 � &gt;max 99.1
(1133.36) 974.95 99.8 179.1
196.8 (889.70) 1189.09 99.8 135.4 120.1 64.7
(226.24) 651.23 99.8 (287.27) 1026.55 99.8 69.4
(7.65) 1158.30 99.6 (7.84) &gt;max 99.6
196.8 179.1 135.4 120.1 69.4 64.7
M5 50 4160.70 „� 974.95 99.8 ,� „� 1189.09 99.8 � 651.23 99.8 � 1026.55 99.8 1158.30 99.6 &gt;max 99.6
In Ar fSS(x) f(x) t C f(x) t C f(x) t C f(x) t C f(x) t C f(x) t C
statische Reihenfolge dynamische Reihenfolge dynamische Reihenfolge
Testlauf 1 Testlauf 2
ohne Umkehren mit Umkehren ohne Umkehren mit Umkehren ohne Umkehren mit Umkehren
Tabelle 8.2: Ergebnisse der Testläufe 1 und 2 ohne Artikeln auf alternativen Lagerplätzen - Durchschnittswerte über 20 Testläufe mit 25, 50,
100 und 200 einzusammelnden Artikeln (Ar). Angeführt sind der Zielfunktionswert (f(x) in Prozent [%]) relativ zur mittels S-Shape konstruierten
Referenzlösung (fSS(x)) und mit absoluter Standardabweichung in Klammern, die Laufzeit (t in Sekunden [s]) und die Kapazitätsauslastung der
Kommissionierungswagen (C in Prozent [%]). Getestet wurden die Instanzen (In) ohne Artikeln auf alternativen Lagerplätzen bei Berechnung mit
und ohne Umkehren innerhalb eines Ganges und bei statischer und dynamischer Nachbarschaftsreihenfolge.
8.2 Wahl von Berechnungsparametern
55
(314.93) &gt;max 100.0 124.4
112.5 (393.85) &gt;max 100.0 106.5 142.0 125.5
(320.98) &gt;max 100.0 (4428.98) &gt;max 100.0 93.4
(1284.40) &gt;max 99.8 (5760.88) &gt;max 99.8
112.5 124.4 106.5 142.0 93.4 125.5
X5 200 11360.11 &gt;max 100.0 &gt;max 100.0 &gt;max 100.0 &gt;max 100.0 , &gt;max 99.8 , &gt;max 99.8
(188.72) &gt;max 99.8 91.1
84.5 (262.57) &gt;max 99.8 82.6 78.0 67.0
(166.42) &gt;max 99.8 (163.04) &gt;max 99.8 72.2
(39.23) &gt;max 99.6 (43.27) &gt;max 99.6
84.5 91.1 82.6 78.0 72.2 67.0
L5 100 6560.45 „�� ,,,,� &gt;max 99.8 ,,,,,,, .,,� &gt;max 99.8 ,,,,,, ,,,� &gt;max 99.8 ,,,,,, ,,,� &gt;max 99.8 ,,,,, ,,,,� &gt;max 99.6 ,,,, ,,,- &gt;max 99.6
(497.16) 950.52 99.8 169.6
176.7 (688.33) 1160.87 99.8 138.0 128.1 64.8
(263.29) 684.97 99.8 (210.22) 1081.84 99.8 68.9
(12.12) 1179.74 99.6 (9.14) &gt;max 99.6
176.7 169.6 138.0 128.1 68.9 64.8
M5 50 4160.70 „� 950.52 99.8 ,,, „� 1160.87 99.8 ,,, � 684.97 99.8 � 1081.84 99.8 � 1179.74 99.6 &gt;max 99.6
(9.99) 20.82 79.3 64.2
67.8 (8.66) 20.82 82.5 66.7 63.5 63.2
(2.68) 91.48 78.1 (3.88) 102.28 79.4 66.5
(1.40) 265.08 81.6 (1.16) 472.63 84.5
S5 25 2310.23 67.8 20.82 79.3 64.2 20.82 82.5 66.7 91.48 78.1 63.5 102.28 79.4 66.5 265.08 81.6 63.2 472.63 84.5
statische Reihenfolge dynamische Reihenfolge dynamische Reihenfolge
Testlauf 1 Testlauf 2
ohne Umkehren mit Umkehren ohne Umkehren mit Umkehren ohne Umkehren mit Umkehren
X1 200 10925.71 98.6 (300.98) &gt;max 99.9 (392.63) 117.0 &gt;max 99.9 101.1 127.8 141.1
(474.02) &gt;max 99.9 (4345.26) &gt;max 99.9 82.5
(55.80) &gt;max 99.7 (7227.99) &gt;max 100.0
</figure>
<table confidence="0.700990828125">
L1 100 6448.32 75.5 (33.27) &gt;max 99.1 (25.18) 71.7 &gt;max 99.1 75.4 71.0 74.1 70.9
(20.19) 1189.46 99.1 (22.46) &gt;max 99.1 (37.37) &gt;max 99.0 (56.67) &gt;max 99.0
M1 50 3658.73 188.6 (448.05) 946.93 99.9 200.4 (461.85) 1096.41 99.9 243.8 191.1 72.7 69.2
(477.00) 650.55 99.9 (396.50) 911.15 99.9 (14.80) 1197.71 99.6 (10.27) &gt;max 99.6
L4 100 6740.34 98.3 &gt;max 99.8 104.9 &gt;max 99.8 94.4 94.4 &gt;max 99.8 71.8 67.3
1199.49 99.8 , &gt;max 99.6 ,,,, ,,,- &gt;max 99.6
L4 100 6740.34 98.3 &gt;max 99.8 104.9 &gt;max 99.8 94.4 1199.49 99.8 94.4 &gt;max 99.8 71.8 &gt;max 99.6 67.3 &gt;max 99.6
(214.82) (286.70) (193.17) (171.96) (73.46) (46.97)
M4 50 3871.34 108.6 945.89 99.2 107.1 1153.29 99.2 95.0 89.5 70.3 66.3
669.68 99.2 973.45 99.2 � 1146.09 99.0 ,,, ,,, , &gt;max 99.0
M4 50 3871.34 108.6 945.89 99.2 107.1 1153.29 99.2 95.0 669.68 99.2 89.5 973.45 99.2 70.3 1146.09 99.0 66.3 &gt;max 99.0
(228.32) (226.38) (163.61) (178.11) (11.14) (9.61)
X4 200 11011.98 94.3 &gt;max 99.7 98.5 &gt;max 99.7 88.8 &gt;max 99.7 202.8 &gt;max 99.9 83.6 116.6
&gt;max 99.5 ,,,,� &gt;max 99.5
X4 200 11011.98 94.3 &gt;max 99.7 98.5 &gt;max 99.7 88.8 &gt;max 99.7 202.8 &gt;max 99.9 83.6 &gt;max 99.5 116.6 &gt;max 99.5
(208.04) (291.13) (212.51) (10275.14) (70.99) (4782.30)
L2 100 6548.31 94.4 &gt;max 99.9 92.5 &gt;max 99.9 83.9 88.5 &gt;max 99.9 70.0 66.2
1187.82 99.9 &gt;max 99.6 &gt;max 99.6
L3 100 6588.51 88.1 (147.70) &gt;max 99.8 93.9 (255.14) &gt;max 99.8 88.9 84.0 67.9
(140.42) &gt;max 99.8 (170.39) &gt;max 99.8 75.1
(59.88) &gt;max 99.6 (25.49) &gt;max 99.6
L2 100 6548.31 94.4 &gt;max 99.9 92.5 &gt;max 99.9 83.9 1187.82 99.9 88.5 &gt;max 99.9 70.0 &gt;max 99.6 66.2 &gt;max 99.6
(211.54) (366.95) (148.72) (225.18) (25.04) (26.12)
88.1 93.9 88.9 84.0 .1
L3 100 6588.51 � &gt;max 99.8 &gt;max 99.8 &gt;max 99.8 &gt;max 99.8 75 &gt;max 99.6 67.9&gt;max 99.6
X2 200 10997.52 86.9 &gt;max 99.5 86.0 &gt;max 99.5 84.1 278.2 &gt;max 99.5 81.9 108.5
&gt;max 99.5 &gt;max 99.3 � &gt;max 99.3
X3 200 10932.39 135.9 (374.26) &gt;max 99.9 (528.37) 151.7 &gt;max 99.9 123.9
(301.01) &gt;max 99.9 (312.00) &gt;max 99.9 141.9
116.3 (6124.02) &gt;max 99.6 418.9
(12399.40) &gt;max 99.6
X2 200 10997.52 86.9 4.
&gt;max 99.5 86.0 &gt;max 99.5 81 &gt;max 99.5 278.2 &gt;max 99.5 81.9 &gt;max 99.3 108.5 &gt;max 99.3
(207.66) (296.29) (160.55) (15585.21) (69.20) (3542.61)
135.9 151.7 123.9 116.3 141.9 418.9
X3 200 10932.39 , , &gt;max 99.9 , &gt;max 99.9 , &gt;max 99.9 &gt;max 99.9 , &gt;max 99.6 „ &gt;max 99.6
M2 50 3932.43 104.7 804.04 99.3 99.8 1118.80 99.3 92.3 85.5 71.2 67.6
797.88 99.3 901.94 99.3 1181.24 99.0 &gt;max 99.0
M3 50 4256.39 130.5 (259.84) 694.81 99.8 (288.40) 123.8 1122.85 99.8 127.5 106.5 62.1
(164.63) 669.46 99.8 (132.44) 973.31 99.8 66.8
(10.71) 1173.11 99.6 (9.11) &gt;max 99.6
M2 50 3932.43 104.7 804.04 99.3 99.8 1118.80 99.3 92.3 797.88 99.3 85.5 901.94 99.3 71.2 1181.24 99.0 67.6 &gt;max 99.0
(141.95) (179.04) (108.51) (143.83) (8.86) (7.70)
130.5 . 127.5 106.5 6.8 62.1
M3 50 4256.39 ,,, ,� 694.81 99.8 ,,,1238 „, 1122.85 99.8 � 669.46 99.8 973.31 99.8 6, 1173.11 99.6 &gt;max 99.6
(7.43) (6.82) (1.41) (0.97) (0.92) (0.85)
S3 25 2368.25 72.9 (0.95) 111.35 85.6 (2.39) 70.3 131.97 85.6 73.0 70.1 70.9 69.4
(1.26) 92.90 85.6 (0.97) 170.86 85.6 (0.02) 259.24 86.2 (0.61) 360.82 86.2
S3 25 2368.25 72&apos;9, 111.35 85.6 70&apos;3 131.97 85.6 73.0 92.90 85.6 - 170.86 85.6 70&apos;9 259.24 86.2 69&apos;4 360.82 86.2
S1 25 2147.27 74.8 (5.23) 62.30 76.9 (1.76) 72.2 104.79 80.5 74.4 72.1 74.4 72.0
(0.95) 136.75 80.0 (1.74) 178.48 84.5 (2.36) 454.55 83.5 (0.00) 523.18 90.2
S2 25 2150.77 68.1 59.76 69.7 66.8 91.76 73.3 67.5 66.2 143.19 74.6 67.3 66.2
117.70 70.2 360.31 74.8 498.57 78.2
S2 25 2150.77 68.1 59.76 69.7 66.8 91.76 73.3 67.5 117.70 70.2 66.2 143.19 74.6 67.3 360.31 74.8 66.2 498.57 78.2
S4 25 2320.21 68.3 90.92 72.7 67.9 122.70 72.7 68.1 67.8 134.27 72.7 67.6 67.6
94.71 72.7 250.91 74.2 325.90 74.2
S4 25 2320.21 68.3 90.92 72.7 67.9 122.70 72.7 68.1 94.71 72.7 67.8 134.27 72.7 67.6 250.91 74.2 67.6 325.90 74.2
(4.26) (0.99) (1.82) (0.73) (0.00) (0.00)
In Ar fSS(x) f(x) t C f(x) t C f(x) t C f(x) t C f(x) t C f(x) t C
Tabelle 8.3: Ergebnisse der Testläufe 1 und 2 mit Artikeln auf alternativen Lagerplätzen - Durchschnittswerte über 20 Testläufe mit 25, 50,
100 und 200 einzusammelnden Artikeln (Ar). Angeführt sind der Zielfunktionswert (f(x) in Prozent [%]) relativ zur mittels S-Shape konstruierten
Referenzlösung (fSS(x)) und mit absoluter Standardabweichung in Klammern, die Laufzeit (t in Sekunden [s]) und die Kapazitätsauslastung der
Kommissionierungswagen (C in Prozent [%]). Getestet wurden die Instanzen (In) mit Artikeln auf alternativen Lagerplätzen bei Berechnung mit
und ohne Umkehren innerhalb eines Ganges und bei statischer und dynamischer Nachbarschaftsreihenfolge.
</table>
<sectionHeader confidence="0.912643" genericHeader="method">
8 Testergebnisse
</sectionHeader>
<bodyText confidence="0.999635535714286">
die Verwendung von dynamischen Nachbarschaftsreihenfolgen bessere Ergebnisse er-
warten und sollte wohl im Echtbetrieb bevorzugt verwendet werden.
Nun zum Unterschied zwischen den Werten mit und denen ohne Umkehren. Vor al-
lem bei kleineren bis mittleren Instanzen sind klare Vorteile durch das Zulassen des
Umkehrens auszumachen. Auch hier sind interessanter Weise die Laufzeiten leicht
über denen der Tests ohne Umkehren. Sobald die Instanzen eine Größe erreichen, bei
der der Algorithmus abgebrochen wird, lässt sich nur schwer eine Aussage darüber
machen, wie repräsentativ die Werte sind. Aber wie auch beim Vergleich zwischen
statischer und dynamischer Nachbarschaftsreihenfolge sind keine klaren Vorteile für
ein Verfahren auszumachen. Dennoch scheint man mit Umkehren eher bessere Er-
gebnisse erzielen zu können.
Weiters wurden die Instanzen hinsichtlich ihrer Lösbarkeit bei Verwendung von al-
ternativen Lagerplätzen für bestimmte Artikel untersucht. Das heißt also, dass man-
che Artikel an mehreren Positionen im Lager verfügbar sind und damit zusätzliche
Möglichkeiten zur Bildung von Touren vorliegen können. Wirklich klare Unterschiede
sind hier nur schwer zu erkennen. Wenn überhaupt, so sind am ehesten in Kombina-
tion mit dem Erlauben des Umkehrens leichte Vorteile auszumachen. Das liegt aber
sicherlich auch daran, dass nicht alle Artikel an mehreren Positionen verfügbar sind.
Somit kann es auch passieren, dass für die angeforderten Artikel keine alternativen
Lagerplätze existieren und somit dieselbe Problemstellung vorherrscht wie bei der
Berechnung ohne alternative Lagerplätze.
Generell sind nach diesen Tests natürlich nur Tendenzen auszumachen, es ist aber
zu beachten, dass durchaus die Werte für kleinere Instanzen ausschlaggebend sind,
da, wie auch schon in der Problembeschreibung erwähnt, nicht alle angeforderten
Artikel auf einmal bekannt sind. Es kann also angenommen werden, dass im Ver-
lauf eines Arbeitstages immer wieder kleinere Instanzen verarbeitet werden. Unter
diesem Gesichtspunkt bieten die zuvor gefundenen Unterschiede durchaus eine Ent-
scheidungsgrundlage zur Wahl entsprechender Berechnungsparameter.
</bodyText>
<subsectionHeader confidence="0.998876">
8.3 Effizienz einzelner Nachbarschaften
</subsectionHeader>
<bodyText confidence="0.999942">
Neben den im vorigen Abschnitt erläuterten Ergebnissen, wurde auch das Verhal-
ten der Nachbarschaften im Verlauf des Algorithmus ausgewertet. In Tab. 8.4 ist
zu sehen wie hoch der Anteil an Verbesserungen gegenüber allen getesteten Schrit-
ten einer Nachbarschaft ist. Wurden also beispielsweise 100 Schritte innerhalb einer
Nachbarschaft getestet und führten 80 davon zu einer Verbesserung, so würde in der
Tabelle ein Wert von 80% vermerkt werden. Die ersten vier Nachbarschaften stellen
grundlegende Operationen zur Lösungsverbesserung dar, weshalb sie auch zu Beginn
gereiht werden. SplitMove ist an erster Stelle, um aus anfänglich meist großen Touren
zunächst mehrere kleinere zu erzeugen. Die Laufzeiten der folgenden Nachbarschaf-
</bodyText>
<page confidence="0.932503">
56
</page>
<subsectionHeader confidence="0.695102">
8.4 Rechenzeit der Nachbarschaften
</subsectionHeader>
<bodyText confidence="0.999954121212121">
ten ShiftMove und SwapMove sind abhängig von der Anzahl der Touren insgesamt,
weshalb vor diesen beiden noch Merge durchsucht wird. Das ermöglicht das Zusam-
menführen mancher Touren, falls dies eine Verbesserung bringt. Erst im Anschluss
an diese vier Nachbarschaften folgen jene, deren Komplexität größer ist, wobei die
Reihenfolge hier auf Basis von kleineren Vortests so gewählt wurde. Es folgen also
noch SwapPosition, SwapPositionMerge, SplitPositionMerge und DoubleShift. Selbst-
verständlich wirkt sich diese Reihenfolge nur direkt bei Verwendung von statischer
Nachbarschaftsreihenfolge aus. Das Durchsuchen der Nachbarschaften erfolgte außer-
dem unter Verwendung der Strategie Next Improvement (siehe dazu auch Kapitel 5).
Sofort fallen viele Einträge mit ”0.0%“ auf. Vor allem Nachbarschaft N7 ist hier sehr
dominant, was aber durchaus zu erklären ist, da ein verteiltes Einsammeln eines Ar-
tikels von mehreren Positionen bedeutet, eine Position mehr im Lager anfahren zu
müssen. Es ist zwar vorstellbar, dass in manchen Szenarien solch eine Aufteilung
von Nutzen ist, die Tests haben allerdings gezeigt, dass damit nicht sehr viel verbes-
sert werden kann. Das Verhalten im Echtbetrieb kann leider nur schwer eingeschätzt
werden, denn hierzu müsste man auf Basis von echten Daten entsprechende Aus-
wertungen erstellen. Weiters sind die Nachbarschaften N5 und N6 nur dann sinnvoll,
wenn auch alternative Positionen von Artikeln im Lager verwendet werden, deshalb
wurden die entsprechenden Einträge mit ”-“ markiert. Zusätzlich dazu beeinflusst
die dynamische Reihung der Nachbarschaften deren Effizienz entscheidend, was sehr
deutlich bei N8 zu sehen ist. Da bei statischer Reihenfolge der Nachbarschaften schon
N3 viele ShiftMoves durchführt, so bleiben für N8 natürlich kaum mehr Möglichkei-
ten zur Verbesserung. Anders bei dynamischer Reihenfolge, wo die Nachbarschaften
einigermaßen gleichmäßig verteilt zum Einsatz kommen. Eine weitere Beobachtung
kann hinsichtlich N2 gemacht werden. Der Prozentsatz ist hier vor allem bei größeren
Instanzen sehr klein, was darauf zurückzuführen ist, dass Merge nur dann sinnvoll
verwendet werden kann, wenn Kommissionierungswagen weit unter ihrer Kapazität
ausgelastet sind, was lediglich zu Beginn des Algorithmus sehr wichtig ist, mit zu-
nehmender Laufzeit aber kaum mehr vorkommen dürfte. Besonders effizient hinge-
gen verhält sich N1, wo ein sehr hoher Prozentsatz an erzeugten SplitMoves auch
tatsächlich zu einer Verbesserung der Gesamtlösung führt. Dabei steht vor allem das
Beseitigen von überfüllten Kommissionierungswagen und damit ungültigen Touren
im Vordergrund.
</bodyText>
<subsectionHeader confidence="0.985425">
8.4 Rechenzeit der Nachbarschaften
</subsectionHeader>
<bodyText confidence="0.9997028">
Repräsentativ für das Laufzeitverhalten der einzelnen Nachbarschaften soll Tab. 8.5
(Testlauf 1) zeigen, wie hoch der Rechenaufwand der einzelnen Nachbarschaften
ausfällt.
Vor allem N8 schlägt hier mit besonders hohem Aufwand zu Buche, was durch die ei-
nigermaßen hohe Effizienz bei Verwendung dynamisch veränderbarer Nachbarschafts-
</bodyText>
<page confidence="0.979358">
57
</page>
<sectionHeader confidence="0.351779" genericHeader="evaluation">
8 Testergebnisse
</sectionHeader>
<table confidence="0.875520830188679">
statische Reihenfolge dynamische Reihenfolge
In Ar N1 N2 N3 N4 N5 N6 N7 N8 N1 N2 N3 N4 N5 N6 N7 N8 N1 N2 N3 N4 N5 N6 N7 N8 N1 N2 N3 N4 N5 N6 N7 N8
Testlauf 1
ohne Umkehren mit Umkehren ohne Umkehren mit Umkehren
Tabelle 8.4: Effizienz der Nachbarschaften in Testlauf 1 ohne bzw. mit Artikeln auf alternativen Lagerplätzen - Durchschnittswerte über 20
Testläufe mit 25, 50, 100 und 200 einzusammelnden Artikeln (Ar). Angeführt ist pro Nachbarschaft der prozentuelle Anteil (alle Werte in Prozent
[%]) an erfolgreichen Schritten in Relation zu den insgesamt getesteten Schritten der jeweiligen Nachbarschaft. Getestet wurden die Instanzen (In)
ohne bzw. mit Artikeln auf alternativen Lagerplätzen bei Berechnung mit und ohne Umkehren innerhalb eines Ganges und bei statischer und
dynamischer Nachbarschaftsreihenfolge. (N1: Split; N2: Merge; N3: Shift; N4: Swap; N5: SwapPosition; N6: SwapPositionMerge; N7: SplitPositionMerge; N8: DoubleShift.)
S1 25 50.3 53.8 62.9 34.9 0.0 2.8 0.0 3.9 38.6 43.3 67.8 46.5 0.0 9.1 0.0 4.7 46.2 44.1 67.6 75.2 14.7 12.8 0.0 62.8 40.6 33.5 71.7 74.8 12.9 16.7 0.0 58.5
S2 25 44.8 47.6 68.5 36.0 0.7 12.3 0.0 6.5 33.2 40.0 73.6 38.4 0.0 10.4 0.0 1.7 46.5 41.5 74.1 68.4 15.1 20.3 0.0 64.8 41.3 36.1 79.9 69.5 10.9 16.6 0.0 62.3
S3 25 100.0 8.1 77.9 64.0 0.0 0.0 0.0 0.0 100.0 10.5 74.4 63.8 0.0 0.0 0.0 0.8 100.0 7.2 76.9 89.2 0.0 0.0 0.0 35.5 100.0 6.4 75.0 87.4 0.0 0.0 0.0 37.3
S4 25 100.0 14.9 71.1 58.1 0.0 0.0 0.0 4.6 93.3 15.9 74.4 55.1 0.0 0.0 0.0 0.7 100.0 13.4 73.6 83.7 0.0 0.0 0.0 31.5 97.8 14.7 76.9 82.1 0.0 0.0 0.0 47.6
S5 25 85.1 57.4 66.4 79.1 0.0 0.0 0.0 62.7 66.4 53.4 84.0 83.9 0.0 0.0 0.0 73.3 69.1 33.6 67.8 81.7 39.1 10.9 0.0 75.4 52.2 38.8 80.1 77.2 25.2 19.1 0.0 68.3
M1 50 100.0 2.2 44.5 96.5 0.0 0.0 0.0 0.0 100.0 1.5 46.0 96.8 0.0 0.0 0.0 0.0 98.0 2.5 66.3 97.0 62.8 49.9 0.0 46.8 100.0 0.1 69.5 97.3 66.3 47.3 0.0 43.6
M2 50 100.0 2.0 53.7 95.3 0.0 0.0 0.0 0.0 100.0 1.4 55.6 96.5 0.0 0.0 0.0 0.0 100.0 3.3 70.0 97.3 0.0 0.0 0.0 17.4 100.0 1.1 71.8 97.6 0.0 0.0 0.0 32.8
M3 50 100.0 2.5 65.7 94.5 0.0 0.0 0.0 0.0 100.0 1.7 64.4 95.8 0.0 0.0 0.0 0.0 100.0 1.7 67.3 96.8 55.3 47.7 0.0 61.3 100.0 0.8 72.4 96.8 58.6 57.9 0.0 56.2
M4 50 100.0 2.1 50.2 94.8 0.0 0.0 0.0 0.0 100.0 1.6 51.5 95.8 0.0 0.0 0.0 0.0 99.0 0.8 65.5 97.1 52.8 58.6 0.0 48.2 100.0 0.3 64.5 97.6 55.0 51.1 0.0 47.8
M5 50 100.0 1.9 57.3 95.3 0.0 0.0 0.0 0.0 100.0 1.6 58.9 96.2 0.0 0.0 0.0 0.0 100.0 0.4 61.4 96.9 37.8 13.9 0.0 63.5 100.0 0.2 68.2 97.2 34.2 11.6 0.0 50.8
L1 100 100.0 2.8 47.8 96.0 0.0 0.0 0.0 0.0 100.0 1.6 52.9 99.0 0.0 0.0 0.0 0.0 100.0 3.8 56.8 97.2 76.7 71.4 0.0 67.6 100.0 0.9 81.9 98.3 62.9 82.6 0.0 61.9
L2 100 100.0 2.6 53.6 97.0 0.0 0.0 0.0 0.0 100.0 1.7 56.2 99.6 0.0 0.0 0.0 0.0 100.0 1.3 72.1 97.3 54.6 70.4 0.0 63.0 100.0 1.2 83.9 98.6 58.1 82.6 0.0 59.0
L3 100 100.0 3.0 52.8 96.5 0.0 0.0 0.0 0.0 100.0 1.4 59.2 99.1 0.0 0.0 0.0 0.0 99.6 2.9 60.7 97.1 70.8 63.8 0.0 70.4 99.6 1.0 87.5 98.1 74.0 72.3 0.0 66.8
L4 100 100.0 2.1 50.6 96.8 0.0 0.0 0.0 0.0 100.0 1.4 53.9 99.7 0.0 0.0 0.0 0.0 100.0 0.9 60.9 97.2 53.7 42.0 0.0 64.4 98.8 2.0 71.7 98.7 62.1 33.7 0.0 75.2
L5 100 100.0 2.2 54.4 96.4 0.0 0.0 0.0 0.0 100.0 1.6 54.4 99.2 0.0 0.0 0.0 0.0 100.0 1.2 67.1 96.9 49.4 52.9 0.0 58.4 100.0 0.1 76.2 98.8 44.5 55.6 0.0 59.1
X1 200 100.0 1.3 75.4 99.1 0.0 0.0 0.0 0.0 100.0 1.1 84.1 100.0 0.0 0.0 0.0 0.0 100.0 8.8 75.5 98.5 69.3 87.0 0.0 82.8 100.0 1.7 91.1 100.0 65.7 93.0 2.6 90.8
X2 200 100.0 0.8 76.4 98.9 0.0 0.0 0.0 0.0 100.0 0.7 86.1 100.0 0.0 0.0 0.0 0.0 100.0 8.2 83.3 98.6 72.1 85.5 0.0 86.4 100.0 2.9 96.1 100.0 65.9 91.7 0.0 88.8
X3 200 100.0 0.8 70.8 99.8 0.0 0.0 0.0 0.0 100.0 0.4 85.7 100.0 0.0 0.0 0.0 0.0 100.0 7.4 66.1 98.6 64.8 84.7 0.0 82.4 100.0 4.3 89.8 100.0 65.2 91.5 0.0 88.7
X4 200 100.0 1.1 76.8 99.0 0.0 0.0 0.0 0.0 100.0 0.5 85.5 100.0 0.0 0.0 0.0 0.0 100.0 2.4 60.7 98.5 58.1 49.9 0.0 89.5 100.0 1.9 86.6 100.0 61.2 53.3 0.0 92.0
X5 200 100.0 1.3 74.0 99.8 0.0 0.0 0.0 0.0 100.0 0.5 86.6 100.0 0.0 0.0 0.0 0.0 99.0 18.9 68.5 98.9 88.0 99.1 0.0 92.1 100.0 24.2 83.4 100.0 80.7 99.6 0.0 95.6
mit alternativen Lagerplätzen
ohne alternative Lagerplätze
58
S1 25 46.9 49.2 49.4 45.6 - - - 1.0 40.4 41.9 55.7 49.5 - - - 3.1 54.3 39.1 71.9 76.9 - - - 47.1 48.5 32.3 76.1 78.7 - - - 50.1
S2 25 44.0 46.1 60.8 37.2 - - - 3.3 33.2 32.6 71.7 42.5 - - - 0.6 52.9 32.1 77.9 72.0 - - - 45.8 42.8 29.0 79.9 74.1 - - - 48.6
S3 25 100.0 6.9 77.3 67.6 - - - 0.0 100.0 7.8 75.9 65.6 - - - 0.0 100.0 8.7 76.2 88.7 - - - 34.0 100.0 6.5 80.4 86.8 - - - 39.3
S4 25 100.0 15.6 71.6 58.2 - - - 4.0 93.4 16.0 77.0 53.5 - - - 0.0 100.0 10.1 74.7 82.9 - - - 36.7 94.3 17.8 75.8 82.1 - - - 51.1
S5 25 67.5 38.6 44.3 55.9 - - - 0.0 48.9 40.0 62.4 41.6 - - - 0.0 71.5 33.6 66.0 80.5 - - - 40.0 55.8 31.6 75.2 77.0 - - - 42.8
M1 50 100.0 2.3 47.2 96.0 - - - 0.0 100.0 1.5 43.6 97.1 - - - 0.0 100.0 2.7 69.6 97.1 - - - 14.8 100.0 0.3 65.9 97.4 - - - 28.9
M2 50 100.0 2.4 54.5 95.6 - - - 0.0 100.0 1.4 57.4 96.3 - - - 0.0 100.0 3.9 72.7 97.1 - - - 20.2 100.0 1.5 68.6 97.8 - - - 34.0
M3 50 100.0 2.2 62.3 94.7 - - - 0.0 100.0 1.3 63.5 95.7 - - - 0.0 100.0 3.7 74.5 96.9 - - - 31.3 100.0 0.7 75.5 97.4 - - - 40.6
M4 50 100.0 2.1 57.1 94.5 - - - 0.0 100.0 1.3 51.7 96.1 - - - 0.0 100.0 1.5 75.2 96.6 - - - 23.3 100.0 1.6 71.3 97.4 - - - 34.6
M5 50 100.0 2.1 57.5 95.0 - - - 0.0 100.0 1.7 60.5 96.1 - - - 0.0 100.0 4.3 73.5 97.1 - - - 22.4 100.0 0.9 69.8 97.6 - - - 35.6
L1 100 100.0 2.2 48.7 96.2 - - - 0.0 100.0 1.7 51.6 99.5 - - - 0.0 100.0 3.8 75.4 96.0 - - - 15.4 100.0 2.1 73.2 98.5 - - - 55.4
L2 100 100.0 2.9 47.7 97.3 - - - 0.0 100.0 1.1 57.8 99.5 - - - 0.0 100.0 3.7 79.2 97.1 - - - 32.7 100.0 2.7 78.0 98.5 - - - 55.9
L3 100 100.0 2.6 54.6 96.3 - - - 0.0 100.0 1.4 59.2 99.3 - - - 0.0 100.0 3.1 78.8 96.5 - - - 30.7 100.0 0.8 86.7 98.2 - - - 58.4
L4 100 100.0 2.7 50.8 96.0 - - - 0.0 100.0 1.4 51.2 99.8 - - - 0.0 100.0 2.3 77.8 97.0 - - - 19.8 100.0 1.4 73.8 99.0 - - - 62.2
L5 100 100.0 3.1 53.1 96.5 - - - 0.0 100.0 1.3 57.8 99.2 - - - 0.0 100.0 1.4 71.9 97.0 - - - 34.0 100.0 2.0 75.3 98.8 - - - 63.0
X1 200 100.0 1.1 74.9 100.0 - - - 0.0 100.0 0.7 86.1 100.0 - - - 0.0 100.0 5.7 81.4 98.6 - - - 69.2 100.0 3.3 95.2 100.0 - - - 94.9
X2 200 100.0 0.9 78.4 99.4 - - - 0.0 100.0 0.5 86.2 100.0 - - - 0.0 100.0 1.8 84.5 98.7 - - - 79.8 100.0 3.7 94.9 100.0 - - - 91.5
X3 200 100.0 0.9 74.5 99.6 - - - 0.0 100.0 0.5 87.8 100.0 - - - 0.0 100.0 2.9 74.1 98.7 - - - 77.5 100.0 6.0 95.7 100.0 - - - 97.4
X4 200 100.0 1.1 76.2 99.4 - - - 0.0 100.0 0.4 85.5 100.0 - - - 0.0 100.0 3.9 84.1 98.3 - - - 69.9 100.0 2.5 90.6 100.0 - - - 90.7
X5 200 100.0 1.1 73.0 99.9 - - - 0.0 100.0 0.5 85.7 100.0 - - - 0.0 100.0 6.1 74.6 99.0 - - - 81.2 100.0 1.9 92.7 100.0 - - - 91.4
8.4 Rechenzeit der Nachbarschaften
</table>
<tableCaption confidence="0.5565752">
Tabelle 8.5: Rechenzeit - Durchschnittswerte über 20 Testläufe mit 25, 50, 100 und 200 einzusam-
melnden Artikeln. Zu sehen ist der prozentuelle Anteil (alle Werte in Prozent [%]) an Rechenzeit
der jeweiligen Nachbarschaft in Relation zur Rechenzeit für alle Nachbarschaften für Instanzen oh-
ne bzw. mit Artikeln auf alternativen Lagerplätzen bei Berechnung mit Umkehren innerhalb eines
Ganges und dynamischer Nachbarschaftsreihenfolge.
</tableCaption>
<table confidence="0.993768304347826">
(N1: Split; N2: Merge; N3: Shift; N4: Swap; N5: SwapPosition; N6: SwapPositionMerge; N7: SplitPositionMerge; N8: DoubleShift;
N9: ShiftSplit; N10: SwapSplit; N11: MultipleSwap; N12: MultipleSplit; N13: SplitMerge.)
In Ar Testlauf 1 Testlauf 2
N1 N2 N3 N4 N5 N6 N7 N8 N1 N2 N3 N4 N6 N7 N8 N9 N10 N11 N12 N13
S1 25 1.1 3.0 9.2 11.2 0.2 0.1 0.1 75.1 0.4 1.0 3.5 3.1 0.1 0.1 22.9 0.1 0.1 4.2 18.3 46.3
S2 25 1.2 2.7 7.8 11.6 0.2 0.1 0.1 76.4 0.4 0.9 3.3 3.7 0.1 0.0 23.1 0.1 0.1 5.1 18.5 44.7
S3 25 0.6 5.0 9.3 7.7 0.2 0.1 0.1 77.1 0.3 1.2 3.2 2.2 0.1 0.0 17.3 0.1 0.1 2.7 8.5 64.2
S4 25 0.7 5.5 11.4 9.0 0.2 0.1 0.1 73.0 0.2 1.4 3.8 2.5 0.1 0.0 17.6 0.1 0.1 2.8 8.1 63.3
S5 25 0.9 3.6 9.4 10.0 0.2 0.1 0.1 75.9 0.3 1.1 3.5 3.4 0.1 0.0 22.2 0.1 0.1 3.5 11.0 54.7
M1 50 0.4 3.9 16.1 9.6 0.1 0.0 0.0 69.8 0.2 0.6 2.2 1.7 0.0 0.0 7.8 0.1 0.0 1.3 2.8 83.2
M2 50 0.4 4.1 16.1 8.8 0.1 0.0 0.0 70.5 0.2 0.6 2.1 2.1 0.0 0.0 8.0 0.1 0.0 1.2 2.6 83.0
M3 50 0.4 4.3 16.0 10.0 0.2 0.1 0.1 69.0 0.2 0.7 2.6 2.4 0.0 0.0 7.3 0.1 0.1 1.7 3.4 81.4
M4 50 0.5 4.2 16.1 9.7 0.1 0.1 0.1 69.3 0.2 0.7 2.4 2.0 0.0 0.0 8.4 0.1 0.0 1.3 3.7 81.2
M5 50 0.5 4.1 16.7 9.3 0.2 0.1 0.0 69.1 0.2 0.7 2.1 2.1 0.0 0.0 8.1 0.1 0.1 1.4 2.3 83.0
L1 100 0.6 6.3 24.6 20.7 0.1 0.0 0.0 47.7 0.1 0.4 1.4 3.5 0.0 0.0 3.0 0.0 0.0 0.4 3.9 87.2
L2 100 0.5 3.9 22.3 23.7 0.1 0.1 0.1 49.3 0.1 0.4 0.7 2.3 0.0 0.0 3.0 0.0 0.0 0.4 2.8 90.3
L3 100 0.7 4.2 17.0 27.0 0.1 0.1 0.0 50.8 0.1 0.3 0.8 2.7 0.0 0.0 2.4 0.0 0.0 0.3 2.6 90.7
L4 100 0.5 4.0 25.3 20.4 0.1 0.0 0.0 49.6 0.1 0.3 0.8 2.6 0.0 0.0 2.4 0.0 0.0 0.3 3.1 90.3
L5 100 0.7 8.0 24.8 22.5 0.1 0.1 0.1 43.8 0.1 0.4 0.8 3.1 0.0 0.0 2.6 0.0 0.0 0.3 3.9 88.8
X1 200 2.1 6.8 27.2 39.1 0.1 0.1 0.1 24.4 0.1 0.4 0.5 1.6 0.0 0.0 0.8 0.0 0.0 0.1 1.4 95.0
X2 200 1.9 7.2 25.5 35.1 0.1 0.1 0.1 30.0 0.1 0.4 0.8 5.5 0.1 0.1 1.5 0.0 0.0 0.2 2.3 88.8
X3 200 1.9 7.6 30.7 41.7 0.1 0.1 0.1 17.8 0.1 0.3 0.6 2.5 0.0 0.0 1.0 0.0 0.0 0.1 2.3 92.9
X4 200 1.4 6.2 36.5 28.1 0.1 0.1 0.1 27.5 0.2 0.4 0.7 5.2 0.0 0.0 1.3 0.0 0.0 0.2 1.9 90.0
X5 200 1.8 6.8 31.8 28.9 0.1 0.1 0.1 30.4 0.1 0.4 0.8 5.0 0.0 0.0 1.8 0.0 0.0 0.2 3.5 88.1
S1 25 1.5 3.7 12.7 14.0 0.3 1.3 1.1 65.5 0.4 0.9 3.8 3.5 0.3 0.3 19.2 0.1 0.1 4.0 18.3 49.0
S2 25 1.6 3.5 10.6 16.1 0.4 1.4 1.1 65.3 0.4 0.9 3.7 3.3 0.4 0.3 18.0 0.1 0.1 4.9 16.7 51.1
S3 25 0.6 5.1 10.1 7.2 0.3 0.1 0.1 76.5 0.2 1.3 3.3 2.1 0.1 0.0 17.5 0.1 0.1 2.8 9.0 63.3
S4 25 0.7 5.5 11.0 8.8 0.3 0.1 0.1 73.4 0.2 1.3 3.8 2.3 0.1 0.0 17.4 0.1 0.1 2.7 8.2 63.8
S5 25 1.5 5.7 15.0 16.1 0.5 3.0 3.0 55.1 0.3 1.0 3.7 3.0 0.5 0.5 14.5 0.1 0.1 3.4 9.1 63.7
M1 50 0.4 4.4 17.4 10.9 0.4 2.0 2.9 61.6 0.2 0.6 2.7 2.0 0.2 0.4 6.7 0.1 0.1 1.0 3.7 82.5
M2 50 0.4 4.0 15.3 9.1 0.1 0.0 0.0 71.0 0.2 0.6 1.9 1.8 0.0 0.0 7.5 0.0 0.0 1.1 3.2 83.7
M3 50 0.9 5.0 20.3 12.5 0.4 1.5 2.3 57.1 0.2 0.7 2.9 2.2 0.2 0.3 6.6 0.1 0.1 1.3 3.5 82.1
M4 50 0.7 4.5 20.6 10.6 0.3 1.7 2.1 59.5 0.2 0.7 2.7 2.0 0.2 0.3 6.7 0.1 0.1 1.1 4.9 81.2
M5 50 0.7 4.9 20.6 12.3 0.3 0.6 0.7 60.0 0.2 0.7 2.7 1.9 0.1 0.1 6.4 0.1 0.0 1.1 2.0 84.6
L1 100 0.6 4.3 21.1 26.1 0.4 1.3 3.2 42.9 0.1 0.3 1.4 2.7 0.1 0.2 1.4 0.0 0.0 0.3 4.2 89.2
L2 100 0.6 4.4 18.9 24.8 0.3 1.0 2.0 47.9 0.1 0.4 1.6 3.0 0.1 0.2 1.8 0.0 0.0 0.3 4.2 88.2
L3 100 0.5 8.6 16.0 31.0 0.5 2.9 4.1 36.5 0.1 0.4 1.3 5.0 0.1 0.3 2.6 0.0 0.0 0.3 3.6 86.2
L4 100 0.7 6.0 29.7 27.7 0.3 2.5 2.9 30.2 0.1 0.4 1.5 3.9 0.1 0.2 1.7 0.0 0.0 0.3 4.2 87.4
L5 100 0.9 4.0 24.0 24.9 0.2 1.0 1.4 43.6 0.1 0.3 1.6 3.1 0.1 0.1 1.7 0.0 0.0 0.3 3.5 89.1
X1 200 0.9 5.7 33.0 36.2 0.6 2.1 6.2 15.3 0.1 0.7 1.2 6.4 0.1 0.5 1.3 0.0 0.0 0.4 3.6 85.6
X2 200 1.1 7.0 25.0 33.3 0.7 3.6 6.9 22.4 0.2 0.2 0.8 3.6 0.2 0.4 0.7 0.0 0.0 0.3 2.3 91.3
X3 200 1.1 5.4 38.7 25.0 0.6 2.5 6.3 20.5 0.1 0.2 0.6 3.2 0.1 0.3 0.6 0.0 0.0 0.3 2.4 92.1
X4 200 1.0 5.3 40.2 32.2 0.5 2.4 3.3 15.0 0.2 0.4 1.3 6.1 0.1 0.2 0.7 0.0 0.0 0.2 3.4 87.5
X5 200 0.9 4.8 49.3 21.7 0.6 2.0 12.1 8.6 0.1 0.3 0.8 0.9 0.1 0.6 0.3 0.0 0.0 0.3 2.4 94.2
ohne alternative Lagerplätze
mit alternativen Lagerplätzen
</table>
<page confidence="0.994375">
59
</page>
<sectionHeader confidence="0.985881" genericHeader="conclusions">
8 Testergebnisse
</sectionHeader>
<bodyText confidence="0.999814833333333">
strukturen durchaus vertretbar ist. Bei statischer Nachbarschaftsreihenfolge hingegen
macht die Verwendung dieser Nachbarschaft keinen Sinn und sollte ausgelassen wer-
den. Wie intuitiv außerdem zu erwarten war, benötigen N3 und N4 deutlich mehr
Aufwand zum Durchsuchen, als die übrigen Nachbarschaften. Sind es bei kleinen In-
stanzen noch je etwa 10% der Rechenzeiten, so steigt der Anteil für große Instanzen
auf 30–40% an.
</bodyText>
<subsectionHeader confidence="0.994979">
8.5 Laufzeit und Lösungsverbesserung
</subsectionHeader>
<bodyText confidence="0.9998703125">
Ein wesentlicher Aspekt des entwickelten Algorithmus ist das Auffinden von guten
Lösungen innerhalb möglichst kurzer Zeit, da im Echtbetrieb nicht uneingeschränkt
viel Zeit zur Verfügung stehen kann. Aus diesem Grund ist eine Visualisierung des
Verlaufs der Lösungsverbesserung durchaus interessant, was anhand von Instanz M3
bei Berechnung mit alternativen Lagerplätzen und dynamischer Nachbarschaftsrei-
henfolge in Abb. 8.1 dargestellt wird. Es ist dabei eindeutig zu erkennen, dass in-
nerhalb der ersten 100 Iterationen des VND bereits eine sehr gute Lösung erreicht
wird, welche im weiteren Verlauf zwar noch geringfügig verbessert wird, aber nicht
mehr in so hohem Maß wie zu Beginn. Es sollte darauf hingewiesen werden, dass die
Verbesserungen innerhalb der zweiten 100 Iterationen bei weitem nicht so gravierend
sind, da hier die veränderte Skalierung der y-Achse für die Tourlänge zwischen 0 und
50000 beachtet werden muss.
Dieses Verhalten ist äußerst günstig für die Verwendung im realen Umfeld, wo vor
allem schnelle Antwortzeiten von Bedeutung sind. In manchen Fällen wird es dort
nötig sein, schon nach kurzer Zeit den Algorithmus abzubrechen und die bis dahin
vorliegende Lösung zu verwenden.
</bodyText>
<subsectionHeader confidence="0.9336895">
8.6 Lösungsqualität bei Verwendung zusätzlicher
Nachbarschaften
</subsectionHeader>
<bodyText confidence="0.997623">
Um das Verhalten des Algorithmus bei der Verwendung zusätzlicher Nachbarschaften
beobachten zu können, wurde ein weiterer Testlauf durchgeführt, der unter den glei-
chen Voraussetzungen wie der in Kapitel 8.2 beschriebene durchgeführt wurde. Hier-
bei wurde allerdings nur mehr mit dynamischer Nachbarschaftsreihenfolge gerechnet,
es kamen aber weitere Nachbarschaften zum Einsatz. Verwendet wurden hier neben
Split, Merge, Shift, Swap, SwapPositionMerge, SplitPositionMerge und DoubleShift
auch ShiftSplit, SwapSplit, MultipleSwap, MultipleSplit und SplitMerge. Diese Auf-
listung entspricht wieder gleichzeitig der Anfangsreihenfolge der Nachbarschaften.
Weiters wurde SwapPosition ausgelassen, da diese bereits durch SwapPositionMerge
abgedeckt ist.
</bodyText>
<page confidence="0.910541">
60
</page>
<figure confidence="0.997333352941177">
Tourlänge gesamt
2000000
1800000
1600000
1400000
1200000
1000000
400000
200000
800000
600000
40000
20000
50000
30000
10000
0
8.6 Lösungsqualität bei Verwendung zusätzlicher Nachbarschaften
Tourlänge
Verbesserungen
200
40
20
80
60
0
180
160
140
120
100
Anzahl der Verbesserungen
0 100 200 300 400 500 600 700
Iterationen
</figure>
<reference confidence="0.696082666666667">
Abbildung 8.1: Verlauf der Zielfunktion im Vergleich zur Anzahl der gefundenen
Verbesserungen (Achtung: Unterschiedliche Skalierung der y-Achse für [0; 50000] und
(50000; 2000000])
</reference>
<page confidence="0.99383">
61
</page>
<sectionHeader confidence="0.984851" genericHeader="acknowledgments">
8 Testergebnisse
</sectionHeader>
<bodyText confidence="0.999975682926829">
In Tab. 8.2 und Tab. 8.3 sind die in diesem Test (Testlauf 2) erzielten Ergebnisse und
Laufzeiten des Algorithmus zu sehen. Diese Tabellen enthalten auch die Ergebnisse
aus Testlauf 1, was die Gegenüberstellung erleichtert. Es ist zu erkennen, dass von
allen berechneten 80 Instanzen nur 11 nicht besser gelöst werden konnten und die
Summe aller Zielfunktionswerte bei Instanzen ohne Umkehren innerhalb von Gängen
um rund 20% und bei Instanzen mit Umkehren sogar um etwa 22% verbessert wer-
den konnte. Gleichzeitig muss aber auch gesagt werden, dass die Berechnungen zum
Teil mehr als die doppelte Laufzeit bei kleineren Instanzen benötigten. Dennoch
konnten auch die Zielfunktionswerte großer Instanzen, deren Bearbeitung nach dem
Grenzwert von 1200 Sekunden abgebrochen wurde, in derselben Zeit wie im vorigen
Testlauf deutlich verbessert werden.
Die Auswertung der Effizienz der Nachbarschaften in Tab. 8.6 zeigt ein ähnliches Bild,
wie in Tab. 8.4. Zur besseren Übersicht wurden nur die Werte für Berechnungen mit
Umkehren innerhalb eines Ganges herangezogen. Zusätzlich ist hier ersichtlich, dass
die neu hinzugekommenen Nachbarschaften N9-N13 eine durchwegs hohe Verbesse-
rungsquote aufweisen.
Die Rechenzeiten aus Testlauf 2, wie in Tab. 8.5 zu sehen ist, weisen Parallelen zu den
in Testlauf 1 erhaltenen Werten auf. Im Wesentlichen bestätigt das Ergebnis die be-
reits zuvor ermittelten Zahlen, wobei es zu leichten Verschiebungen gekommen ist, da
die neu hinzugefügten Strukturen mit Kombinationen aus zuvor einzeln angewandten
arbeiten. Hier sind die Berechnungen für kombinierte und damit komplexere Struk-
turen natürlich auch aufwändiger, aufgrund des Erfolgs ist deren Anwendung aber
wünschenswert. Besonders auffällig ist der hohe Rechenaufwand für SplitMergeCom-
bine, wo im Vergleich dazu im vorangegangenen Testlauf DoubleShift den größten
Anteil an Rechenzeit benötigte.
Es hat sich also gezeigt, dass die neu eingebundenen Nachbarschaftsstrukturen ein
durchwegs positives Resultat bringen und die Lösung tatsächlich verbessern konnten.
Teilweise konnten die Zielfunktionswerte sogar um 50% verringert werden und nur in
wenigen Fällen wurden geringfügig schlechtere Ergebnisse erzielt, als beim vorherigen
Testlauf.
Abschließend ist zu den Testergebnissen zu sagen, dass durchwegs positive Resultate
erzielt werden konnten. Auch im Vergleich zur Lösung mittels S-Shape-Heuristik
konnten mehrheitlich bessere Werte berechnet werden. Zusätzlich dazu sollte noch
einmal darauf hingewiesen werden, dass unter der Verwendung der S-Shape-Heuristik
keine Nebenbedingungen, wie etwa Kollisionen zwischen Arbeitern, geprüft werden
konnten. Es wurde damit lediglich eine Referenzlösung erzeugt.
Es bleibt nun noch zu erwähnen, dass die hiermit geschilderten Beobachtungen darauf
schließen lassen, dass weitere Verbesserungen etwa in Zusammenhang mit Anpassun-
gen der Nachbarschaftsstrukturen durchaus möglich sind. In jedem Fall bietet sich
ein Einsatz im Echtbetrieb an, um die Leistungsfähigkeit des entwickelten Ansatzes
unter realen Bedingungen zu ermitteln.
</bodyText>
<page confidence="0.975941">
62
</page>
<reference confidence="0.954912222222222">
8.6 Lösungsqualität bei Verwendung zusätzlicher Nachbarschaften
Tabelle 8.6: Effizienz der Nachbarschaften in Testlauf 2 ohne bzw. mit Artikeln auf alternativen
Lagerplätzen - Durchschnittswerte über 20 Testläufe mit 25, 50, 100 und 200 einzusammelnden
Artikeln (Ar). Angeführt ist pro Nachbarschaft der prozentuelle Anteil (alle Werte in Prozent [%])
an erfolgreichen Schritten in Relation zu den insgesamt getesteten Schritten der jeweiligen Nachbar-
schaft. Getestet wurden die Instanzen (In) ohne bzw. mit Artikeln auf alternativen Lagerplätzen bei
Berechnung mit Umkehren innerhalb eines Ganges und bei dynamischer Nachbarschaftsreihenfol-
ge. (N1: Split; N2: Merge; N3: Shift; N4: Swap; N5: SwapPosition; N6: SwapPositionMerge; N7: SplitPositionMerge; N8: DoubleShift;
N9: ShiftSplit; N10: SwapSplit; N11: MultipleSwap; N12: MultipleSplit; N13: SplitMerge.)
</reference>
<table confidence="0.990258214285715">
Testlauf 2 / dynamische Reihenfolge / mit Umkehren
In Ar N1 N2 N3 N4 N6 N7 N8 N9 N10 N11 N12 N13
S1 25 22.4 26.4 63.7 79.5 - - 48.5 18.2 12.6 72.9 15.6 56.2
S2 25 21.3 28.3 67.5 73.7 - - 50.9 15.5 9.5 68.4 21.2 62.4
S3 25 95.2 14.0 65.0 79.7 - - 39.5 52.6 56.0 76.2 23.8 42.1
S4 25 86.2 15.1 62.2 75.3 - - 47.0 52.3 37.1 78.3 21.6 45.4
S5 25 27.1 27.4 63.9 69.5 - - 41.9 16.8 15.9 73.8 17.6 53.3
M1 50 100.0 0.7 71.4 95.6 - - 43.1 79.2 56.3 72.0 70.3 31.8
M2 50 100.0 0.6 79.1 94.9 - - 47.6 78.7 53.3 76.7 79.0 42.0
M3 50 100.0 1.5 77.8 93.7 - - 57.1 78.3 75.4 66.4 73.0 48.8
M4 50 100.0 0.3 75.4 94.3 - - 44.3 81.9 60.0 75.8 66.0 44.5
M5 50 100.0 0.2 77.4 94.6 - - 45.8 81.9 57.8 70.2 82.3 42.7
L1 100 100.0 2.3 89.7 95.9 - - 72.0 76.6 54.5 90.9 42.1 45.8
L2 100 100.0 3.5 95.5 97.5 - - 70.6 75.8 53.9 89.4 51.5 32.1
L3 100 100.0 0.1 94.3 96.6 - - 77.5 74.7 70.2 93.3 53.2 33.9
L4 100 100.0 0.1 95.1 96.9 - - 73.5 73.8 48.9 93.4 46.0 27.5
L5 100 100.0 1.1 95.8 96.3 - - 74.3 76.3 61.0 93.5 36.2 39.4
X1 200 100.0 4.2 99.1 100.0 - - 98.1 67.4 44.8 98.9 77.9 64.7
X2 200 100.0 4.2 99.2 99.3 - - 88.7 71.0 41.2 97.4 62.3 69.5
X3 200 100.0 2.1 99.2 99.9 - - 93.1 68.2 41.6 98.1 57.7 61.6
X4 200 100.0 6.3 99.3 99.4 - - 93.6 66.9 49.6 98.5 74.7 73.8
X5 200 100.0 2.1 99.0 100.0 - - 90.3 66.7 49.1 97.9 56.0 78.0
S1 25 18.3 26.4 58.7 73.7 34.7 0.0 50.6 13.6 9.5 74.4 9.8 62.7
S2 25 20.9 30.3 63.0 76.0 32.6 0.0 58.8 13.5 10.0 69.7 16.2 63.3
S3 25 95.4 13.3 62.7 79.4 0.0 0.0 38.6 63.5 54.7 75.6 18.3 42.4
S4 25 92.6 17.9 61.0 76.4 0.0 0.0 46.6 45.9 46.2 77.9 12.8 42.6
S5 25 27.7 31.0 63.4 72.5 46.5 0.0 46.3 15.6 12.9 75.0 18.6 58.7
M1 50 100.0 0.2 65.8 94.0 83.8 0.0 52.8 70.9 68.6 80.7 60.0 33.9
M2 50 100.0 0.4 80.5 94.3 0.0 0.0 44.1 78.6 66.7 76.5 70.2 33.7
M3 50 100.0 1.8 72.4 93.4 82.1 0.0 63.1 64.7 69.3 77.5 70.4 47.4
M4 50 100.0 1.0 70.0 94.9 81.4 0.0 55.8 71.2 69.5 78.5 49.4 39.8
M5 50 100.0 0.4 71.9 95.2 49.6 0.0 61.0 70.0 74.5 80.7 86.7 39.5
L1 100 100.0 0.2 89.5 97.7 91.2 0.0 90.6 73.4 58.1 94.4 39.6 38.3
L2 100 100.0 0.8 87.8 96.8 90.3 0.0 85.3 69.5 52.6 91.7 32.1 36.5
L3 100 100.0 0.0 92.1 93.4 94.0 0.0 72.8 76.3 63.8 95.8 50.0 47.7
L4 100 100.0 0.0 90.7 96.3 86.2 0.0 89.8 68.2 57.3 95.5 40.8 42.4
L5 100 100.0 0.0 88.4 96.5 77.2 0.0 87.1 67.9 50.1 95.0 43.3 33.7
X1 200 100.0 10.0 98.0 100.0 96.9 0.0 88.6 63.1 41.2 96.0 56.6 82.3
X2 200 97.5 2.7 99.1 99.4 94.3 0.0 94.8 62.6 42.1 91.2 56.9 66.1
X3 200 100.0 7.4 99.3 100.0 96.6 0.0 95.3 66.9 32.3 97.9 60.8 70.1
X4 200 100.0 0.0 98.1 100.0 78.2 0.0 97.3 63.6 43.6 98.3 47.7 73.2
X5 200 100.0 32.7 97.9 100.0 99.4 0.0 99.0 21.9 21.1 94.4 56.7 63.4
</table>
<page confidence="0.982986">
63
</page>
<figure confidence="0.7746125">
ohne alternative Lagerplätze
mit alternativen Lagerplätzen
</figure>
<page confidence="0.992908">
64
</page>
<sectionHeader confidence="0.998229" genericHeader="references">
9 Fazit
</sectionHeader>
<bodyText confidence="0.997881617647059">
Inhalt dieser Arbeit war die Vorstellung eines hybriden Verfahrens, welches zum
Lösen von Problemen der Tourenplanung im Echtbetrieb eines Ersatzteillagers ein-
gesetzt werden kann. Das Grundgerüst bildet dabei eine Variable Nachbarschafts-
suche mit integriertem Variable Neighborhood Descent (VND) als lokale Verbesse-
rungsstrategie. Zum Lösen von Teilproblemen innerhalb dieses Algorithmus wird ein
eigens entwickeltes Dynamisches Programm verwendet, mit dessen Hilfe es möglich
ist, konkrete Touren optimal in polynomieller Zeit abhängig von der Anzahl der be-
stellten Artikel zu berechnen. Um abschließend eine Zuweisung von Lagerarbeitern
zu den im vorhergehenden Schritt berechneten Touren zu berechnen, wird eine zweite
VNS verwendet.
Aus den präsentierten Ergebnissen der Tests lässt sich ableiten, dass der gefunde-
ne Ansatz prinzipiell funktionstüchtig ist und schnell akzeptable Lösungen erzeugt.
Sind die Arbeiter des Lagers erst einmal damit beschäftigt den ersten ihnen zuge-
wiesenen Artikel auszufassen, kann die Gesamtlösung weiter optimiert werden. Dies
ist möglich, da zu jedem Zeitpunkt eine gültige Lösung verfügbar ist. Von Bedeu-
tung ist dies eventuell auch, wenn eine Erweiterung des Verfahrens zu einem Online-
Algorithmus durchgeführt wird. Als solcher muss dieser auf laufend hinzukommende
und im Vorhinein nicht bekannte Bestellungen reagieren können. Die Adaptierung
von bereits ausgegebenen Touren würde in so einem Algorithmus einen wesentlichen
Beitrag zur Flexibilität liefern. Dadurch, dass viele der zu liefernden Artikel erst im
Laufe des Tages bestellt werden und zwischen den einzelnen Ausfassungsoperatio-
nen der Lagerarbeiter entsprechend viel Berechnungszeit zur Verfügung steht, wird
die kontinuierliche Verbesserung einer anfangs schnell generierten Lösung möglich.
Weiters scheint eine Aufteilung des Lagers in örtlich voneinander getrennte Berei-
che, basierend auf der Lage der Verpackungszone, sinnvoll, wodurch die Größe der
so entstehenden (Teil-)Instanzen entsprechend gering ist.
Obwohl die in dieser Arbeit präsentierten Testergebnisse implizieren, dass die Größe
der tatsächlichen Instanzen mit bis zu 5000 bestellten Artikeln pro Tag zu kom-
plex ist, kann man vermuten, dass nach weiterer ¨Uberarbeitung und Erweiterung der
Nachbarschaftsstrukturen oder Anpassungen der Durchsuchungsstrategie die Ergeb-
nisse weiter verbessert und selbst Instanzen von solcher Größe qualitativ hochwertig
gelöst werden können.
Leider war es im Rahmen dieser Arbeit nicht möglich, die Auswirkungen von unvor-
hergesehenen Vorkommnissen (ein Artikel ist nicht in gewünschter Menge verfügbar,
</bodyText>
<page confidence="0.99499">
65
</page>
<sectionHeader confidence="0.959626" genericHeader="acknowledgments">
9 Fazit
</sectionHeader>
<bodyText confidence="0.999974911764706">
Verspätung eines Arbeiters auf seiner Tour, etc.) aussagekräftig zu testen, da auf-
grund des erst neu eingeführten Verwaltungssystems die Testdaten nicht dem Echt-
betrieb entnommen werden konnten. Daher musste versucht werden, beim Gene-
rieren der Testdaten alle bekannten Aspekte und Eigenschaften der Lagerstruktur
bestmöglichst zu berücksichtigen.
Anzumerken ist noch, dass die Methode zum Berechnen von optimalen Kommis-
sionierungstouren teilweise auf der Annahme basiert, dass ein Mitarbeiter in einem
Gang jederzeit umdrehen kann. Je nach Beschaffenheit des Lagers und der verwen-
deten Fahrzeuge kann es durchaus vorkommen, dass eine solche Richtungsänderung
nicht, beziehungsweise nur schwer möglich ist. Sollte dies der Fall sein, kann das
Dynamische Programm einfach angepasst werden. Die grundlegende Struktur des
Ansatzes ändert sich dadurch nicht.
Im Rahmen der Tests hat sich gezeigt, dass die gefundenen Lösungen im Vergleich
zu ebenfalls berechneten Referenzlösungen von guter Qualität sind und zusätzlich
dazu alle Nebenbedingungen erfüllt werden konnten. Aber auch die Laufzeit des
Verfahrens und vor allem die raschen Verbesserungen zu Beginn eines Durchlaufs
vermitteln einen positiven Eindruck.
In Hinblick auf eine Beschleunigung des Algorithmus gäbe es die Möglichkeit auf
die Berechnung exakter Touren zu verzichten. Natürlich würde man in diesem Fall
zwar Geschwindigkeit gewinnen können, müßte aber bei der Lösungsqualität Einbu-
ßen hinnehmen. Auch ein nochmaliges Überarbeiten der Nachbarschaftsstrukturen
könnte die eine oder andere Verbesserung bringen. Es sollte aber erwähnt werden,
dass der präsentierte Ansatz bereits mit stabilem Verhalten und vielversprechender
Leistung überzeugen kann.
Als Fazit lässt sich sagen, dass der Einsatz eines computerunterstützten Entschei-
dungssystems zur Planung von Kommissionierungstouren durchaus sinnvoll scheint,
wenngleich aufgrund der Problemkomplexität auf eine besonders effiziente Imple-
mentierung geachtet werden muss. Besonders berücksichtigt werden muss dabei die
Tatsache, dass dies ein System sein soll, dass darauf abzielt Menschen in gewisser
Hinsicht Befehle zu erteilen, was einerseits soziale Schwierigkeiten mit sich bringt
und andererseits aber auch bedeutet, dass Zustände erreicht werden können, die im
Vorhinein nur schwer vorherzusehen sind. Das System sollte also nur als Entschei-
dungsunterstützung eingesetzt werden und kann die Kontrolle und Betreuung durch
einen qualifizierten Lagerarbeiter nicht ersetzen.
</bodyText>
<page confidence="0.885524">
66
</page>
<sectionHeader confidence="0.957839" genericHeader="references">
Literaturverzeichnis
</sectionHeader>
<reference confidence="0.999747620689655">
[1] D. L. Applegate, R. E. Bixby, V. Chvatal, and W. J. Cook. The Traveling
Salesman Problem: A Computational Study (Princeton Series in Applied Ma-
thematics). Princeton University Press, January 2007.
[2] C. Archetti, M. G. Speranza, and A. Hertz. A tabu search algorithm for the split
delivery vehicle routing problem. Transportation Science, 40(1):64–73, 2006.
[3] R. E. Bellman. Dynamic Programming. Dover Publications, Incorporated, 2003.
[4] R. de Koster, T. Le-Duc, and K. J. Roodbergen. Design and control of warehouse
order picking: A literature review. European Journal of Operational Research,
182(2):481–501, 2007.
[5] R. de Koster and E. Van Der Poort. Routing orderpickers in a warehouse: a com-
parison between optimal and heuristic solutions. IIE Transactions, 30(5):469–
480, 1998.
[6] E. W. Dijkstra. A note on two problems in connexion with graphs. Numerische
Mathematik, 1(1):269–271, Dezember 1959.
[7] M. Dror and P. Trudeau. Savings by split delivery routing. Transportation
Science, 23:141–145, 1989.
[8] M. Dror and P. Trudeau. Split delivery routing. Naval Research Logistics,
37:383–402, 1990.
[9] C. Feremans, M. Labbe, and G. Laporte. Generalized network design problems.
European Journal of Operational Research, 148(1):1–13, 2003.
[10] M. Fischetti, J. J. Salazar Gonzalez, and P. Toth. The symmetric generalized
traveling salesman polytope. Networks, 26(2):113–123, 1995.
[11] P. Hansen, N. Mladenovi´c, and L. C. D. Gerad. A tutorial on variable neigh-
borhood search. Technical report, Les Cahiers du GERAD, HEC Montreal and
GERAD, 2003.
[12] P. Hansen and N. Mladenovi´c. Variable neighborhood search. In F. W. Glover
and G. A. Kochenberger, editors, Handbook of Metaheuristics, pages 145–184.
Kluwer Academic Publisher, New York, 2003.
[13] S. C. Ho and D. Haugland. A tabu search heuristic for the vehicle routing
</reference>
<page confidence="0.751086">
67
</page>
<reference confidence="0.976866947368421">
LITERATURVERZEICHNIS
problem with time windows and split deliveries. Computers and Operations
Research, 31:1947–1964, 2004.
[14] B. Hu and G. R. Raidl. Variable neighborhood descent with self-adaptive
neighborhood-ordering. In C. Cotta, A. J. Fernandez, and J. E. Gallardo, editors,
Proceedings of the 7th EU/MEeting on Adaptive, Self-Adaptive, and Multi-Level
Metaheuristics, 2006.
[15] J. Lysgaard, A. N. Letchford, and R. W. Eglese. A new branch-and-cut algo-
rithm for the capacitated vehicle routing problem. Mathematical Programming,
100(2):423–445, 2004.
[16] N. Mladenovi´c. A variable neighborhood algorithm - a new metaheuristic for
combinatorial optimization. Abstracts of papers presented at Optimization Days,
page 112, 1995.
[17] T. Ralphs, L. Kopman, W. Pulleyblank, and L. T. Jr. On the capacitated vehicle
routing problem. Mathematical Programming Series, 94(B):1–19, 2003.
[18] P. Toth and D. Vigo. The Vehicle Routing Problem. Monographs on Discrete
Mathematics and Applications. SIAM, Philadelphia, 2002.
[19] K. Q. Zhu, K. C. Tan, and L. H. Lee. Heuristics for vehicle routing problem
with time. In Windows, 6th AI and Math, 2000.
</reference>
<page confidence="0.984523">
68
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.6740006">Ein hybrides Verfahren basierend Variabler Nachbarschaftssuche Dynamischer Programmierung Tourenfindung in einem Ersatzteillager domänenspezifischen Nebenbedingungen DIPLOMARBEIT zur Erlangung des akademischen Grades im Rahmen des Software Engineering &amp; Internet eingereicht von</title>
<author confidence="0.934968">Thomas Misar</author>
<address confidence="0.515758">Matrikelnummer 0025068</address>
<author confidence="0.627964">an der</author>
<affiliation confidence="0.513822">Fakultät für Informatik der Technischen Universität Wien</affiliation>
<address confidence="0.263837">Betreuung:</address>
<keyword confidence="0.453454">Betreuer: Univ.Prof. Dipl.-Ing. Dr. Günther Raidl Mitwirkung: Univ.Ass. Mag. Dipl.-Ing. Matthias Prandtstetter</keyword>
<address confidence="0.979705">Wien, 20.04.2009</address>
<affiliation confidence="0.5591005">(Unterschrift Verfasser) (Unterschrift Betreuer) Technische Universität Wien</affiliation>
<abstract confidence="0.981074307692308">A-1040 Wien Karlsplatz 13 Tel. +43/(0)1/58801-0 http://www.tuwien.ac.at ii Danksagung Die vorliegende Arbeit durfte ich am Institut für Computergraphik und Algorithmen der Technischen Universität Wien erstellen und es freut mich diese nun fertig in Händen halten zu können. Ich möchte mich für die Geduld und Mithilfe von Seiten Günther Raidls bedanken und ebenso Matthias Prandtstetter großen Dank für seine Betreuung aussprechen. In den vergangenen Monaten hat er einen besonders großen Beitrag zur Vervollständigung dieser Arbeit geleistet. Natürlich gilt meine Anerkennung auch allen anderen Personen, die von Seiten des Instituts ihren Anteil an der Entstehung dieser Arbeit hatten. Es ist mir weiters ein Anliegen auch all jene zu erwähnen, die mich im Laufe des gesamten Studiums begleitet und unterstützt haben. Dazu zählen vor allem meine Studienkollegen Christian und Gerhard, sowie gleichermaßen auch meine Eltern, die mir zu jedem Zeitpunkt eine große Hilfe waren und Linda, der ich an dieser Stelle für ihre Ausdauer und Motivation danken will. iii iv Erklärung zur Verfassung der Arbeit Hiermit erkläre ich, Thomas Misar, wohnhaft in 1070 Wien, Seidengasse 3/108, dass ich diese Arbeit selbständig verfasst habe, dass ich die verwendeten Quellen und Hilfsmittel vollständig angegeben habe und dass ich die Stellen der Arbeit (einschließlich Tabellen, Karten und Abbildungen), die anderen Werken oder dem Internet im Wortlaut oder dem Sinn nach entnommen sind, auf jeden Fall unter Angabe der Quelle als Entlehnung kenntlich gemacht habe.</abstract>
<address confidence="0.675725">Wien, 20.04.2009</address>
<abstract confidence="0.87612218446602">(Unterschrift Verfasser) v vi Kurzfassung Im Rahmen dieser Arbeit wird eine konkrete Problemstellung aus dem Bereich der Lagerverwaltung behandelt. Dabei soll die benötigte Zeit zum Ausfassen von Artikeln aus dem Lager unter Berücksichtigung von domänenspezifischen Nebenbedingungen minimiert werden. Ausgehend von durch Kunden laufend aufgegebenen Bestellungen sollen feste Lieferzeiten eingehalten werden und Einschränkungen wie etwa Kapazitätslimits oder das Vermeiden von Kollisionen zwischen Arbeitern beachtet werden. Die für die gegebene Problemstellung zentrale Bestimmung effizienter Touren steht im Mittelpunkt der Arbeit, welche mit Ergebnissen aus einer konkreten Implementierung des vorgestellten Ansatzes abschließt. wird ein Algorithmus vorgestellt, der ein eigens entwickeltes Pro- Berechnung optimaler Wege durch das Warenlager mit der Umsetzung Nachbarschaftssuche (engl.: Variable Neighborhood Search) verbindet. In mehreren Phasen werden dabei die vorliegenden Bestellungen zerlegt und davon ausgehend Touren gebildet, welche zuletzt auf alle verfügbaren Lagerarverteilt werden. Innerhalb der VNS kommt eine Variante des Neigh- Descent als lokale Verbesserungskomponente zum Einsatz. Während über die definierten Nachbarschaftsstrukturen unterschiedliche potentielle Lösungen erzeugt werden, erfolgt deren Bewertung durch die Berechnung von konkreten Touren mittels eines für diesen Zweck entwickelten Dynamischen Programms. Dabei werden spezielle Eigenschaften der zugrundeliegenden Lagerstruktur ausgenutzt, um so in polynomieller Zeit die bestmögliche Wegführung durch das Lager berechnen zu können. Für die Zuordnung von Arbeitern zu den auf diese Weise berechneten Touren wird schließlich eine zusätzliche VNS verwendet, deren Aufgabe es ist, die notwendigen Touren derart zu verteilen, dass der letzte Artikel zum frühest möglichen Zeitpunkt ausgefasst werden kann. Die anhand des implementierten Programms durchgeführten Tests zeigen, dass die erfolgte Tourenplanung wertvolle Ergebnisse liefert und die notwendige Rechenzeit niedrig gehalten werden kann. Getestet wurde mit Bezug auf eine Referenzlösung, welche auf Basis eines aus der Literatur entnommenen Ansatzes erzeugt werden konnte. Eine ausführliche Auswertung der Testergebnisse zeigte, dass die Anwendung des hier vorgestellten Ansatzes im Echtbetrieb als sehr vielversprechend gilt und erhebliche Einsparungen bezüglich der benötigten Arbeitszeit erreicht werden können. Insgesamt betrachtet wird ein effizientes und zielführendes Verfahren zur Lösung des vorliegenden Problems vorgestellt. vii viii Abstract Within this thesis a real-world problem related to a warehouse for spare parts is considered. Regarding several constraints typically stated by spare parts suppliers the time needed to collect articles should be minimized. Based on continuously arriving orders by customers predefined delivery times and capacity constraints have to be met. To accomplish this task efficient pickup tours need to be determined which is the main issue covered by this work which comes to an end with experimental results of a concrete implementation of the proposed approach. algorithm presented embeds a specifically developed program comoptimal walks through the warehouse into a general neighborhood scheme. Several stages are used for first splitting up all orders, then creating tours out of the results and finally assigning them to available workers. The uses a variant of the neighborhood descent as local improvement procedure. While the neighborhood structures defined are intended to produce candidate solutions, a dynamic program specially designed to compute optimal order picking tours is used to evaluate them. For this purpose properties specific to warehouses are exploited such to compute optimal routes within polynomial time. The final assignment of workers to tours is realized by another VNS. The task is then to find an allocation such that the last article to be picked up will be collected as early as possible. Evaluations of experimental results of a concrete implementation indicate that the presented approach provides valuable pickup plans and computation times can be kept low. Moreover the performed test runs have been compared to a reference solution which was computed based on an approach found in relevant literature. A detailed analysis of the obtained results showed that the application of the proposed approach to real-world instances is promising whereas the savings with respect to working time can be kept high. Overall an efficient as well as effective approach is introduced to solve this real-world problem. ix X Inhaltsverzeichnis 1 Einleitung 1 2 Verwandte Arbeiten 3 3 9 3.1 Vehicle Routing Problem 10 3.1.1 Capacitated Vehicle Routing Problem 10 3.1.2 Split Delivery Vehicle Routing Problem 11 3.1.3 Vehicle Routing Problem with Time Windows 11 3.2 Generalisierte Netzwerkprobleme 12 3.3 Traveling Salesman Problem 12 3.4 Bekannte Lösungsansätze 13 4 Dynamische Programmierung 15 5 Variable Nachbarschaftssuche 17 5.1 Lokale Suche und Shaking 18 5.2 Genereller Ansatz für die Variable Nachbarschaftssuche 20 6 Ein hybrides Verfahren 23 6.1 Der grundsätzliche Ablauf 23 6.2 Variable Nachbarschaftssuche und Dynamische Programmierung . . . 24 7 Der Algorithmus im Detail 27 7.1 Partitionierung vorhandener Bestellungen 27 7.2 Zuordnung von Artikeln zu Touren 27 7.2.1 Konstruktionsheuristiken 28 7.2.2 Reparaturund Verbesserungsheuristik 30 7.2.3 Durchsuchen der Nachbarschaften 35 7.2.4 Dynamische Reihenfolge der Nachbarschaften 36 7.3 Berechnung einzelner Touren 38 7.3.1 Repräsentation als Graph 38 7.3.2 Ein Dynamisches Programm 39 7.3.3 S-Shape-Heuristik 45 7.4 Zuordnung von Arbeitern zu Touren 46 7.4.1 Konstruktionsheuristik 47 xi Inhaltsverzeichnis</abstract>
<address confidence="0.876352857142857">7.4.2 Reparaturund Verbesserungsheuristik 48 7.5 Erweiterter Algorithmus 48 8 Testergebnisse 51 8.1 Wahl der Konstruktionsheuristik 51 8.2 Wahl von Berechnungsparametern 53 8.3 Effizienz einzelner Nachbarschaften 56 8.4 Rechenzeit der Nachbarschaften 57</address>
<abstract confidence="0.979987993421052">8.5 Laufzeit und Lösungsverbesserung 60 8.6 Lösungsqualität bei Verwendung zusätzlicher Nachbarschaften . . . 60 9 Fazit 65 Literaturverzeichnis 67 xii 1 Einleitung vorliegende Arbeit ist aus einer Zusammenarbeit des für Computergraund Algorithmen der Technischen Universität Wien der Firma welche sich mit Problemen der Lagerverwaltung auseinandersetzt und in diesem Fall Aufgaben innerhalb des Lagers eines Ersatzteillieferanten analysieren soll. Neben der Verwaltung sämtlicher Stammdaten und Auftragsdaten des Lagers gilt es, die tatsächliche Anordnung von Artikeln im Lager zu erfassen und davon ausgehend die benötigte Zeit zum Ausfassen von bestellten Artikeln (im Weiteren wird dieser Vorgang auch Kommissionierung genannt) zu minimieren. Dadurch müssen auch die Arbeitsschritte des Lagerpersonals berücksichtigt und im System abgebildet werden. Der Aufbau des Lagers gleicht im Wesentlichen dem, was man sich gemeinhin beim Gedanken an ein Warenlager vorstellt. Es sind parallel zueinander angeordnete Regale vorhanden, zwischen denen jeweils Gänge verlaufen, um entsprechend lagernde Artikel ausfassen zu können. An den beiden Enden jedes dieser Regalgänge verlaufen orthogonal dazu etwas breitere Hauptgänge (siehe dazu Abb. 1.1). Innerhalb dieses Gangsystems bewegen sich dann meist mehrere Arbeiter gleichzeitig, die unter Zuhilfenahme von Kommissionierungswagen diverse Artikel einsammeln. Welche Artikel benötigt werden, ergibt sich aus den jeweils vorliegenden Bestellungen, welche im Laufe des Arbeitstages durch Kunden in Auftrag gegeben werden. Da der Ersatzteillieferant gewisse Lieferzeiten einhalten will und muss, ist eine entsprechend effiziente Bearbeitung der Aufträge notwendig. Sobald die verlangten Artikel eingesammelt wurden, werden sie zu einer zentralen Stelle im Lager, der Verdichtungszone, gebracht, wo sie verpackt und für den Versand an die Kunden vorbereitet werden. Ohne Unterstützung durch ein entsprechendes System obliegt es nun dem Lagerleiter die vorhandenen Aufträge auf seine Mitarbeiter derart aufzuteilen, dass in möglichst kurzer Zeit die gewünschten Artikel in der Verdichtungszone bereitstehen. Die Reihenfolge, in der Artikel ausgefasst werden, ist nicht weiter vorgegeben und so entscheidet jeder Lagerarbeiter selbst über seinen Weg durch das Lager. Diese Wege oder Touren durch das Lager sind nun genau jener Teil innerhalb des gesamten Bestellablaufs, der großes Optimierungspotential bietet. Ziel der Arbeit ist es, das Ressourcenmanagement innerhalb des Lagers dahingehend zu optimieren, dass zunächst die Zusammenstellung von einzusammelnden Artikeln geschickt gewählt wird und damit im Weiteren das Erstellen von dafür kürzest mögli- Touren einen erheblichen Vorteil in der Planung des Ablaufs bringt. Ein wesent- 1 1 Einleitung Abbildung 1.1: Schematische Darstellung des Lagers licher Beitrag dazu ist ein von mir im Rahmen dieser Arbeit erstelltes Programm, das der Umsetzung sämtlicher Überlegungen innerhalb einer Heuristik dient. Dabei wird die vorhandene Problemstellung in vier algorithmischen Schritten bearbeitet. Es wird anhand bestimmter Kriterien, wie etwa Lieferzeit oder Platzbedarf eines Artikels, bestimmt, welche Artikel innerhalb einer Tour eines Arbeiters im Lager eingesammelt werden sollen. Der Schritt zur Berechnung von Touren ist dabei ein zentraler Bestandteil des Algorithmus und wurde mittels eines speziell entwickelten Dynamischen Programms umgesetzt. Sobald alle benötigten Touren berechnet wurden, können diese auf alle verfügbaren Lagermitarbeiter aufgeteilt werden, was im letzten Schritt erfolgt. Im Anschluss an die Beschreibung des Algorithmus kann man anhand der Testergebnisse sehen, dass die Effizienz des Programms einen durchwegs positiven Eindruck vermittelt. Große Probleminstanzen können zwar sehr lange Laufzeiten im Bereich von mehreren Stunden benötigen, bis der Algorithmus keine weitere Verbesserung bringt, allerdings werden schon innerhalb der ersten Minuten gute Lösungen erzeugt und somit bleibt der Einsatz in der Praxis vielversprechend. Zuerst werde ich nun eine detaillierte Problembeschreibung geben, die als Basis für meine Untersuchungen gedient hat. Im Anschluss daran möchte ich anhand von verwandten Arbeiten aus der Literatur einen Überblick über den Rahmen geben, in dem sich diese Arbeit bewegt. Ich werde im Weiteren beschreiben, aus welchen Teilen der letztlich verwendete Algorithmus aufgebaut ist und mit welchen Methoden der zuvor beschriebenen Arbeiten hierbei vorgegangen wird, wobei auch diese, wo sinnvoll und passend, im Detail behandelt werden. Im Zuge der Erläuterungen zum algorithmischen Verlauf, werde ich auch auf einige spezielle Probleme eingehen, die in diesem Zusammenhang zu lösen waren. Abschließend werden dann die Ergebnisse, die mit dem vorhandenen Programm erzielt werden konnten und aufgrund statistischer Auswertungen mehrerer Testläufe zustande gekommen sind, die Arbeit abschließen. Regal Regalgang Hauptgang VZ Verdichtungszone VZ 2 2 Problembeschreibung Die folgende Aufgabenstellung stammt in ihrer ursprünglichen Form von der Firma GmbH wurde in Zusammenarbeit mit Mitarbeitern des für und Algorithmen der Technischen Universität Wien um innerhalb eines gemeinsamen Projekts einen Lösungsansatz dafür zu entwerfen. Im Zuge der Reorganisation und Erweiterung des Lagers eines Ersatzteillieferanten soll eine automationstechnisch unterstützte Lagerverwaltung eingeführt und ausgebaut werden, die unter anderem die Möglichkeit bieten soll, einzelne Prozessabläufe im Lageralltag zu rationalisieren. Zu diesem Zweck wurden sämtliche Artikel beziehungsweise jene Ladungsträger, auf denen sich die Artikel befinden, mit maschinenlesbaren Kodierungen, konkret mit Barcodes, versehen und eine zentrale Lagerverwaltungssoftware eingeführt. Auf Basis einer im Hintergrund eingerichteten Datenbank erlaubt die grafische Oberfläche der Software die Erfassung und Verwaltung von Stammdaten und Bestelldaten sowie den Zugriff auf den aktuellen Lagerstand. In einer ersten Ausbaustufe soll vor allem die Zusammenstellung der einzelnen von Kunden in Auftrag gegebenen Bestellungen möglichst effizient realisiert werden, wobei folgende Schritte zu berücksichtigen sind: 1. Ein Kunde gibt eine Ersatzteillieferung in Auftrag. 2. Für jeden Auftrag fasst ein Lagerarbeiter die erforderliche Anzahl der bestellten Artikel aus dem Lager aus und bringt sie in eine so genannte Verdichtungszone. 3. Ein dieser Verdichtungszone zugeteilter Mitarbeiter packt alle zu den jeweiligen Bestellungen gehörenden Einzelteile in entsprechend dimensionierte Kisten, versieht diese mit Adresstickets und leitet sie an den Lieferanten (Paketdienst, Post, etc.) weiter. Während der erste und der dritte Punkt dieser Abarbeitungsreihenfolge derzeit schon verlässlich und ohne gröbere Verzögerungen ablaufen, stellt der zweite Punkt den Flaschenhals in der Zusammenstellung der Aufträge dar, da hierbei die Mitarbeiter große Strecken im Lager zurücklegen müssen, um alle Einzelteile einzusammeln. Da im Normalfall bis zu sechs Mitarbeiter gleichzeitig an bis zu 1000 täglichen Aufträgen bestehend aus je fünf unterschiedlichen Artikeln arbeiten, gibt es durch geschickte Aufteilung der Aufträge ein großes Einsparungspotential, sofern eine geschickte Einteilung von Artikeln zu Touren vorgenommen wird. Folgender neu gestalteter Ablauf soll daher realisiert werden: 3 2 Problembeschreibung 1. Mehrere Kunden geben (unabhängig voneinander) jeweils eine Ersatzteillieferung in Auftrag. 2. Alle derzeit im Lager tätigen Mitarbeiter bekommen jeweils eine Liste von Artikeln, die sie entlang einer vorberechneten Tour im Lager auf Kommissionierungswagen laden sollen. Diese Artikel können im Allgemeinen auch zu unterschiedlichen Aufträgen gehören. 3. Nach Abarbeitung dieser Liste stellt jeder Mitarbeiter den von ihm bedienten Kommissionierungswagen in der Verdichtungszone ab und entnimmt dort einen weiteren, allerdings leeren Kommissionierungswagen, um sich auf eine neue Tour zum Ausfassen weiterer Artikel zu machen. 4. Der Mitarbeiter in der Verdichtungszone verfährt weiterhin so, dass er alle Artikel eines Auftrags in entsprechende Schachteln verpackt und an den Botendienst übergibt. Dabei muss er allerdings beachten, dass nun die Artikel, die einer Bestellung zugeordnet sind, auf unterschiedlichen Kommissionierungswagen zwischengelagert sein können. Die Verdichtungszone selbst (siehe Abb. 2.1) ist in drei Zonen unterteilt, die als eine Art Zwischenlager verstanden werden können. Von dort holen die Lagermitarbeiter leere Kommissionierungswagen, um Artikel aus dem Lager auszufassen und stellen diese befüllt wieder dort ab. Mitarbeiter, die für Verpackung und Versand zuständig sind, können dann von dort die entsprechenden Waren abholen und die Bestellabwicklung fortsetzen. Da diese einzelnen Zonen entsprechend weitläufig sind, um genügend Platz zu bieten, ist vorgesehen, dass alle zu einer Bestellung gehörigen Artikel innerhalb derselben Zone abgeliefert werden sollen. Dies verringert den Zeitaufwand für die Verpackung und macht die Arbeit in der Verdichtungszone wesentlich einfacher und effizienter. Gegenstand dieser Arbeit ist nun die Entwicklung eines Lösungsansatzes, mit dessen Hilfe es möglich wird, die Aufteilung der Bestellungen auf unterschiedliche Mitarbeiter derart zu optimieren, dass die Touren der Kommissionierer möglichst kurz werden, wodurch gleichzeitig der zeitliche Abstand zweier Entnahmen einzelner Artikel aus dem Lager minimiert wird. Ausschlaggebend hierfür ist, dass durch diese Aufteilung der Bestellungen auf mehrere gleichzeitig im Lager arbeitende Personen bei entsprechender Optimierung große Einsparungen erreicht werden können, da für die Mitarbeiter besser organisierte Touren mit kürzeren Wegen möglich sind. Weiters soll erreicht werden, dass die jeweils zu einer gemeinsamen Bestellung gehörenden Artikel ungefähr zeitgleich in der Verdichtungszone bereitgestellt und im Weiteren verpackt werden, um mehrere Aufträge ohne den Einsatz größerer Zwischenlager gleichzeitig bearbeiten zu können. Neben dieser prinzipiellen Aufgabenstellung müssen jedoch noch mehrere Nebenbedingungen berücksichtigt werden, die einen entscheidenden Einfluss auf die tatsächliche Realisierung der einzelnen Kommissionierungstouren haben: 4</abstract>
<title confidence="0.988089064516129">Verdichtungszone W Stellplatz für Kommissionierungswagen W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W W Verpackung</title>
<author confidence="0.446966">Versand</author>
<abstract confidence="0.992112475862069">Abbildung 2.1: Schematische Darstellung der Verdichtungszone • Die Kommissionierungswagen können einerseits nur bis zu einer gewissen Kapazität beladen werden und andererseits ist es aufgrund ihrer Bauweise nur vorgesehen, dass sie sich in eine Richtung bewegen. Wegen des schmalen Gangsystems ist ein Umkehren innerhalb eines Ganges nicht ohne Weiteres möglich. • Die Überkreuzung zweier Kommissionierungstouren innerhalb eines Regalganges sollte möglichst vermieden werden, da aufgrund der Platzbeschränkung ein oder aneinander Vorbeifahren nicht möglich ist. • Manche Artikel können an mehreren Positionen im Lager verfügbar sein. Abhängig von der bestellten Menge müssen oder können dann unter Umständen auch mehrere solcher Lagerplätze für einen Artikel angefahren werden. • Einen weiteren Aspekt birgt die Tatsache, dass nicht alle an einem Tag zu bearbeitenden Bestellungen zu Arbeitsbeginn bereits bekannt sind, da noch im Laufe des Tages weitere Bestellungen eintreffen können. Dies entspricht sogar eher dem Normalfall, wodurch Anzahl und Struktur der zu bearbeitenden Aufträge im Laufe des Tages stark variieren. Ein Lösungsansatz soll das insofern berücksichtigen, als die Berechnungen jederzeit mit angepassten Eingabewerten wieder gestartet werden können sollen. Das heißt, es wird immer mit den aktuell offenen Bestellungen neu gerechnet. • Die Bearbeitung von Bestellungen sollte nach Möglichkeit in der Reihenfolge ihres Eintreffens geschehen, um die Lieferzeiten möglichst sicher einhalten zu können. 5 2 Problembeschreibung • Die zuvor beschriebene Einteilung der Verdichtungszone in drei Zonen muss derart berücksichtigt werden, dass von den Kommissionierern ausnahmslos alle zu einer Bestellung gehörigen Artikel in derselben dieser drei Zonen abgeliefert werden. Durch mobile Datenerfassungsgeräte soll der Optimierungsprozess unterstützt werden, da der Einsatz dieser Geräte es ermöglicht, die Entnahme eines Artikels beziehungsweise Abgabe eines Kommissionierungswagens in der Verdichtungszone in Echtzeit nachzuvollziehen. Dieses neue Lagerverwaltungssystem soll das derzeitige Verfahren ablösen, bei dem alle Entscheidungen durch Mitarbeiter getroffen werden. Unter Berücksichtigung dieser Einschränkungen gilt es nun vorrangig die Berechnung von kürzesten Touren für die Mitarbeiter zu behandeln. Mögliche Erweiterungen Die folgende Auflistung eröffnet mögliche Erweiterungen der gegebenen Problembeschreibung, wobei deren Umsetzung aufgrund von massivem Mehraufwand nicht erfolgte. Überdies beeinflussen diese Aspekte den Kern der Arbeit nicht, wodurch die zentralen Ergebnisse des vorgestellten Verfahrens ihre Aussagekraft behalten. Folgende Punkte sind als zusätzliche Funktionalitäten und Optionen denkbar: • Die im Lager verfügbaren Kommissionierungswagen haben durchaus unterschiedliche bauartliche Voraussetzungen, was sich auf damit verbundene Eigenschaften, wie Geschwindigkeit, Ladefläche oder Manövrierfähigkeit, auswirkt. Ein entwickelter Lösungsansatz dafür sollte dann genügend Flexibilität aufweisen, um damit umgehen zu können. Die Palette an Transportmitteln reicht dabei von ”einkaufswagenähnlichen“ Fahrzeugen bis hin zu Gabelstaplern. • Die eingeschränkte Bewegungsfreiheit aufgrund der sehr schmalen Gänge im Lager verhindert es, dass zwei Kommissionierungswagen aneinander vorbeifahren können. Um Kollisionen auszuschließen, wäre es denkbar einen Algorithmus zu entwerfen, der entsprechende Zustände verbietet. • Ein weiterer Punkt in Zusammenhang mit den im Lager verwendeten Fahrzeugen bezieht sich auf die Sicherheitsbestimmungen in Bezug auf Gabelstapler. Diese schreiben es prinzipiell vor, dass sich in einem Gang kein anderer Mitarbeiter gleichzeitig mit einem Gabelstapler aufhalten darf. Die Sperrung von solchen Gängen muss dann natürlich berücksichtigt werden. • Es kann der Fall auftreten, dass der Lagerleiter befindet, einen Lagerplatz mit einem anderen Artikel belegen zu wollen. In einem solchen Fall muss die Möglichkeit gegeben sein, dass der anderweitig benötigte Lagerplatz möglichst schnell (gleichzeitig aber kosteneffizient) leer geräumt wird. 6 • Weiters liegt durch das ständige Eintreffen von Bestellungen im Laufe eines Arder Anspruch an eine Das heißt, dass aktuell eintreffende Bestellungen jederzeit in den Optimierungsprozess aufgenommen werden können müssen. Im Unterschied zu einem kompletten Neustart der Berechnungen müssen in diesem Fall die bereits getätigten Optimierungen in den weiteren Verlauf des Programms einfließen. • Außerdem kann es vorkommen, dass während der Zusammenstellung der einzelnen Aufträge unvorhersehbare Vorkommnisse auftreten, auf die entsprechend reagiert werden muss. Artikel können beispielsweise fehlerhaft, kaputt oder gar nicht vorhanden sein. In einem solchen Fall muss der entsprechende Artikel von einer anderen Position im Lager entnommen werden oder möglicherweise sogar neu eingelagert werden. Wenn ein Lagerarbeiter mehr Zeit benötigt als angenommen, verzögert sich natürlich auch die Kommissionierung und entsprechende Änderungen müssen berücksichtigt werden • Eine zusätzliche Straffung der Nebenbedingungen ist durch die Garantie des Ersatzteillieferanten gegeben, fixe Lieferzeiten an seine Kunden einzuhalten. Diese sind auf alle Fälle einzuhalten. Es muss daher sichergestellt sein, dass jeder Auftrag bis zu einem vorgegebenen Termin verpackt ist, um verschickt werden zu können. 7 8 3 Verwandte Arbeiten Aus der detaillierten Problemspezifikation folgt unmittelbar, dass es sich bei dieser um ein mit dem Routing Problem [18] verwandtes Problem handelt, das zu den im klassischen VRP definierten Nebenbedingungen noch weitere domänenspezifische Einschränkungen enthält. Die ursprüngliche Variante des VRP verlangt, dass ausgehend von einem Depot Kunden mit unterschiedlichen Bestellungen beliefert werden müssen. Um den Transport des Ladeguts zu gewährleisten, steht eine Flotte von Lkws zur Verfügung. Gesucht ist eine Einteilung von Lkws zu Kunden, sodass die insgesamt zurückgelegte Wegstrecke der Lieferfahrzeuge minimiert wird. Auch Parallelen zu in der Literatur häufig auftretenden Varianten VRP können festgestellt werden. Zum Beispiel darf beim VRP nur eine gewisse Last transportieren, beim Delivery VRP hingegen alle Kunden von beliebig vielen Lkws angefahren werden. Es konnte allerdings keine Arbeit gefunden werden, die alle diese Varianten ineinander vereint und zusätzlich noch die bereits beschriebenen domänenspezifischen Nebenbedingungen, wie etwa die beschränkte Breite von Gängen, berücksichtigt. Neben der offensichtlichen Verwandtschaft mit Varianten des VRP, besteht auch eine zu Netzwerkproblemen So kann die Möglichkeit einen Artikel von unterschiedlichen Lagerplätzen zu holen als implizite Clusterbildung verstanden werden. Jeweils nur ein Knoten aus einem solchen Cluster soll besucht wer- Unter diesem Blickwinkel ist eine Verbindung zum Traveling Sales- Problem [10] offensichtlich, bei dem es gilt, jeweils einen Knoten pro Cluster auszuwählen und anschließend eine Tour zu berechnen, sodass jeder Cluster genau einmal besucht wird. Wie später genauer erklärt wird, basiert der hier vorgeschlagene Lösungsansatz auf Nachbarschaftssuche (engl.: Variable Neighborhood Search) [12] mit Neighborhood Descent Bei VNS/VND handelt es sich um Metaheuristiken, die auf der Idee aufbauen, dass ein globales Optimum stets ein lokales Optimum bezüglich aller möglichen Nachbarschaftsfunktionen ist. Unter einer Nachbarschaftsfunktion versteht man eine Rechenvorschrift, die es ermöglicht einer gegebenen Lösung neue Lösung zu berechnen, wobei sich in einigen (wenigen) Merkmalen unterscheiden. VND durchsucht systematisch eine Menge von gegebenen Nachbarschaften, um so zu einer möglichst guten Lösung gelangen. Weiters wird durch VNS ein so genannter angewendet, der dazu dient, festgefahrene Suchläufe durch das Einbringen von zufälligen Änderungen zu verbessern. 9 3 Verwandte Arbeiten Abbildung 3.1: Vehicle Routing Problem (VRP) 3.1 Vehicle Routing Problem klassischen Routing Problem handelt es sich um eine aus der Transportlogistik stammende Problemstellung, welche die Verteilung von Gütern ausgehend von einem Depot an Kunden mit unterschiedlichen Standorten beschreibt (siehe Abb. 3.1). Dabei fordert jeder Kunde eine gewisse Menge eines bestimmten Gutes an. Das angestrebte Ziel hierbei ist es, Routen in der Form zu erstellen, dass die Gesamtkosten zur Anlieferung aller Güter minimiert werden. Natürlich kann diese Formulierung auch entsprechend umgekehrt werden und so nicht Kunden beliefert werden, sondern gewisse Güter eingesammelt werden. In der Regel unterliegt die Routenerstellung gewissen Kriterien, wie etwa der Kapazität des jeweiligen Transoder zeitlichen Einschränkungen. Das VRP gehört in die Klasse der schweren Probleme. 3.1.1 Capacitated Vehicle Routing Problem Variante des VRP ist das Vehicle Routing Problem [17], welches die Kapazitäten der verwendeten Fahrzeuge einschränkt. Das in [17] beschrie- CVRP verlangt die Auslieferung eines einzigen Gutes an ausgehend einem Depot Verwendung von Transportmitteln mit identischer Kapazität wobei jedem Kunden ... , Menge wird. Aus kombinatorischer Sicht handelt es sich bei der Lösung um eine ... , wobei jede dieser Routen muss. klassischen, bereits VRP kommen also noch zusätzliche Einschränkungen hinzu, welche zu berücksichtigen sind. Das Problem wird dadurch allerdings nicht leichter.</abstract>
<note confidence="0.722978230769231">4 5 3 2 1 6 Depot 12 7 9 8 11 10 10</note>
<title confidence="0.369068">3.1 Vehicle Routing Problem 3.1.2 Split Delivery Vehicle Routing Problem Delivery Vehicle Routing Problem [2] beschreibt jene Form des</title>
<author confidence="0.608234">Wieder</author>
<abstract confidence="0.983503008948546">sind mehrere Lieferanten im Einsatz und jedes Transportmittel hat die gleiche Kapazität. Nun kann es allerdings vorkommen, dass die benötigte Menge eines Kunden die Kapazität eines einzelnen Transportmittels übersteigt oder aber auch einfach aus Effizienzgründen zwei Lieferanten einen Kunden mit Teillieferungen beliefern. Wie bereits bei Dror und Trudeau in [7] und [8] gezeigt, können durch die Aufteilung von Lieferungen beträchtliche Einsparungen erzielt werden, sowie auch die Anzahl Lieferanten reduziert werden. Dennoch bleibt das Problem an sich Die meisten Lösungsansätze gehen von der Annahme aus, dass die so genannte Dreiecksungleichung erfüllt ist. Geht man von der Kostenberechnung auf Basis von Wegstrecken aus, so bedeutet dies, dass der direkte Weg zwischen zwei Knoten immer der kostengünstigste ist. Formal lässt sich das ganz leicht durch mit j, k ... , wobei Anzahl an Kunden repräsentiert und die Kosten für den von Kunde Kunde Es wird dabei angenommen, dass Ein interessanter Aspekt der zuvor erwähnten Arbeiten [7] und [8] ist die Erkenntnis, dass es bei geltender Dreiecksungleichung eine optimale Lösung gibt, bei der je zwei Routen nie mehr als zwei gemeinsame Zielorte mit Teillieferungen anfahren. 3.1.3 Vehicle Routing Problem with Time Windows Eine weitere Variante des VRP behandelt jene Problemstellung, bei der die Kunden innerhalb eines definierten Zeitfensters beliefert werden müssen. Bei diesem Problem, Routing Problem with Time Windows [19], kann sich die Reihenfolge der zu beliefernden Kunden daher nicht ausschließlich aus den Routen mit kürzesten Wegen definieren, sondern wird zusätzlich von einer zeitlichen Bebeeinflusst. Auch dieses kombinatorische Problem ist und ist als Erweiterung des klassischen VRP eine sehr häufig vorkommende Problemstellung im Bereich der Logistik, wo es neben der Belieferung aller Kunden mit minimalen Kosten nun auch zu berücksichtigen gilt, dass jeder Kunde nur innerhalb eines beliefert werden kann, wobei früheste und späteste ist, zu dem Kunde werden kann. Da das Ziel die Minimierung des notwendigen Zeitaufwandes ist, muss die Dreiecksungleichung in konkreten Szenarien meist nicht erfüllt werden, da kürzere Strecken nicht gleichbedeutend mit kürzerem Zeitaufwand sind. Das heißt, dass den Zeitaufwand für die Strecke von Kunde Kunde in 11 3 Verwandte Arbeiten diesem Fall nicht zwingend gilt. 3.2 Generalisierte Netzwerkprobleme Klasse der man unter anderen das Spanning das Salesman Problem das Problem kürzester Wege. besteht die Aufgabe bei einem einen optimalen Graphen Einhaltung gewisser Randbedingungen zu fin- Wenn man nun von Netzwerkproblemen so werden dabei Knoten des Graphen Gruppen (engl.: Cluster) eingeteilt und die Randbedingungen auf dieser Basis formuliert. Hier kann dann beispielsweise ein minimaler über alle Cluster oder ein dazu auch Kapitel 3.3) für alle Cluster gesucht werden. ist bei einem Netzwerkproblem (un)gerichteter Graph bestehend aus einer Menge von Knoten ... , der Kantenmenge : j gegeben. = j dann jene von Kanten, die ihre Endpunkte in Je nachdem welche Randbedingungen definiert werden, entsteht ein entsprechendes konkretes Problem. 3.3 Traveling Salesman Problem sogenannten Salesman Problem [1] handelt es sich um ein weikombinatorisches Optimierungsproblem, das in der Klasse der gen Probleme enthalten ist. Das Ziel hierbei ist es, alle vorhandenen Orte innerhalb einer Rundreise, bei der also der Startort gleich dem Zielort ist, zu besuchen und dabei eine möglichst kurze Strecke zu finden. Um dieses Problem in ein mathematisches Modell zu bringen, bietet sich die Übersetzung in ein graphentheoretisches Problem an, wobei die Orte den Knoten und die Verbindungen der Orte den Kanten des Graphen entsprechen. Jede Kante besitzt eine bestimmte Länge, womit die mit ihrer Verwendung verbundenen Kosten definiert sind. Gesucht ist nun eine Tour, welche ein Kreis im Graphen ist, der jeden Knoten einmal enthält. Eine solche Tour wird auch Der Einfachheit halber wird für dieses Problem meist angenommen, dass der zugrunde liegende Graph vollständig ist, also je zwei Knoten durch eine Kante verbunden sind. Sollte der Graph nicht vollständig sein, kann man sich dadurch helfen, die fehlenden Kanten einzufügen und mit so hohen Kosten zu belasten, dass sie in einer minimalen Tour nicht vorkommen würden, es sei denn es wäre sonst keine Tour auffindbar. Allerdings ist dann zu beachten, dass möglicherweise unlösbare Instanzen durch diese Anpassung lösbar werden. Die Komplexität des Suchraumes unter 12 3.4 Bekannte Lösungsansätze der Anzahl Knoten im Graphen ist dabei in Traveling Salesman Problem behandelt die leicht abgeänderte Variante des eigentlichen Problems, welche alle zu besuchenden Orte in Gruppen einteilt und verlangt, dass genau ein Ort aus jeder Gruppe besucht werden muss. Welcher das ist, kann frei gewählt werden. Es sind dafür also zwei miteinander verknüpfte große Schritte notwendig, nämlich einerseits die Auswahl einer Teilmenge von Knoten des zugrunde liegenden Graphen, wobei aus jeder Gruppe von Orten jeweils genau einer in dieser Teilmenge enthalten ist und andererseits die Bestimmung einer Tour mit minimalen Kosten innerhalb des Teilgraphen, der aus den ausgewählten Knoten entstanden ist. 3.4 Bekannte Lösungsansätze Lösung des Routing Problem es einige Ansätze, die unter anderem Nachbarschaftssuche Hierbei wird der Einsatz solcher heuristischer Verfahren gewählt, da aufgrund der Problemstellung bereits für kleine Probleminstanzen eine Vielzahl an möglichen Lösungen existiert, gleichzeitig aber kein Algorithmus bekannt ist, der in polynomieller Zeit eine optimale Lösung konstruiert. [13] wird etwa beschrieben, wie mittels einer Lösung für ein SDVRP kombiniert mit einem VRPTW gesucht werden kann, für die die Anzahl der verwendeten Fahrzeuge sowie die Länge der insgesamt zurückgelegten Strecke minimiert werden. exakte Verfahren wie Lineare Optimierung (engl.: Integer Linear und &amp; Bound &amp; Cut häufig zur Lösung herangezogen. Ausgehend von einer ILP-Formulierung beschreibt [15] einen solchen Ansatz zur Lösung von CVRP-Instanzen mittels &amp; In Zusammenhang mit Warenlagern, deren Anordnung in klassischer rechteckiger Form vorliegt, ist auch das Aufsuchen von Touren ein interessantes Teilproblem im Zuge der Optimierung von Lagerabläufen. In [5] wird ein Verfahren, die sogenannte betrachtet, das der Erstellung solcher Touren dient. Dabei bewegen sich die Lagerarbeiter S-förmig durch das Lager, das heißt, dass ein Gang komplett durchquert wird, sobald er einmal betreten wurde. Interessant ist dieser Ansatz besonders deshalb, da er später für Vergleiche zu dem in dieser Arbeit vor- Verfahren herangezogen wird. Betrachtungen der sowie Varianten davon finden sich auch in [4], wo außerdem auf die Komplexität solcher Lagerabläufe hingewiesen wird und klar hervorgeht, dass entsprechende Probleme stets sehr speziell sind. Es gibt also kein Konzept und kein globales Optimierungsmodell für eine systematische Behandlung ähnlicher Situationen. 13 14 4 Dynamische Programmierung Unter dem Begriff der Dynamischen Programmierung versteht man ein algorithmisches Verfahren, bei dem in mehreren voneinander abhängigen Schritten Entscheidungen getroffen werden, die zur optimalen Lösung eines Problems führen. Dabei ist stets die Lösung eines Problems unter Ausnützung des Wissens über bereits gelöste Teilprobleme ein wesentlicher Bestandteil. Die in den einzelnen Berechnungsschritten zu lösenden Teilprobleme sind außerdem immer abhängig von den zuvor schon gelösten. Sobald zu einem Teilproblem eine Lösung berechnet wurde, wird diese mitprotokolliert, um für die spätere Verwendung abgerufen werden zu können und nicht wiederholt berechnet werden zu müssen. So arbeitet man sich schrittweise anhand optimaler Teillösungen zur Lösung des Gesamtproblems vor. Der Ansatz der Dynamischen Programmierung basiert auf folgendem ursprünglich von Bellman formulierten Postulat [3]: ”Ein optimales Verfahren hat die Eigenschaft, dass, wie auch immer der Anfangszustand und die erste Entscheidung ausfielen, die folgenden Entscheidungen für eine optimale Lösung sich auf den Zustand, der aus der ersten Entscheidung resultiert, beziehen müssen.“ Wesentlich dabei ist, dass alle Entscheidungen des Algorithmus von bereits zuvor getroffenen abhängen. Das bedeutet, dass die Lösung eines Teilproblems als Ausgangspunkt stets die Lösung eines vorangehenden Teilproblems heranziehen muss. Folgt man diesem Prinzip, dann versucht man das Problem derart zu zerlegen, dass jedes der entstehenden Teilprobleme optimal gelöst werden kann. Am Ende wird die optimale Lösung des initial formulierten Problems erreicht und kann durch die zuvor durchgeführten Schritte zusammengesetzt werden. Ein ähnlicher Ansatz, der ebenso das Zerlegen eines Problems in Teilprobleme verist &amp; Dieses Verfahren unterscheidet sich allerdings wesentlich von Dynamischer Programmierung, da hier per Definition keine Abhängigkeit zwischen den einzelnen Teilproblemen bestehen muss. Kürzeste Wege in einem Graphen Ein gutes Beispiel für Dynamische Programmierung bietet der Algorithmus für kür- Wege in einem Graphen, welcher 1959 von Dijkstra [6] vorgestellt wurde. Ge- 15 4 Dynamische Programmierung sei ein Graph bestehend aus einer Menge ... , und einer Menge Kanten. Weiters bezeichne eine Kante von deren Kosten. Der Algorithmus von Dijkstra berechnet in diesem Graph jeweils kürzesten Weg von einem Knoten allen anderen Knoten Anfangs wird für jeden Knoten im Graph dessen initial bekannte Distanz zum Anfangsknoten mit = 0 und = i Ausgehend vom ersten Knoten des Weges und beginnend mit diewird nun jeweils immer ein Knoten und alle direkten Nachfolger zur vorgemerkt, also ”markiert“. Dabei wird für jeden Knoten Distanz aktualisiert mit = + damit bestimmt, ob ein kürzerer Weg bis zum Knoten Wenn alle von dieser Form bearbeitet wurden, wird der näheste davon fixiert und dessen Nachfolger untersucht. Ein Knoten, der bereits fixiert wurde, wird nicht mehr aktualisiert. Durch dieses Vorgehen nähert man sich Schritt für Schritt dem Zielknoten. Sobald dieser fixiert wird, hat man das Ende erreicht und einen optimalen Weg gefunden. Die Rekonstruktion des Weges ist durch Rückverfolgung über die Gleichung + einfach möglich, womit sich natürlich auch mehrere mögliche kürzeste Wege ergeben können. Anhand dieses ursprünglich von Dijkstra vorgestellten Algorithmus ist es daher möglich, durch schrittweises Lösen voneinander abhängiger Teilprobleme in einem Graphen den kürzesten Weg zwischen zwei Knoten zu bestimmen, sofern dieser existiert. Die Dynamische Programmierung folgt also einer einfachen Strategie: 1. Aufteilung des Problems in kleinere, voneinander abhängige Probleme 2. Finden einer optimalen Lösung für die Teilprobleme 3. Kombinieren der optimalen Teillösungen zur Berechnung der optimalen Lösung für das Gesamtproblem Es sei hier nochmals auf den wesentlichen Aspekt der Abhängigkeit von Teilproblehingewiesen, welcher etwa bei &amp; Conquer Teil des Konzepts ist. 16 5 Variable Nachbarschaftssuche Nachbarschaftssuche ist eine vergleichsweise junge Metaheuristik, die ihren Ursprung um das Jahr 1995 hat, in dem sie erstmalig vorgestellt wurde (siehe [16] und [11]). Grundsätzlich kann ein Optimierungsproblem allgemein formuliert werden als X dabei den Lösungsraum, die Menge der gültigen Lösungen, konkrete Lösung und eine Funktion, die jeder Lösung reellen zuordnet. Meist ist eine explizite Durchsuchung von Basis von (vollständigen) Enumerationsverfahren nicht applikabel. Zudem sind viele der in Praxis relevanten Probleme was impliziert, dass die Existenz eines polynomiellen Algorithmus zur Lösung dieser Probleme höchst unwahrscheinlich ist. Daher kommen häufig (Meta-)Heuristiken zum Einsatz. VNS bietet dabei ein sehr einfach gehaltenes Verfahren mit vielen Ausbaumöglichkeiten und folgt dem einfachen Prinzip, bereits vorhandene Lösungen einer leichten Veränderung zu unterziehen, um somit neue, möglicherweise bessere, Lösungen zu erhalten. Um dabei systematisch vorgehen zu können, werden so genannte Nachbarschaften definiert, welche im Wesentlichen auf Rechenvorschriften basieren, wie eine vorhandene Lösung abzuändern ist, um neue, möglicherweise bessere, zu erreichen. ... , als endliche Menge vorgegebener Nachbarsowie als Menge der Lösungen der Nachbarschaft von Als globales Optimum wird jene Lösung bezeichnet, für die min X Ein lokales Minimum E Bezug auf gegeben, wenn es keine Lösung f gibt. Die Variable Nachbarschaftssuche beruht auf folgenden drei einfachen Tatsachen [12]: (i) Ein lokales Minimum bezüglich einer Nachbarschaftsstruktur ist nicht notwendigerweise auch ein lokales Minimum bezüglich einer anderen. (ii) Ein globales Minimum muss gleichzeitig ein lokales Minimum bezüglich aller Nachbarschaftsstrukturen sein. 17 5 Variable Nachbarschaftssuche Abbildung 5.1: Lokale Optima und globales Optimum im Verlauf der Zielfunktion (iii) Sehr viele Probleme bieten die Eigenschaft, dass lokale Optima nahe beieinander liegen. Der letzte Punkt basiert auf vorhandenen Erfahrungswerten und lässt in vielen Fällen Rückschlüsse von einem lokalen auf das globale Optimum zu. 5.1 Lokale Suche und Shaking Suche mittels Variable Neighborhood Descent lokaler Suche versteht man ein Verfahren, bei dem der Lösungsraum in einem begrenzten Bereich in der Umgebung einer gültigen Lösung durchsucht wird. Der zu durchsuchende Bereich wird durch die Nachbarschaft dieser Lösung vorgegeben. Das bedeutet, dass durch festgelegte Rechenvorschriften Adaptionen der Ausgangslösung vorgenommen werden und auf diesem Weg neue Lösungen erreicht werden. Um entscheiden zu können, ob eine Lösung besser oder schlechter ist, wird eine Bewertungsfunktion verwendet. In Abb. 5.1 ist der Verlauf einer möglichen Zielfunktion dargestellt, sowie die Posieiner Startlösung markiert, von welcher ausgehend innerhalb einer Nachalle Lösungen im Intervall oder innerhalb ei- Nachbarschaft Lösungen im Intervall erreichbar sind und die markierten lokalen Optima hierbei jeweils die besten Lösungen der Nachbarschaften darstellen. der konkreten Umsetzung der lokalen Suche durch den Neighborhood wird der Lösungsraum über alle Nachbarschaftsstrukturen determidurchsucht. Ausgangspunkt sind eine vorhandene Startlösung sowie die vorlokale Optima globales Optimum X 18 5.1 Lokale Suche und Shaking definierte Reihenfolge der verfügbaren Nachbarschaftsstrukturen. Beginnend bei der ersten Nachbarschaft der Startlösung wird nun nach einer besseren Lösung gesucht, um auf Basis dieser die Suche fortzusetzen. Die Reihenfolge in der die Nachbarschaften einer Lösung durchsucht werden hängt davon ab, ob Verbesserungen gefunden können oder nicht. Wird Nachbarschaft und konnte eine Vererzielt werden, so wird die Suche mit Nachbarschaft Kann Verbesserung erzielt werden, so kommt Nachbarschaft zum Einsatz. Der Algorithmus terminiert also erst, wenn keine weiteren Verbesserungen erzielt werden können. Auf diesem Weg werden alle Nachbarschaften durchsucht, wobei am Beginn der Kette üblicherweise jene Strukturen stehen, deren Definition ein schnelleres Durchsuchen erlaubt als bei später gereihten. In diesem Zusammenhang seien zwei Strategien erwähnt, anhand derer entschieden werden kann, wann das Durcheiner Nachbarschaft beendet werden soll. Wird Improvement die beste Lösung einer Nachbarschaft) gewählt, dann werden die Nachbarschaften, wie beschrieben, komplett durchsucht. Unter Verwendung von Improvement (für die nächst bessere Lösung einer Nachbarschaft) wird die Suche innerhalb einer Nachbarschaft abgebrochen, sobald eine bessere Lösung gefunden werden konnte. Der erste Eindruck mag vermitteln, dass es für die Lösungsverbesserung über alle Nachbarschaften besser wäre diese stets komplett zu durchsuchen. Tatsächlich ist es aber schwierig zu beurteilen welche Lösung für nachfolgende Nachbarschaften größe- Optimierungspotential bietet. Sicher jedoch kann behauptet werden, dass Laufzeit hat als sofern mindestens einmal abgebrochen werden kann, bevor eine Nachbarschaft komplett durchsucht wurde. In Alg. 1 ist der Ablauf von VND dargestellt. Natürlich ist zu beachten, dass sich abhängig von der Anzahl der definierten Nachbarschaftsstrukturen auch die Laufzeit verändert. Eine größere Anzahl an Nachbarschaftsstrukturen erhöht den notwendigen Zeitaufwand, steigert aber gleichzeitig auch die Chance eine bessere Lösung zu finden. zur lokalen Suche kann der Einsatz von zufälligen Komponenten positiven Einfluss auf die Effizienz eines Algorithmus haben. Dies kann durch einen genannten erreicht werden, also einem zufälligen ”Durchschütteln“, wodurch zufällige Veränderungen einer Lösung eine neue Lösung erzeugen. Angenommen alle vorhandenen Nachbarschaftsstrukturen alleine ermöglichen von der in Abb. 5.1 markierten Startlösung aus innerhalb des Inneue Lösungen zu finden, so würde dies bedeuten, dass die besten auffindbaren Lösungen die beiden gekennzeichneten lokalen Optima wären. Durch man allerdings erreichen, dass dieses Intervall verschoben wird und somit in einem neuen Bereich der Zielfunktion nach Optima gesucht werden kann, womit die Wahrscheinlichkeit steigt, das globale Optimum zu finden. der Suche es sich also um einen Prozess, der innerhalb eines definierten Teilbereichs des gesamten Lösungsraumes nach besseren Lösungen sucht. Die Definition von zu durchsuchenden Teilbereichen (Nachbarschaften) ist allerdings 19 5 Variable Nachbarschaftssuche 1 VND eine Startlösung für das Optimierungsproblem die beste gefundene (lokale) Lösung sei eine endliche Menge vorgegebener Nachbarschaftsstrukturen begin ; repeat nach bestem Nachbarn der Lösung der E ; f ; else 1 ; end abhängig von der aktuellen Lösung. Somit stellt sich natürlich stets die Frage, ob mit den zur Verfügung gestellten Nachbarschaften der gesamte Lösungsraum erreicht werden kann, beziehungsweise vor allem die optimale Lösung. Um nun auch möglicherweise nicht abgedeckte Bereiche des Lösungsraumes erreichen zu können, wird Erzeugt werden diese Veränderungen durch zufälliges Generieren von Lösungen aus einer der Nachbarschaften der aktuellen Lösung. 5.2 Genereller Ansatz für die Nachbarschaftssuche Aus der Kombination von lokaler Suche und Shaking lässt sich nun der generelle Ansatz für VNS aufbauen. Dabei wird die lokale Suche eingebettet in einen wiederkehrenden Ablauf von Shaking und der Entscheidung darüber, ob mit einer neuen und besseren Lösung fortgesetzt wird, oder keine Verbesserung innerhalb der lokalen Suche möglich war. Diese Vorgehensweise wird in Alg. 2 gezeigt. Es handelt sich hier um die Grundstruktur einer VNS, wobei die allgemein als lokale Suche bezeichnete Phase durch VND abgedeckt wird. Darüber hinaus bildet dieser Ablauf zugleich das Grundgerüst der in dieser Arbeit angewandten Nachbarschaftssuche. 20 5.2 Genereller Ansatz für die Variable Nachbarschaftssuche 2 Genereller VNS-Ansatz eine Startlösung für das Optimierungsproblem die beste gefundene Lösung sei eine endliche Menge vorgegebener Nachbarschaftsstrukturen begin ; repeat Shaking: Erzeuge eine zufällige Lösung aus der Nachbarschaft ∈ N ; // Führe lokale Suche mittels VND durch ; f ; ; else 1 ; end 21 22 6 Ein hybrides Verfahren Die vorliegende Problemstellung macht es unmöglich ein konstruktives Verfahren zu entwickeln, dass in polynomieller Zeit zur optimalen Lösung führt, weshalb eine Alternative gefunden werden muss. Die Herausforderung dabei stellen die Probleminstanzen dar, durch welche bei einer Größenordnung, die im Echtbetrieb vorstellbar wäre, die Anzahl der gültigen Lösungen sehr groß wird. Würde man alle möglichen Lösungen untersuchen wollen oder mit exakten Verfahren wie Branch &amp; Bound arbeiten, so würde dies zu nicht akzeptablen Rechenzeiten führen. Man kann davon ausgehen, dass es sich dabei um mehrere Stunden handeln würde, man im Echtbetrieb je nach Situation aber bei einer vertretbaren Zeitspanne im Bereich von Sekunden bis zu maximal wenigen Minuten liegen muss. Aus diesem Grund schien es sinnvoll zu sein, metaheuristische Verfahren in Kombination mit exakten Methoden zur Lösung von Teilaufgaben beziehungsweise zur Bewertung von konkreten Lösungen zu verwenden. Durch den Einsatz von VNS als Metaheuristik ist es möglich in kurzer Zeit sehr viele unterschiedliche Lösungen zu erzeugen. Dabei werden zunächst gewisse Parameter ermittelt, die eine konkrete Lösung definieren. Allerdings muss diese auch bewertet werden, um deren Güte bestimmen zu können. Dies geschieht mittels Dynamischer Programmierung in einem weiteren Schritt des Algorithmus, in welchem auf Basis der durch die VNS vorgegebenen Parameter einer Lösung eine passende konkrete Tour durch das Lager berechnet wird. 6.1 Der grundsätzliche Ablauf Der in dieser Arbeit entwickelte Algorithmus kann im Wesentlichen in vier Teilbereiche gegliedert werden, welche so lange wiederholt werden bis keine zu bearbeitenden Bestellungen mehr vorhanden sind: Partitionierung vorhandener Bestellungen erste Schritt soll aus allen vorhandenen Bestellungen jene auswählen, die im Weiteren bearbeitet werden. Dabei wird einerseits berücksichtigt welche Priorität eine Bestellung auf Basis ihres Liefertermins hat und andererseits welche Kapazitätsbeschränkungen in der Verdichtungszone vorherrschen. Es soll bereits durch diesen Schritt sichergestellt sein, dass Artikel aus einer Bestellung stets im selben Bereich der Verdichtungszone gelagert werden (siehe auch Kapitel 2). Berechnung von Artikelauswahlen einem zweiten Schritt werden dann 23 6 Ein hybrides Verfahren die einzusammelnden Artikel in so genannte Artikelauswahlen zerlegt. Das heißt es werden Listen von Artikeln erstellt, die dazu dienen, die innerhalb einer Tour abzuarbeitenden Artikel zu definieren. Dieser Schritt wird durch eine VNS abgedeckt, die viele verschiedene solcher Artikelauswahlen erzeugt, um später konkrete Touren daraus zu berechnen. Berechnung von Kommissionierungstouren bereits im vorangegangenen Schritt beschrieben, geht es hierbei um das Finden konkreter Touren durch das Lager. Für jede einzelne Artikelauswahl kann nun mittels eines Dynamischen Programms sehr schnell die optimale Tour in Bezug auf deren Länge berechnet werden. Die Summe der Längen aller Touren stellt dabei die Güte der gesamten Lösung in dieser Konstellation dar. Sobald dieser Schritt abgeschlossen ist, kann entschieden werden, ob das vorhandene Ergebnis an die Lagerarbeiter übergeben werden soll, oder nochmals zum vorigen Schritt zurückgegangen werden soll, um durch neue Artikelauswahlen ein möglicherweise besseres Gesamtergebnis erzielen zu können. Zuweisen der Touren zu Arbeitern letzten Schritt werden die vorhandenen Touren an die verfügbaren Lagerarbeiter vergeben. Hier wird wieder mittels einer weiteren VNS versucht eine möglichst optimale Aufteilung zu erreichen, damit die letzte Tour zum frühest möglichen Zeitpunkt beendet werden kann. Sollten nach diesem Schritt noch weitere Bestellungen im System vorhanden sein, beginnt einfach ein neuer kompletter Durchlauf des Algorithmus. Zur Veranschaulichung dieses Ablaufs dienen sowohl die schematische Darstellung in Abb. 6.1, als auch die Skizzierung durch Alg. 3. Dabei ist zu beachten, dass die Auswertung der Zielfunktion des ersten Schritts abhängig ist von den Berechnungen des zweiten Schritts, wodurch ein starkes Zusammenspiel dieser beiden Phasen gegeben ist. Das endgültige Ergebnis aller Berechnungen soll allen verfügbaren Arbeitern des Lagers Touren so zuweisen, dass der Endzeitpunkt aller Touren so früh wie möglich ist. 6.2 Variable Nachbarschaftssuche und Dynamische Programmierung Wie bereits erwähnt, handelt es sich bei dem Algorithmus um einen hybriden Ansatz, bestehend aus VNS und Dynamischer Programmierung. Dabei wird der durchsuchte Lösungsraum über die zuvor angesprochene Einteilung in Artikelauswahlen definiert und dieser Schritt des Algorithmus auf Basis von VNS durchgeführt. Ausgehend von einer ersten Auswahl werden also alle weiteren auf bessere Zielfunktionswerte hin untersuchten Artikelzusammenstellungen durch stete leichte Abänderungen, definiert durch das System an Nachbarschaften, generiert. Hierbei kann eine geringfügige Veränderung einer Artikelzusammenstellung gleichzeitig große Auswirkungen auf die 24 6.2 Variable Nachbarschaftssuche und Dynamische Programmierung Abbildung 6.1: Schematische Darstellung des grundsätzlichen Ablaufs Berechnung von Artikelauswahlen Bestellungen durch Kunden ! Berechnung von Kommissionierungstouren Partitionierung vorhandener Bestellungen Zuweisen der Touren zu Arbeitern 3 Grundsätzlicher Algorithmus Bestellungen mit Listen aller einzusammelnder Artikel Eine Zuordnung von Arbeitern zu fertigen Touren begin repeat Erstelle Partitionierung vorhandener Bestellungen ; repeat Berechne Zuordnung von Artikeln zu Touren ; Berechne optimale Touren für die oben erstellte Zuordnung ; Verbesserung konnte erzielt werden eine Zuordnung von Touren zu Arbeitern Zuordnung von Touren zu Arbeitern weiteren Bestellungen sind abzuarbeiten end 25 6 Ein hybrides Verfahren dadurch erhaltene Lösung haben. Das bedeutet, dass eine schlechte Lösung durch kleine Adaptionen schnell zu einer sehr guten Lösung werden kann. Da dies alleine noch nicht ausreicht um die notwendigen Kommissionierungstouren bereitzustellen, ist als weiterer Bestandteil die Berechnung von optimalen Touren notwendig. Zu diesem Zweck schien es aufgrund der eingrenzbaren Möglichkeiten für einzelne Wegstrecken innerhalb des Lagers sinnvoll, mittels Dynamischer Programmierung nach einer Lösung zu suchen. Dabei werden für Auswahlen von zu besuchenden Lagergängen optimale Teiltouren berechnet, auf deren Basis die kürzeste Gesamttour erstellt werden kann. 26 7 Der Algorithmus im Detail Die in Kapitel 6 beschriebene Struktur des in dieser Arbeit entwickelten Verfahrens verlangt nun noch nach einer konkretisierten Beschreibung. In diesem Kapitel möchte ich nun die genaue Funktionsweise des Algorithmus vorstellen und im Detail auf die zuvor vorgestellten einzelnen Schritte eingehen. 7.1 Partitionierung vorhandener Bestellungen Wie bereits erwähnt wurde, handelt es sich bei diesem Teil des Ablaufs um eine erste Auswahl aus den vorhandenen Bestellungen. Es gibt also sozusagen einen Container, der mit Bestellungen von Seiten der Kunden befüllt wird. Aus diesem werden dann jeweils die nächsten zu bearbeitenden ausgesucht und an die folgenden Phasen übergeben. Um die Anforderungen an die möglichst kurz zu haltenden Lieferzeiten einhalten zu können, werden die verfügbaren Bestellungen nach deren Lieferdatum geordnet. Zusätzlich wird berücksichtigt, dass Artikel einer Bestellung im selben Bereich der Verdichtungszone abgelegt werden müssen und die damit verbundenen Kapazitätsbeschränkungen einzuhalten sind. Die Auswahl wird daher so getroffen, dass eine Partitionierung in ihrer Gesamtheit einen einzigen Bereich der Verdichtungszone erreicht. Es ist natürlich ersichtlich, dass es sich bei dieser Vorgehensweise nur um einen möglichen Ansatz handelt, mit diesen Randbedingungen beziehungsweise mit im Verlauf des Arbeitstages eintreffenden Bestellungen umzugehen. Es wird hierbei kein Anspruch auf Optimalität des Verfahrens gestellt, alle Nebenbedingungen werden dabei allerdings erfüllt. 7.2 Zuordnung von Artikeln zu Touren Obwohl dieser Schritt des Algorithmus hauptsächlich die Entscheidung trifft welche der bestellten Artikel innerhalb einer Tour eingesammelt werden sollen, erfolgt die Bewertung dessen auf Basis der Länge von konkreten Touren und das macht bereits hier die Berücksichtigung mehrerer Einschränkungen notwendig. So auch bei Artikeln mit mehreren Lagerplätzen. Hier muss entschieden werden welche Menge von welchem Platz abgeholt werden soll, wobei natürlich auch die Kapazität der Kommissionierungswagen nicht überschritten werden darf. 27 7 Der Algorithmus im Detail Lösung die Zuordnung von Artikeln zu Touren muss also mehrere Inforbeinhalten, welche über die Menge Zuordnungen von Artikeln zu Touren bestimmt sind. Das ist zunächst die Information, welche Mengen jeden Artikel A sind, wobei Menge der Artikel bezeichund gleich der Anzahl an unterschiedlichen Lagerplätzen den Artikel kann. Weiters wird definiert von welchen Lagerplätzen entnommen werden sollen, wobei Menge der Lagerplätze beschreibt. Die sich daraus ergebende Anzahl an Touren, um alle Artikel einzusammeln, soll mit werden. Dies wiederum lässt folgende formale Definition zu: i=1 ... , (7.2) ... , ... , (7.3) sei als ein konkreter Weg durch das Lager, auf welchem die Lagerplätze besucht werden. Die Menge T i=1 dann die Menge aller Touren 7.2.1 Konstruktionsheuristiken Aufgrund der Tatsache, dass der Algorithmus ausgehend von einer Startlösung viele unterschiedliche Lösungen erzeugen und untersuchen soll, ist es notwendig einen schnellen Startpunkt zu generieren, was mittels Initialisierung per Konstruktionsheuristiken geschieht. Ausgehend davon kann dann in der Folge die vorhandene Lösung weiter verbessert werden. Da die Anzahl der gegebenen und zu erfüllenden Nebenbedingungen groß ist, bot sich die Entwicklung zweier unterschiedlicher Konstruktionsheuristiken an, von denen beide jeweils unterschiedliche Mengen von Einschränkungen abdecken. erste dieser Heuristiken, die so genannte Avoiding Heuristic auf der Idee auf eine Menge von Touren erzeugen zu können, die nicht über- 28 7.2 Zuordnung von Artikeln zu Touren 4 CollisionAvoidingHeuristic eine Liste bestellter Artikel; Anzahl der Zonen m eine Menge von Mengen bestehend aus einzusammelnden Artikeln innerhalb von m Touren Menge Mengen mit i = 1 ... m, von einzusammelnden Artikeln begin S ∅ alle in Zone Artikel zu ; end lappen. Es sollen dabei also keine Kreuzungen auftreten, sodass Arbeiter auf ihrem Weg durch das Lager nicht kollidieren. Um das zu erreichen, wird das Lager in m nicht überlappende Zonen mit i = 1, ... , m, eingeteilt. Nun wird für solche Zone Tour um alle Artikel einzusammeln, welche Zone sind. Der Parameter m kann nach Belieben gewählt werden, es bietet sich aber durchaus an ihn mit der Anzahl der verfügbaren Lagerarbeiter zu initialisieren. Der Ablauf dieser Heuristik wird in Alg. 4 skizziert. zweite Konstruktionsheuristik, Saving Heuristic genannt, versucht anhand der streng einzuhaltenden Liefertermine entsprechende Zuordnungen zu finden. Erreicht wird dies hierbei, indem zunächst eine Reihung der Bestellungen nach deren spätest möglichen Lieferzeitpunkten erstellt wird, um anschließend mittels Verfahrens Touren mit i = 1, ... , m, zu berechnen, sodass die ersten und auszuliefernden Artikel in Tour werden. Erst wenn die Kapazität des ersten Kommissionierungswagens nicht mehr ausreichen sollte, eine zweite Tour weitere Artikel erzeugt. Analog dazu entstehen eventubenötigte weitere Touren ... , Der Pseudo-Code für diesen Ablauf wird in Alg. 5 gezeigt. Es ist offensichtlich, dass diese beiden Heuristiken alleine noch nicht ausreichen, um zulässige Lösungen des Problems zu produzieren. Bei CAH kann nicht zugesichert werden, dass etwa Lieferzeiten eingehalten werden und darüber hinaus werden die Kapazitäten der Kommissionierungswagen nicht beachtet. Andererseits kann bei TSH nicht garantiert werden, dass die Touren nicht überlappen. Daher kann nur dann mit diesen Methoden gearbeitet werden, wenn zusätzlich Reparaturalgorithmen zum Einsatz kommen. Trotzdem soll angenommen werden, dass die vorerst gefundenen als durchaus akzeptabel sind, etwa wenn das System im Betrieb morgens gestartet wird. Der Hintergedanke dabei ist, dass für jeden einzelnen Mitarbeiter zunächst nur die Information über den nächsten zu holenden Artikel von ist. Alle weiteren Artikel können bestimmt werden während der Mitar- 29 7 Der Algorithmus im Detail 5 TimeSavingHeuristic eine Liste Artikel eine Menge von Mengen bestehend aus einzusammelnden Artikeln von Menge Mengen mit 1 von einzusammelnden durch diesen Algorithmus bestimmt begin die Elemente in dem spätesten Lieferdatum; &amp;lt;-- 0 ; 0 passt nicht in &amp;lt;-- S u 1 ; 0 ; &amp;lt;-- S u end beiter mit den ersten Artikeln beschäftigt ist. Damit hat das System Zeit, um weitere Rechenschritte durchzuführen und verbesserte Lösungen für die übrigen Routen zu finden. Artikel, die bereits eingesammelt wurden, müssen fix in den jeweiligen Touren eingeplant bleiben und nur nachfolgende Artikel sind in der Reihenfolge der Abholung noch variabel. wenn die Lösung gefunden von CAH oder TSH, gültig ist, heißt das noch dass deren Güte im Speziellen also die Länge aller dadurch errechneten Touren insgesamt, die bestmögliche ist. Generell kann man aber davon ausgehen, dass dermaßen erzeugte Lösungen relativ schlechte Bewertungen haben werden. Der Grund dafür sind die Bestrafungen, die durch ein Überfüllen von Kommissionierungswagen entstehen. Sobald die Kapazitätsgrenze eines solchen erreicht wird, bestraft der Algorithmus dies so stark, dass es auf alle Fälle eine günstigere Lösung ist einen zusätzlichen Wagen zu verwenden. Es wird also unerlässlich sein mit Verbesserungsheuristiken weiterzuarbeiten. 7.2.2 Reparaturund Verbesserungsheuristik Bestandteil des Programms ist die Umsetzung einer Nachbar- [12] mit Verwendung des Neighborhood Descent lokale Verbesserungskomponente, welche sowohl als Reparaturals auch als Ver- 30 7.2 Zuordnung von Artikeln zu Touren besserungsheuristik eingesetzt werden kann. Zur Reparatur ist das Verfahren einsetzbar, weil durch hohe Bestrafung von ungültigen Lösungen stets eine bessere, also kostengünstigere und gleichzeitig vor allem gültige Lösung gefunden werden kann. Wesentlich hierbei ist die Veränderung der Artikelauswahlen, die in weiterer Folge erst die Tourberechnung beeinflusst. Die nachfolgende Auflistung bezieht sich also stets auf eine Adaptierung von Artikelauswahlen. Folgend den bereits in Kapitel 5 dargelegten Erläuterungen, kommen die anschließend vorgestellten Nachbarschaftsstrukturen zum Einsatz. Da diese Strukturen auf Basis grundlegenden werden, folgt zuvor eine Auflistung eben dieser: j, k, Schritt tauscht die Artikel mit 1 &amp;lt; j Das bedeutet, dass nach Anwendung dieses Artikel Tour und Artikel wurde. Analog Artikel Tour und Artikel j, dieser Schritt durchgeführt, so bedeutet dies, dass Artikel und in wird, wobei 1 j diesem Schritt werden zwei Touren einer neuen zusammengeführt. Es werden also all jene Artikel, die zuvor von wurden, von einer neuen Tour bearbeitet, wodurch der Menge werden können und stattdessen in wird. Es vermindert sich dadurch also die Anzahl der Touren um eins. Anwendung dieses Schrittes bringt die Tour einer Aufteiin zwei neue Touren indem alle in Artikel von verschoben werden. muss dann natürlich zu werden und somit erhöht sich die Gesamtzahl an Touren um eins. betrachtet hat man hier Möglichkeiten die ursprüngliche Tour zu wenn die Anzahl an Elementen in wird, also Die Zerlegungen berechnen sich dann aus der Potenzmenge von nämlich beziehungsweise ergibt das verschiedene Möglichkeiten. k, Move nützt die Tatsache aus, dass Artikel an mehr als nur einer Position im Lager verfügbar sein können. Sollte an einer weiteren Position im Lager ein bestimmter Artikel in der benötigten Menge vorhanden sein, so kann die Position vertauscht werden. Es wird dann der Ort Artikels den neuen Ort Um den Ablauf hierbei einzu halten, wird der Artikel aus der Tour und eine neue Tour gebildet, die zunächst nur diesen einen Artikel der neuen Lagerplatzenthält. Durch die spätere Anwendung eines diese Tour mit einer anderen wieder zusammengelegt werden. k, l, Schritt ermöglicht es in etwas anderer Form als den beiden bisherigen Varianten einen Artikel von anderer Stelle einzusam- 31 7 Der Algorithmus im Detail meln. Es ist generell natürlich nicht nur möglich die komplette Menge eines angeforderten Artikels von einem anderen Lagerplatz zu holen, sondern bei Bedarf auch nur eine Teilmenge davon. Diese Tatsache erlaubt die Definitieines Moves, durch den aus der Tour bestimmte Teilmenge Artikel einer zusätzlichen Position Lager innerhalb einer neuen eingesammelt wird und gleichzeitig eine bleibende Restmenge von der ursprünglichen Position zu holen bleibt. Aus diesen grundlegenden Moves werden nun folgende Nachbarschaftsstrukturen dewobei Menge an Selektionen (Touren) bezeichnet, die maximale vorkommende) Anzahl an Artikeln einer Tour angibt und für die maximale (größte vorkommende) Anzahl an alternativen Lagerplätzen eines Artikels aus dem Lager steht: für diese Nachbarschaftsstruktur ist der zuvor eingeführte Swap- Ausgehend von einer konkreten Lösung sind dadurch alle Lösungen defiwelche mittels eines sind. Sollen also Artikel zwischen je zwei Touren vertauscht werden, so liegt die Anzahl an Möglichkeiten in · Nachbarschaftsstruktur basiert auf dem somit kann die an möglichen Alternativen zu einer konkreten Lösung mit · abgeschätzt werden. diese Struktur leitet sich aus nur einem Move ab, nämlich dem Merge- Hier kommt man für eine Lösung auf mögliche neue Lösungen. In dieser Nachbarschaftsstruktur sind alle Lösungen enthalten, die aus einer ge- Lösung durch Anwendung eines werden können. der Anwendung hat es sich bewährt bei dieser auf dem basierenden Nachbarschaftsstruktur beim Durchsuchen auf eine komplette Abdeckung verzichten. Die insgesamt möglichen Adaptierungen können mit abgeschätzt werden. Tatsächlich werden nur jene Fälle berücksichtigt, bei denen die Anzahl an Artikeln in einer Tour auf die Hälfte reduziert werden. Bei einer geraden Anzahl an Artikeln kann genau in die Hälfte geteilt werden, bei ungerader Anzahl entsteht dementsprechend eine Tour mit einem Artikel mehr als der anderen. Somit bleibt ein stark verminderter Umfang von · übrig. Nachbarschaftsstruktur stützt sich auf den vorgestellten Swapumfasst daher eine geschätzte Anzahl von · möglicher Nachbarlösungen zu einer konkreten Lösung. handelt es sich um eine Struktur, die ähnlich wie Swapist. Allerdings wird versucht eine jeweils durch einen Swapentstehende Tour mit den übrigen verfügbaren Touren zu Es kommt hierbei zur Kombination mit einem Da- 32 7.2 Zuordnung von Artikeln zu Touren entsteht eine Größe des in Frage kommenden Lösungsraumes von für diese Nachbarschaftsstruktur bilden der Splitder welche nacheinander angewendet werden. Konkret wird versucht etwa die Hälfte der angeforderten Menge eines Artikels von einem alternativen Lagerplatz zu holen. Dabei entstehen für eine Lösung · beschränkte weitere gültige Lösungen. Die nun aufgelisteten Nachbarschaftsstrukturen sind im Wesentlichen aus mehreren (deren Anzahl wird im Folgenden mit zusammengesetzt und benötigen daher weit mehr Rechenzeit, um durchsucht zu werden. Um dem entgegenzuwirken, wurde der durchsuchte Bereich teilweise eingeschränkt beziehungsweise mit einer vorgegebenen Anzahl an zufällig erzeugten Lösungen innerhalb der Strukturen gearbeitet. Daher gibt es in solchen Fällen deutliche Unterschiede zwischen dem theoretischen und dem praktisch durchsuchten Nachbarschaftsbereich einer Lösung. Der Vorteil bei der Kombination von mehreren Moves ist, dass schlechtere Lösungen vorerst beibehalten werden können und erst nachdem alle definierten Moves durchgeführt wurden eine Bewertung erfolgt. Weiters ist auch zu beachten, dass die einzelnen dabei verwendeten Moves in keiner Abhängigkeit zueinander stehen müssen, nur Überschneidungen müssen beachtet werden. Es kann ein Artikel beispielsweise nicht zweimal hintereinander aus einer Tour genommen werden. Die Strukturen sind also wie folgt definiert: wird einfach die Anwendung von gereiht und somit zweimal verschoben, um eine neue Lösung zu erzeugen. Die Menge an möglichen Lösungen hat dabei eine Mächtigkeit in der Größenordnung von · Durch die zufällige Generierung von entsprechenden Moves und einer fix vorgegebenen Anzahl an Versuchen ergibt sich eine Laufzeitkomplevon Dieser markante Unterschied entsteht hier, da entschieden wurde jeweils 1000 zufällig generierte Lösungen zu testen, um die Komplexität der Nachbarschaftsstruktur zu umgehen. Das komplette Durchsuchen dieser, wie auch einiger der folgenden Nachbarschaftsstrukturen würde zu lange dauern. Es schien durchaus vertretbar an dieser Stelle mit einer Zufallskomponente zu arbeiten. wie beim zuvor beschriebenen ist auch hier Aneinanderreihung von Elementen aus der Definition, allerdings ist die Anzahl an Verschiebungen hier frei definierbar. Dementsprechend definiert sich die Größenordnung der möglichen Lösungen hier als · die Laufzeit liegt aber auch hier wieder in (siehe auch handelt es sich um die Kombination mehrerer welche in ihrer Gesamtheit dann zu mehrfachen Vertauschungen von Artikeln 33 7 Der Algorithmus im Detail innerhalb einer gesamten Veränderung führen. Ein Lösungsraum der Größe · steht hier einem durchsuchten Raum der Größe O(1) ge- (siehe auch bei der Name bereits andeutet, werden hier einige miteinander verknüpft, was die Aufspaltung mehrerer Touren auf einmal zur Folge hat. Hier bewegen wir uns bei der Anzahl der möglichen Alternativen im Bevon · Durch die auch hier wieder gewählte Beschränkung auf zufällig erzeugte Kombinationen ergibt sich eine Laufzeit von O(1) (siehe bei Schritt soll die Vorzüge eines denen eines Shift- Dem Verschieben eines Artikels folgt hier unmittelbar die einer Zuordnung. Damit ergeben sich · Möglichkeiten, wiederum in O(1) durchsucht werden (siehe auch bei auch hier bereits aus dem Namen hervorgeht, wird zuerst ein Swapund anschließend eine Zuordnung durch einen Hierbei ergibt sich ein Ausmaß an Lösungen von das selbst ist wieder auf O(1) reduziert (siehe auch bei Nachbarschaftsstruktur wurde in der Form umgesetzt, dass sie Anlehnung an den durchsucht wird und nach einer Aufsplittung versucht wird beide neu erzeugten Touren mit allen anderen verfügbaren zu kombinieren. Dies geschieht in mehreren Schritten. Zunächst wird versucht den ersten Teil der Tour mit allen weiteren verfügbaren Touren zu kombinieren. Anschließend wird dies auch mit dem zweiten Teil probiert. Ein weiterer Schritt versucht den ersten und zweiten Teil gleichzeitig mit jeweils unterschiedlichen Touren zu kombinieren. Es entstehen hier also gleich drei unterschiedliche Ansätze pro Aufsplittung. Die Vorgehensweise unterliegt dabei weitaus weniger dem Zufall, viel eher wird versucht eine komplette Abdeckung zu erreichen. Lediglich das Aufsplitten von Touren erfolgt nach wie vor eingeschränkt, da sonst für ein geringes Maß an Verbesserung ein unverhältnismäßig hoher Aufwand betrieben werden müsste. Außerdem sind bei dieser Nachbarschaftsstruktur die einzelnen Moves abhängig voneinander. Es ergibt hier eine Komplexität von · Manche Situationen machen es nötig, eine schnelle Verbesserung einer gegebenen Lösung x zu errechnen, zum Beispiel wenn ein einzusammelnder Artikel nicht an der zugeteilten Stelle aufzufinden ist, weshalb die standardmäßige Abfolge bei VND durch eine Laufzeitbeschränkung limitiert wurde. Es kann dann nach Bedarf eine zeitliche Grenze geben, nach deren Erreichen keine neue Nachbarschaft durchsucht wird. Der Pseudo-Code in Alg. 6 soll diese Umsetzung andeuten. Wie bereits zuvor erwähnt, kann dieser hier vorgestellte VND Ansatz als Reparaturauch als Verbesserungsverfahren verwendet werden. Dies erfordert die Bewer- 34 7.2 Zuordnung von Artikeln zu Touren 6 VND mit zeitlicher Einschränkung eine Startlösung Zähler Anzahl der zu untersuchenden Nachbarschaften begin ; repeat Nachbarschaft ; f ; else 1 ; &gt; eine vordefinierte Zeit wurde erreicht end einer Lösung einer daraus abgeleiteten möglichen Verbesserung Da die Güte einer Lösung im Wesentlichen von der Summe der Längen aller Touren abhängt, ist es also hier von Bedeutung sämtliche benötigte Touren einer Lösung so zu berechnen, dass diese auf kürzestem Weg durch das Lager führen. Kapitel 7.3 wird zeigen wie es möglich ist entsprechende Touren unter Berücksichtigung der speziellen Eigenschaften des Lagers in polynomieller Zeit zu berechnen. Nachbarschaftsstrukturen zur Durchführung von (also zufälligen Veränderungen einer Lösung) basieren auf den zuvor vorgestellten, jedoch werden hierbei anstelle eines Schrittes mehrere zufällig ausgewählte Schritte auf die entspre- Lösung angewendet. In der letzten Version des Algorithmus kam dafür Einsatz. Die zufälligen Veränderungen aus der Nachbarschaft in Alg. 2 daher jeweils nur aus Gleichermaßen wäre aber auch die Verwendung jede Kombination dieser möglich gewesen, jedoch konnten keine klaren Vorteile für eine der Varianten im Vorfeld ausgemacht werden. 7.2.3 Durchsuchen der Nachbarschaften Beim Durchsuchen der einzelnen Nachbarschaften unterscheidet man zwei Methoden Übernahme einer neuen und besseren Lösung, nämlich Improvement Improvement auch Kapitel 5). Wird Improvement so ist das gleichbedeutend mit einem Abbruch der Suche, sobald eine bessere Lösung gefunwurde. Konkret auf wird also die Nachbarschaft systematisch durchsucht und beginnend mit dem ersten bis zum letzten Artikel versucht diesen einer anderen Tour zuzuordnen. Bei diesem Vorgehen sind aber jene Artikel klar bevorzugt, welche in der Liste am Anfang stehen. Daher wurde eine zufällige Durchsuchungsreihenfolge implementiert, sodass jede Lösung im Nachbarschaftsraum mit 35 7 Der Algorithmus im Detail gleicher Wahrscheinlichkeit zu einer Verbesserung beitragen kann. 7.2.4 Dynamische Reihenfolge der Nachbarschaften Eine große Herausforderung bei der Umsetzung mittels VNS stellt die Reihung der definierten Nachbarschaftsstrukturen dar. Nachdem die Anwendung einer Nachbarschaftsstruktur durchaus auch Auswirkungen auf die Effizienz nachfolgender Nachbarschaftsstrukturen hat, ist diese Entscheidungsfindung nicht trivial. Aus diesem Grund wurde entschieden, eine Adaptierung der in [14] vorgestellten Methode zur dynamischen Reihung vorzunehmen. Im Folgenden gilt es stets eine Permutation = ... , der Nachbarschaftsstrukturen ... , berechnen, wobei der Nachbarschaftsstruktur i = 1, ... , k, ein Prädikat 0 zugeordnet wird, welches zu Beginn mit einem konstanten Wert W belegt wird. nun die Nachbarschaft einer Lösung x durchsucht wird, wird in von Rechenzeit und Sucherfolg aktualisiert. Wurde eine verbesserte gefunden, so wird halbiert und hinzugefügt, wobei α ein Parameter ist, der den Einfluss der Auswertung auf die eigentliche Rechenzeit repräsentiert. Sollte keine bessere Lösung gefunden werden, so wird die Nachbarschaftsstruktur Hinzufügen der unverminderten Rechenzeit zum bestehenden Wert mit höheren Kosten belastet. Die Permutation λ wird erst neu erzeugt, wenn ein gerade Wert kleiner als das bisher kleinste, oder größer das bisher größte, solcher Prädikate ist. Dann wird anhand der Werte neue Reihenfolge bestimmt. Das Konzept ist in Alg. 7 ersichtlich, wobei eine kleine Anpassung zum in [14] vorgestellten Algorithmus durchgeführt wurde, um zu vermeiden, dass Nachbarschaften ausgelassen werden können. Das kann vorkommen, da dort vor jeder Umreihung gespeichert wird mit welcher Nachbarschaft fortgesetzt werden soll und diese dann weiter hinten gereiht werden könnte als andere noch nicht besuchte. Außerdem soll verhindert werden, dass die Nachbarschaften ständig umgereiht werden. Dies geschieht im ursprünglich vorgestellten Verfahren viel häufiger, da auch dann eine Umreihung passieren kann, wenn keine Verbesserung der Lösung erzielt wurde. Der tatsächlich verwendete Algorithmus verändert die Reihenfolge der Nachbarschaften erst dann, wenn gerade eine verbesserte Lösung gefunden werden konnte. Getestet wurde der gesamte Algorithmus sowohl mit dynamischer als auch mit statischer Nachbarschaftsreihenfolge. Die Ergebnisse dazu werden in Kapitel 8 präsentiert. 36 7.2 Zuordnung von Artikeln zu Touren 7 VND mit dynamischer Nachbarschaftsreihenfolge eine Startlösung Zähler Anzahl zu untersuchenden Nachbarschaften begin &amp;lt;-- ; ; repeat Nachbarschaft mit Zeitaufwand f ; 2 α ... , sodass ; else 1 ; &gt; k end 37 7 Der Algorithmus im Detail 8 Berechnung einzelner Touren Menge an Zuordnungen Menge von Touren begin S Tour für &amp;lt;-- T u end 7.3 Berechnung einzelner Touren Die nachfolgende Phase des Algorithmus, wie in Alg. 3 vorgestellt, betrifft das Auffinden von Touren ausgehend von den zuvor festgelegten Artikelzuordnungen. Weiters ist die Berechnung von kürzesten Wegen ein Teilproblem des VNS, wie in Kapitel 7.2.2 beschrieben. Zur effizienten Berechnung dieser Touren ist es zunächst notwendig das Lager in eine passende Struktur zu dessen Repräsentation zu bringen, was durch einen ungerichtezusammenhängenden Graphen passiert. Ausgehend davon kann nun ein Verfahren basierend auf Dynamischer Programmierung nach optimalen Touren Die dabei entscheidende Idee ist die Definition so genannter welche entsprechend ihrer Verbindungsmöglichkeiten aneinander angeschlossen werden Der nun im Detail erläuterte Algorithmus berechnet für jede Zuordnung konkrete Tour Diese Vorgehensweise ist im Pseudo-Code in Alg. 8 ersichtlich. 7.3.1 Repräsentation als Graph Die Repräsentation des Lagers geschieht also mittels eines ungerichteten, zusam- Graphen wobei die Kantenmenge Gänge innerhalb Lagers bildet. Unterschieden werden dabei Während erstere jene Gänge sind, die sich zwischen den Lagerregalen befinden und parallel zu diesen sind, verbinden zweitere Regalgänge und wieder andere Hauptgänge miteinan- (siehe auch Abb. 1.1 in Kapitel 1). Jeder Knoten einem Punkt speziellen Eigenschaften. Das können die Kreuzungen von Gängen und Positionen innerhalb von Regalen sein. Es kommt sehr häufig vor, dass mehrere Positionen im Lager (Lagerplätze) übereinander liegen, solche Vorkommen werden dann aber zusammengefasst in einem Knoten, der darüber hinaus den gesamten Regalgang enthält. kann nun sehen, dass jeder Knoten vier Nachbarn hat, das 38 7.3 Berechnung einzelner Touren (a) (b) Abbildung 7.1: Lagerrepräsentation (a) als Graph (b) heißt, der Grad jedes Knotens ist von oben mit vier beschränkt. Weiters besitzen Knoten, die einen Lagerplatz bezeichnen, höchstens zwei Nachbarn. Das heißt, all jene Knoten innerhalb eines Regalganges können als lineare Liste betrachtet werden. Da dem Graph ein typisches Lager zugrunde liegt, ist er planar, also ohne Kreuzungen von Kanten zeichenbar. Ausnützung dieser Eigenschaften kann man den Graphen und die Anzahl an Knoten stark reduzieren, indem für jeden Gang höchstens drei Knoten existieren (siehe Abb. 7.1). Dort repräsentiert der Knoten in der Mitte die (lineare Liste der) Lagerplätze und die beiden Knoten am Beginn und am Ende des Ganges bezeichnen die Kreuzungspunkte mit dem jeweiligen Hauptgang. 7.3.2 Ein Dynamisches Programm Ohne Einschränkung der Allgemeinheit und mit Bezug auf Abb. 7.1 soll angenommen werden, dass Regalgänge und Hauptgänge orthogonal zueinander liegen. Hauptgänge verlaufen hierbei von oben nach unten, Regalgänge stets von links nach rechts. Eine Menge von zwei Hauptgänge gemeinsam mit den dazwischen liegenden Regalgängen weiters auch als Im Folgenden wird ein Algorithmus aufbauend auf Dynamischer Programmierung gezeigt, welcher in polynomieller Zeit die Berechnung kürzester Touren über alle von Interesse, also all jene Lagerplätze mit einzusammelnden Artikeln, in- 39 7 Der Algorithmus im Detail (a) (b) (c) (d) (e) Abbildung 7.2: Grundlegende Gangoperationen. Abbildung 7.3: Grundlegende Zwischen-Gangoperationen. nerhalb eines Blocks durchführt. diesem Zweck werden so genannte sowie Zwischen-Gangopera- Gangoperationen werden herangezogen, um die Möglichkeiten für Wege innerhalb eines Regalganges abzudecken, wohingegen Zwischen-Gangoperationen Bewegungen innerhalb der Hauptgänge beschreiben. Abb. 7.2 ist die Menge an grundlegenden Gangoperationen, welche von Arbeitern durchgeführt werden können, grafisch dargestellt. Es ist offensichtlich, dass Gänge entsprechend von links oder rechts betreten werden können (siehe Abb. 7.2a–7.2d), aber auch komplett ausgelassen werden können (siehe Abb. 7.2e). Ein Gang kann natürlich nur dann ausgelassen werden, wenn keine Artikel daraus benötigt werden. In diesem Fall ist eine solche Operation also auch gültig. Im implementierten Algorithmus kommt diese Operation nicht direkt zum Einsatz, da hier Gänge weggelassen werden, wenn sie nicht betreten werden müssen. Es werden dann einfach die Gänge davor und danach direkt miteinander verbunden. zu den eingeführten grundlegenden Gangoperationen werden Zwischen-Gangoperationen benötigt. Diese wiederum beschreiben welche Möglichkeiten für die Arbeiter bestehen, um sich zwischen zwei aufeinander folgenden Gängen zu bewegen (siehe Abb. 7.3). Diese Aktionen lassen einen Wechsel über die Hauptgänge zu (siehe Abb. 7.3a–7.3d). Natürlich kann es auch vorkommen, dass kein weiterer Gang besucht werden muss, dann ist kein Gangwechsel mehr nötig, wie in Abb. 7.3e zu sehen ist. Die Umsetzung im Programm erfolgt auch hier durch Weglassen nicht benötigter Gänge, die theoretisch gültigen Gangoperationen sind dann nicht nötig. (a) (b) (c) (d) (e) 40 7.3 Berechnung einzelner Touren Abbildung 7.4: Gültige und ungültige Module. ist es hiermit möglich eine Menge an so genannten Gangdefinieren, welche wiederum auf den vorgestellten grundlegenden Operationen aufbauen. Daraus kann man nun jede erdenkliche Kombination erstellen, jedoch ist nicht jede davon auch gleichzeitig gültig. Abb. 7.4a und 7.4b zeigen zwei gültige Module. Das in Abb. 7.4c gezeigte Modul ist jedoch von vornherein ungültig, da der rechte Knoten, der die Kreuzung von Regalgang und Hauptgang repräsentiert zweimal verlassen aber nur einmal betreten wird. Das Modul in Abb. 7.4d ist im Prinzip gültig, aber vom Programm zu verwerfen, weil die Lagerplätze, von denen Artikel eingesammelt werden sollen (in der Abb. dunkelgrau markiert), gar nicht besucht werden. sei nun definiert, dass zwei Module j und für die Gänge i und untereinkompatibel sind, wenn die Module j und basierend auf ihren Zwischenverbunden werden können. Weiters ist Modul mit Modul j ”von oben“ kompatibel, wenn die Zwischen-Gangoperationen von j um ”nach unten“ beziehungsweise ”nach oben“ zu gehen mit den entsprechenden Zwischen-Gangoperatiovon zusammenpassen. Im Folgenden bezeichnet die Menge aller die ”von oben“ kompatibel mit j sind. Beobachtungen Ziel ist immer noch das Einsammeln aller angeforderten Artikel. Nachdem bereits Selektionen an Artikeln getroffen wurden, welche jeweils innerhalb einer Tour einzusammeln sind, wird mit dem Berechnen jeder dieser Touren ein Teilziel erreicht. Zusätzlich dazu suchen wir aber nach Touren durch das Lager, die insgesamt ein Minimum an Zeit benötigen sollen, weshalb eine entsprechende Bewertung jeder Tour erfolgen muss. Diese Bewertung kann auf den zuvor Modulen zur Tourkonstruktion passieren, indem die Kosten &gt; 0 für jedes Modul j basierend auf den Aktionen, die ein Arbeiter in Gang i durchführt, werden. Transformiert auf den erwähnten Dekodierungsgraph bedeutet eine einfache Umlegung auf die Kosten für jede einzelne Kante e gemäß den jeweiligen Längen derselben. In Bezug auf die Anzahl von Modulen, die zur Zusammenstellung einer Tour relevant sein können, muss zum einen nocheinmal erwähnt werden, dass nicht alle Kombinationen an Gangoperationen und Zwischen-Gangoperationen gültige Module bilden. Zum anderen ist es aber darüber hinaus wesentlich zu beachten, dass auch gültige Module teilweise auszuschließen sind beziehungsweise manche gültige Module durch weitaus effizientere Module mit gleichen Möglichkeiten ersetzt werden können. Als (a) (b) (c) (d) 41 7 Der Algorithmus im Detail Abbildung 7.5: Ein gültiges Modul (a) kann durch ein effizienteres Modul (b) ersetzt werden. (a) (b) (a) (b) 7.6: Konstuktion einer Tour aus einer Tour der Annahme, dass Knoten nach Beispiel für einen solchen Austausch im Sinne der Effizienzsteigerung soll Abb. 7.5 dienen. Dort verlangt Modul 7.5a das Erreichen und sofortige Verlassen des Ganges von links oben, weshalb diese beiden Kanten und damit auch nicht notwendiger Weg eingespart werden könnten. Zu beachten ist außerdem, dass eine Tour, wie sie im Rahmen dieser Arbeit verwird, sich von Touren in Zusammenhang mit dem Salesman Prodem Routing Problem Die etwas andere Auffassung kommt daher, dass Knoten, wie zum Beispiel Kreuzungspunkte von Gängen oder die Verdichtungszone, mehr als nur einmal besucht werden dürfen. Das ist notwendig, da meistens keine direkte Verbindung zwischen zwei Knoten des Lagergraphs besteht. Somit können Pfade zwischen zwei Knoten mehrfach zurückgelegt werden, allerdings kann man die Anzahl an Verwendungen des selben Wegs von oben beschränken. 7.3.1. ist eine Tour T von kürzester Länge in Bezug auf eine Menge an Punkten, die von T besucht werden. Weiters wird angenommen, es gibt zwei adjazente Punkte v und w, welche in T zweimal unmittelbar hintereinander besucht werden. Der Weg zwischen v und w wird dann in T einmal von v nach w passiert und einmal umgekehrt. der Weg zwischen zweimal in der gleichen Richdurchlaufen, dann kann man die Tour fünf Teil-Touren wie in Abb. 7.6a zu sehen, wobei die Verdichtungszone steht. kann nun eine neue Tour erzeugen, welche beginnend bei von dann um schließlich von zu (siehe Abb. 7.6b). Da sind, also kein anderer auf dem Weg von werden muss, besucht dieselben Punkte die Tour Weiters werden von ausgelassen, wodurch ist als das wiederum einen Widerspruch zu der Annahme darstellt, 42 7.3 Berechnung einzelner Touren Abbildung 7.7: Sieben gültige und potentiell verwendete Gangoperationen. Abbildung 7.8: 16 gültige und potentiell verwendete Zwischen-Gangoperationen. ist. 7.3.2. ist eine optimale Tour Bezug auf eine Menge an Punk- Zwei adjazente Punkte dann innerhalb von zweimal unmittelbar hintereinander besucht. Beweis dafür folgt direkt aus Theorem 7.3.1. Unter der Annahme, dass als zweimal unmittelbar hintereinander besucht werden, müßte der Weg zweimal in derselben Richtung durchlaufen werden. Ausgehend von Theorem 7.3.1 und Lemma 7.3.2 kann man schließen, dass es sieben Kombinationen von Gangoperationen gibt, die in einer optimalen Tour Anwendung finden können (siehe Abb. 7.7). Natürlich kann ein Gang auch passiert (ausgelassen) werden, wenn keine Artikel entnommen werden müssen. Weiters kann die Anzahl an möglichen Zwischen-Gangoperationen, die für eine optimale Tour Relevanz haben können, von oben mit 16 eingeschränkt werden (siehe Abb. 7.8). Daher kann man mit einer festen Anzahl an generell möglichen und verwendbaren Modulen für optimale (a) (b) (c) (d) (e) (f) (g) (a) (b) (c) (d) (e) (f) (g) (h) (i) (j) (k) (l) (m) (n) (o) (p) 43 7 Der Algorithmus im Detail Abbildung 7.9: Sind diese Module gültig oder ungültig? Touren arbeiten. An dieser Stelle sei nochmals darauf hingewiesen, dass leere Operationen, wie in Abb. 7.7a und Abb. 7.8a, theoretisch Gänge repräsentieren sollen, die nicht betreten oder erreicht werden müssen und im entwickelten Programm gar nicht zum Einsatz kommen. In solchen Fällen werden diese Gänge behandelt als würden sie für die jeweils konkrete Tour nicht existieren. Obwohl nun ersichtlich ist, dass das Auffinden von Touren durch Auswahl geeigneter Module bewerkstelligt werden kann, kann man beobachten, dass das Zusammenspiel mancher Module zu letztlich ungültigen oder nicht rekonstruierbaren Touren führt (siehe Abb. 7.9a). Hier ist zu sehen, dass durch die Kombination zweier Module eigentlich zwei voneinander getrennte Touren entstehen würden. Wie in Abb. 7.9b zu sehen ist, kann die Entscheidung, ob die Kombination von Modulen gültig ist, nicht immer zu dem Zeitpunkt getroffen werden, zu dem ein Modul gewählt wird. Manchmal bestimmt erst ein später hinzugefügtes Modul darüber, ob die Kombinatigültig oder ungültig ist. Sei die Menge von Modulen E wobei die Verwendung von Modul j in einer gültigen (Sub-)Tour resultiert. Update Funktion aus den zuvor erwähnten Beobachtungen, zwei (n+ 1) Matrizen σ und τ eingeführt werden, wobei n die Anzahl an Gängen mit einzusammelnden Artikeln und ν die Anzahl an verwendbaren Modulen Ein Eintrag mit 1 und 1 steht für die Länge einer gültigen welche alle Gänge 1, ... , i besucht, das heißt alle benötigten Artikel aus den Gängen 1 bis i einsammelt und Modul j für Gang i verwendet. Analog dazu steht ein für die Länge einer Tour welche wiederum die Gänge 1, ... , i besucht Modul j für Gang i verwendet. Im Gegensatz zu Tour besteht aber bei Tour Möglichkeit durch Verwendung bestimmter Module in den Gängen i + 1 bis n, ungültig zu werden. Die Einträge für σ und τ berechnen sich mittels folgender rekursiver Funktion: (a) (b) gültig oder ungültig? gültig oder ungültig? gültig ungültig 44 7.3 Berechnung einzelner Touren 0 (7.1) 0 (7.2) ... , \ ... , \ ( ) : ∈ ∪ ... , + min (7.5) : ∈ ... , ( ) : ∈ ∪ ... , + min (7.6) : ∈ diesem Fall repräsentiert Modul Verdichtungszone. Wenn ein Modul ungültige Touren bilden oder nicht kompatibel nach unten sein würde, wird beziehungsweise einer optimalen Tour nun die beiden Matrizen beschrieben initialisiert worden, dann kann man die optimale Tour einfach daraus Zuerst muss das Modul für Gang der optimalen Tour gewählt werden, jener Eintrag repräsentiert, der minimal ist für alle Um die bereits zu ergänzen, sind alle gültigen Module in Gang zwar mittels Zwischen-Gangoperationen zum Gang verbinden, nicht aber Gang 1. Vereinfachung nehmen wir an dieser Stelle an, dass das Modul für Gang in einer optimalen Tour bezeichnet. Es ist dann leicht zu zeigen, dass so ein Eintrag existieren muss. Nun kann man einfach innerhalb der Matrix zurückverfolgen, dass Modul für Gang jenes Modul ist, für das die Gleichung (7.7) erfüllt ist: ( (7.7) = Für alle weiteren Gänge lässt sich die optimale Tour entsprechend ableiten. Sollte der Fall eintreten, dass mehr als ein Modul die Gleichung (7.7) erfüllt, so ist das gleichbedeutend damit, dass es mehrere optimale Touren gibt. Aus diesen Touren ist dann eine beliebige wählbar. 7.3.3 S-Shape-Heuristik Wie bereits in Kapitel 3.4 erwähnt, gibt es Arbeiten, welche zur Berechnung von auf die so genannte zurückgreifen. Das Verfahren folgt einem einfachen Prinzip, wonach sich die Arbeiter auf S-förmigen Touren durch das 45 7 Der Algorithmus im Detail Abbildung 7.10: Veranschaulichung der S-Shape-Heuristik Lager bewegen. Dabei wird ein Gang durchquert sobald er betreten wurde. Natürlich werden Gänge, aus denen kein Artikel geholt werden muss, ausgelassen. Zur Veranschaulichung dieser Vorgehensweise soll Abb. 7.10 dienen. Laut den bereits referenzierten Arbeiten [4] sowie [5] kann man auf diese Weise Lösungen finden, die für viele Probleminstanzen nahe am Optimum liegen. Das ist der Grund dafür, weshalb diese Heuristik in Kombination mit TSH im Rahmen dieser Arbeit als Referenzverfahren eingesetzt wurde. Damit kann man einen Vergleich zu den mittels des entwickelten hybriden Verfahrens berechneten Ergebnissen anstellen und deren Qualität Hierbei sollte darauf hingewiesen werden, dass es sich bei den mittels Sgefundenen Werten nur um Richtwerte handelt. Im Gegensatz zum vorgestellten Algorithmus werden keine Nebenbedingungen geprüft. Daher werden beispielsweise weder Kollisionen vermieden und Artikel stets vom ersten gefundenen Lagerplatz geholt anstatt nach alternativen Lagerplätzen zu suchen. 7.4 Zuordnung von Arbeitern zu Touren Zusätzlich zu den bisherigen Schritten ist es noch wichtig eine Aufteilung aller berechneten Touren auf die verfügbaren Lagerarbeiter zu erstellen. Das bedeutet, dass jedem Arbeiter eine Liste von Touren zugewiesen wird, die von diesem dann abgearbeitet werden muss. Nachdem sich aber alle Arbeiter gleichzeitig im Lager bewegen, müssen entsprechende Maßnahmen getroffen werden, um gegenseitige Behinderungen auszuschließen. VZ 46 7.4 Zuordnung von Arbeitern zu Touren 9 Initiale Arbeiter-Zuordnung eine Menge Touren mit 1 die Anzahl an Arbeitern w Menge Mengen mit 1 von abzuarbeitenden Zähler begin W ∅ ; T &amp;lt; m 1 ; else ; end Eine Zuordnung von Arbeitern zu Touren soll also genau dann gültig sein, wenn es zu keinem Zeitpunkt zu Kreuzungen der Touren zweier Arbeiter innerhalb von Rekommt. Des weiteren sind in Gängen nicht zulässig. Um das berücksichtigen zu können, muss die Geschwindigkeit der Kommissionierungswagen genauso beachtet werden, wie auch die Zeit, die notwendig ist, um die jeweiligen Artikel auszufassen. Trotz all dieser formalen Überlegungen darf man nicht vergessen, dass immer noch Menschen in diesem Lager arbeiten, weshalb man entsprechende Zeitpuffer einplanen muss. Die Arbeitsgeschwindigkeit ist eben abhängig von sehr vielen Faktoren, wie etwa Alter und Erfahrung der Arbeiter, oder äußeren Einflüssen aus dem Umfeld des Lagers. 7.4.1 Konstruktionsheuristik Zur Erzeugung einer Startlösung für weitere Berechnungen muss zunächst eine initiale Zuordnung von Arbeitern zu Touren erfolgen, indem die vorhandenen Touren gleichmäßig auf alle Arbeiter verteilt werden. Der einfache Ansatz einer First-Fit Heuristik wird zum Auffinden einer solchen Initiallösung herangezogen (siehe Alg. 9). Jedenfalls stellt eine solche erste Lösung keinerlei Anspruch auf Korrektheit. Zum einen können Kollisionen der Arbeiter innerhalb von Regalgängen auftreten, zum anderen kann nicht garantiert werden, dass alle angeforderten Artikel innerhalb des zulässigen Zeitrahmens zur Verdichtungszone gebracht werden. Es müssen also noch weitere Schritte folgen, um eine Zuordnung gültig zu machen. Auch hier hilft wieder 47 7 Der Algorithmus im die Umsetzung einer VNS weiter. 7.4.2 Reparaturund Verbesserungsheuristik Zusätzlich zur Entscheidung, ob eine Zuordnung von Arbeitern zu Touren gültig ist, wird versucht eine Aufteilung zu finden, bei der alle Arbeiter mit ihren Arbeitsschritten so früh wie möglich fertig werden. Zu diesem Zweck bietet sich eine Zielfunktion an, die den letzten Endzeitpunkt aller Arbeiter auswertet. Für ein sinnvolles VNS Verfahren muss nun noch eine Anzahl an Nachbarschaften anhand von definiert werden. Sei Arbeitern zu Touren. Weiters nehme man an, dass Menge aller Zu- Menge aller zuvor berechneter Touren beschreibt. Folgende die Basis für die verwendeten Nachbarschaften: j, k, Schritt definiert einfach den Austausch von Tour mit 1 &amp;lt; j Das bedeutet schlicht, dass zwischen zwei Arbeitern je eine Tour ausgetauscht wird. j, wird lediglich eine Tour und letzter Stelle angefügt, wobei 1 j Das kommt einem Verschieben einer Tour von einem Arbeiter zu einem anderen gleich. j, diesem Schritt wird Tour mit um verschoben, wobei 1 Eine solche Umreihung kann in Bezug auf die termingerechte Abwicklung hilfreich sein. der Anwendung dieses Schrittes werden alle Elemente und in eine neue Zuordnung eingefügt, welche dann einem neuen Arbeiter zugewiesen werden kann. Dieser Schritt kann natürlich nur angewendet werden, solange noch freie Arbeiter zur Verfügung stehen. diesen sich die Nachbarschaftsstrukturen WorkerS- Nachdem das Hauptziel dieser VNS Prozedur das Auffinden einer gültigen Zuordnung von Touren zu Arbeitern ist, werden nur Moves berücksichtigt, deren Resultat eine gültige Lösung darstellt. 7.5 Erweiterter Algorithmus Da die hier vorgeschlagenen Methoden insgesamt dafür ausgelegt sind in vergleichbar kurzer Zeit relativ gute Lösungen zu erzeugen, ist es durchaus wahrscheinlich, dass die gefundenen Lösungen noch weiter verbessert werden könnten. Zudem sind 48 7.5 Erweiterter Algorithmus 10 Erweiterter Algorithmus Bestellungen mit Listen aller einzusammelnder Artikel Eine Zuordnung von Arbeitern zu fertigen Touren begin repeat Erstelle Partitionierung vorhandener Bestellungen ; repeat repeat Berechne Zuordnung von Artikeln zu Touren ; Berechne optimale Touren für die oben erstellte Zuordnung ; Verbesserung konnte erzielt werden eine Zuordnung von Arbeitern zu Touren ; aktuelle Zuordnung von Arbeitern zu Touren definiertes Abbruchkriterium ist erfüllt weiteren Bestellungen sind abzuarbeiten end zu dem Zeitpunkt, zu dem der Algorithmus zu arbeiten beginnt, noch nicht alle Bestellungen bekannt, die im Laufe des Tages zu bearbeiten sein werden. Deshalb empfiehlt es sich eine erweiterte Variante des Alg. 3 wie in Alg. 10 beschrieben zu verwenden. Anstelle eines Abbruchs, sobald eine Zuordnung von Touren zu Arbeitern gefunden wurde, soll der Algorithmus hier wieder von vorne beginnen, allerdings unter Berücksichtigung von bereits bearbeiteten Aufteilungen. Das bedeutet etwa, dass bereits eingesammelte Artikel natürlich nicht mehr vertauscht werden können, oder, dass Arbeiter, die bereits auf dem Weg zu einem Artikel sind nicht mehr anders geschickt werden können. Sonstige Änderungen können natürlich noch durchgeführt werden, solange sie eine Verbesserung der Gesamtlösung bringen. Der Algorithmus sollte dann arbeiten, bis alle Bestellungen anforderungsgemäß bearbeitet wurden. Um den Algorithmus möglichst effizient zu gestalten, müssen natürlich auch die darunterliegenden Datenstrukturen entsprechend gewählt werden und Bewertungsfunktionen oder im Speziellen die Funktion zur Berechnung optimaler Touren möglichst schnell arbeiten. 49 50 8 Testergebnisse Um die Verwendbarkeit der vorgestellten Methode im industriellen Umfeld abschätzen zu können, wurden zahlreiche Testläufe durchgeführt. Als Hardware wurde ein zur Zeit aktuelles Arbeitsplatzsystem gewählt – konkret ein Dual Xeon mit 2.6 GHz und 8 GB RAM. Leider war es nicht möglich Echtdaten zu bekommen, da zum Zeitpunkt der Fertigstellung dieser Diplomarbeit noch keine hardwaremäßige Realisierung im Ersatzteillager unseres Industriepartners vorgenommen wurde, weswegen auf statistische Parameter, die im Laufe des vergangenen Jahres gesammelt wurden, zurückgegriffen werden musste, um zufällige Testinstanzen zu generieren. Hierzu wurde das Lager modelliert und die einzusammelnden Artikel den Parametern entsprechend zufällig im Lager verteilt. Zusätzlich wurden typische Kundenbestellungen erzeugt. Variable Parameter waren dabei die Summe der insgesamt bestellten Artikel und die Anzahl der Kundenbestellungen. Nach Rücksprache mit den Lagerleitern wurde festgesetzt, dass Rechenzeiten bis 20 Minuten als akzeptabel gelten, weswegen die maximal verfügbare Rechenzeit auf diese 20 Minuten gesetzt wurde. 8.1 Wahl der Konstruktionsheuristik In einem ersten Vortest wurde untersucht wie die beiden Konstruktionsheuristiken zur Findung einer Ausgangslösung den gesamten Algorithmus beeinflussen. Die verwendeten Testinstanzen sind nicht ident mit jenen der späteren Testläufe, da durch die im Laufe der Entwicklung entstandenen Erweiterungen des Programms auch die Testdaten überarbeitet werden mussten. Deshalb sind die Ergebnisse dieses Vortests nicht direkt mit den späteren vergleichbar. In Tab. 8.1 sind die gesammelten Ergebnisse ersichtlich. Sie zeigen die absoluten Werte der Summe aller Tourlängen für die in Kapitel 7.2.1 vorgestellten Konstruktionsheuristiken CAH und TSH. Natürlich sind diese Werte für sich noch nicht sehr aussagekräftig, vergleicht man sie allerdings miteinander, so lassen sich gewisse Beobachtungen machen. Zunächst fällt auf, dass die errechneten Werte der Tourlängen nicht in unmittelbarem Zusammenhang mit der gewählten Methode zur Erzeugung einer Startlösung gebracht werden können. Es gibt in beiden Fällen an manchen Stellen überdurchschnittlich große Abweichungen. Abgesehen von wenigen Ausnahmen schwanken die Werte für die Tourlängen im direkten Vergleich zwischen den beiden Konstruktionsheuristiken kaum. Das legt die Vermutung nahe, dass die Wahl der Konstruktionsheuristik, wenn überhaupt, nur einen vernachlässigbaren Einfluss auf die endgültige Lösung hat. 51 8 Testergebnisse Tabelle 8.1: Absolute Werte der Tourlängen (Spalten CAH und TSH). Alle Werte sind Durchschnittswerte über 20 Durchläufe (in Klammern sind jeweils die Standardabweichungen angeführt). In Ar Vortest TSH CAH S1 50 9450.11 (68.94) 9428.10 (71.05) S2 50 6961.53 (68.51) 6960.26 (48.91) S3 50 8810.44 (30.38) 8812.79 (34.52) S4 50 6587.15 (83.36) 7631.04 (3149.92) S5 50 7003.12 (87.93) 7010.59 (64.48) M1 100 15724.93 (95.96) 15747.49 (80.36) M2 100 12266.77 (5159.42) 15229.84 (3113.72) M3 100 10187.26 (114.72) 10188.83 (122.95) M4 100 13872.25 (105.74) 13839.25 (131.25) M5 100 14485.47 (5062.99) 16471.11 (4194.89) L1 150 14772.86 (190.65) 14778.72 (174.84) L2 150 15712.18 (162.93) 17217.15 (3677.97) L3 150 18052.87 (3706.13) 19439.24 (200.45) L4 150 18357.51 (167.09) 18287.73 (121.11) L5 150 20216.30 (4847.74) 21540.72 (5330.36) X1 200 22441.44 (4263.34) 23766.84 (5223.52) X2 200 20354.92 (4331.64) 22260.29 (189.05) X3 200 25609.66 (361.38) 29492.64 (5359.09) X4 200 18393.69 (3773.50) 25555.01 (3443.50) X5 200 19685.29 (211.60) 23847.93 (5303.58) 52 8.2 Wahl von Berechnungsparametern 8.2 Wahl von Berechnungsparametern Der erste durchgeführte Testlauf sollte nun zeigen, wie sich gewisse Berechnungsparameter auf den Algorithmus auswirken. Zwei wesentliche Steuerungsmöglichkeiten sind zum einen das Erlauben oder Verbieten des Umkehrens innerhalb von Gängen, was bedeutet, dass ein Gang komplett durchquert werden muss, falls er betreten wird. Zum anderen ist das die Verwendung von statischen oder dynamischen Reihenfolgen für die Nachbarschaften der VNS. Wie bereits in Kapitel 7.2.4 beschrieben wurde, erfolgt bei dynamischer Nachbarschaftsreihenfolge laufend eine Umreihung dieser Strukturen, um Lösungsverbesserungen durch normalerweise später durchsuchte Nachbarschaften, die dann möglicherweise gar keine Verbesserungen erzielen, schon früher zu ermöglichen. In Tab. 8.2 (ohne Artikel auf alternativen Lagerplätzen) und Tab. 8.3 (mit Artikeln auf alternativen Lagerplätzen) sind die gesammelten des Testlaufs (Testlauf 1) zusammengefasst. Dabei wird die mittels S- (siehe Kapitel 7.3.3) gefundene Lösung als Referenz herangezogen. Die berechneten Werte werden dann prozentuell dazu angegeben, sodass ein direkter Vergleich möglich ist. Da alle Werte den Durchschnitt über 20 Durchläufe repräsentieren, wird auch die Standardabweichung angeführt. Zu beachten ist hierbei, die mittels erzielten Werte nur als Anhaltspunkt dienen und keinerlei Nebenbedingungen berücksichtigt wurden. Zusätzlich sind noch die Durchschnittswerte für Laufzeit und Kapazitätsauslastung der Kommissionierungswagen Verwendet wurden die Nachbarschaften Swap- Diese Auflistung entspricht gleichzeitig der Anfangsreihenfolge der Nachbarschaften. Man kann nun beim Untersuchen der Tabellen einige interessante Entdeckungen machen. Zunächst möchte ich auf den Vergleich von statischer und dynamischer Nachbarschaftsreihenfolge eingehen. Hier ist bei den kleinen Instanzen mit 25 Artikeln zu sehen, dass die Werte der Zielfunktionen sehr nahe beisammen liegen, bei dynamischer Nachbarschaftsreihenfolge dennoch leicht bessere Werte vorliegen. Die Laufzeit ist allerdings geringfügig länger, wenn auch nicht sehr viel. Interessant hingegen sind die Instanzen mit 50 Artikeln, bei denen sowohl ein besseres Laufzeitverhalten, als auch ein besserer Zielfunktionswert zu bemerken ist, wenn dynamische Nachbarschaftsreihenfolge verwendet wird. Auch bei jenen Instanzen mit 100 Artikeln bringt die Berechnung mittels dynamischer Nachbarschaftsreihenfolge stets ein besseres Ergebnis in beiden Bereichen. Für die größeren Instanzen mit 200 Artikeln wiederum muss man sagen, dass die dynamische Reihenfolge der Nachbarschaften keinen klaren Vorteil bringt. Das mag aber möglicherweise daran liegen, dass bei so vielen Artikeln große Teile des Lagers durchlaufen werden müssen, also kaum Wege eingespart werden können und somit die Optimierung weniger Optionen zur Verfügung hat. Außerdem werden nach der gegebenen zeitlichen Beschränkung die Berechnungen unterbrochen. Um die Auslastung der Kommissionierungswagen nicht außer Acht zu lassen, sei erwähnt, dass die Durchschnittswerte eine durchwegs hohe Belegung zeigen, was deutlich für die Effizienz der Berechnungen spricht. Gesamt betrachtet lässt 53 8 Testergebnisse 54 M1 50 3658.73 225.1 (433.63) 829.65 99.9 210.6 (520.43) 1117.14 99.9 200.9 189.0 68.9</abstract>
<phone confidence="0.840485">(485.90) 649.32 99.9 99.9 73.2</phone>
<address confidence="0.683424833333333">1185.23 99.6 99.6 75.7 75.6 100 6461.82 99.1 72.7 71.2 77.7 68.7 99.1 99.1 (13.48) 99.1 99.0 99.0 200 10820.65 102.7 (285.88) 99.9 (532.23) 115.2 99.9 (507.35) 104.3 99.9 694.9 96.8 81.9</address>
<phone confidence="0.800251">(54.59) 99.7 382.8</phone>
<address confidence="0.9173445">98.4 94.5 82.1</address>
<phone confidence="0.827773666666667">100 6581.63 99.8 (142.52) 95.0 99.8 88.2 68.1 (153.86) 1188.82 99.8 99.8 73.8 (40.10) 99.6 99.6</phone>
<address confidence="0.861704">87.7 99.9 99.9 81.5 81.6 99.9 70.9 66.5 100 6622.66 99.9 99.6 �� 99.6 100 81.5 &gt;max 81.6 &gt;max 70.9 &gt;max 66.5 &gt;max 99.6</address>
<phone confidence="0.962422">(156.68) (607.07) (173.85) (157.74) (49.67) (46.18)</phone>
<address confidence="0.9143574">94.5 95.0 88.2 82.1 73.8 68.1 100 6581.63 ,,,,, .,,� „ ,,, .,,� &gt;max 99.8 ,, .,, �„� 1188.82 99.8 ,,,,,, ,,,,� ,,,, ,,,� &gt;max 99.6 ,.,, 100 6740.34 99.8 99.8 95.2 102.1 99.8 72.0 67.4 99.8 99.6 99.6 100 95.2 &gt;max &gt;max 72.0 &gt;max 67.4 &gt;max 99.6</address>
<phone confidence="0.960837">(303.67) (310.36) (196.42) (307.57) (68.85) (43.64)</phone>
<address confidence="0.871399">93.3 99.7 99.7 109.9 99.7 152.2 99.7 100.3 226.4 X4 200 11011.98 99.5 99.5 X4 200 11011.98 93.3 &gt;max 99.7 99.7 109.9 &gt;max 99.7 152.2 &gt;max 99.7 100.3 &gt;max 99.5 226.4</address>
<phone confidence="0.82226125">(177.47) (372.87) (1469.24) (5119.61) (1978.89) (10815.91) M3 50 4325.10 133.8 (258.82) 832.84 99.8 (196.96) 127.8 1138.18 99.8 119.9 118.0 61.2 (152.27) 660.23 99.8 99.8 66.6 (13.52) 1137.23 99.6 99.6</phone>
<address confidence="0.786592">50 3908.69 99.3 99.3 98.1 87.4 957.56 99.3 71.9 68.1 638.38 99.3 1151.07 99.0 ,,,� 99.0</address>
<phone confidence="0.8215265">50 3908.69 99.3 99.3 99.3 87&apos;4 957.56 99.3 99.0 68&apos;1 (192.75) (143.38) (154.15) (126.26) (9.54) (6.47)</phone>
<address confidence="0.711177666666667">133.8 127.8 119.9 118.0 66.6 61.2 50 4325.10 „� 832.84 99.8 „� 1138.18 99.8 � 660.23 99.8 894.85 99.8 � 1137.23 99.6 200 10987.27 129.1 (332.14) 99.9 (531.30) 148.6 99.9 (251.67) 121.5 99.9 335.7 72.9</address>
<phone confidence="0.938236">(12189.38) 99.8 83.3 (66.47) 99.6 99.6</phone>
<address confidence="0.899926">99.5 93.8 99.5 147.9 103.9 99.5 80.3 118.7 200 11049.59 99.5 99.3 99.3 200 11049.59 84.0 93.8 &gt;max 99.5 147.9 &gt;max 99.5 103.9 80.3 &gt;max 99.3 118.7</address>
<phone confidence="0.971342">(146.84) (344.94) (4458.14) (1926.03) (51.32) (5157.68)</phone>
<address confidence="0.8149154">129.1 148.6 121.5 335.7 83.3 72.9 200 10987.27 � &gt;max 99.9 � &gt;max 99.9 �� &gt;max 99.6 50 3886.14 99.2 99.2 96.2 101.7 947.45 99.2 68.2 64.7 685.06 99.2 1153.65 99.0 99.0 50 3886.14 99.2 99.2 96.2 685.06 99.2 101.7 947.45 99.2 99.0 64.7 &gt;max 99.0</address>
<phone confidence="0.968093">(286.22) (191.30) (183.15) (230.13) (13.04) (6.59)</phone>
<address confidence="0.584608">68.6 81.05 72.5 67.4 111.65 80.8 67.6 66.6 152.07 77.5 67.3 66.5 S2 25 2150.77 83.64 69.9 342.29 74.4 420.56 79.2 25 2150.77 68.6 81.05 72.5 80.8 67.6 83.64 69.9 66.6 152.07 77.5 67.3 342.29 74.4 66.5 420.56 79.2</address>
<phone confidence="0.720623944444444">(8.27) (8.19) (1.92) (0.64) (0.56) (0.10) 75.2 74.8 S1 25 2135.47 80.4 72.6 72.5 74.7 72.6 (2.22) 119.63 87.1 80.6 (1.27) 156.23 86.1 86.9 86.7 73.0 70.1 25 2368.25 85.6 (3.37) 70.2 135.41 85.6 72.9 69.5 (0.00) 119.23 85.6 (1.19) 148.48 85.6 70.9 270.27 86.2 80.2 S3 25 2368.25 73.0 108.64 85.6 70.2 135.41 85.6 72.9 119.23 85.6 70.1 148.48 85.6 70.9 270.27 86.2 69.5 381.24 80.2 68.5 89.24 72.7 72.7 68.3 67.8 129.77 72.7 67.6 67.6 S4 25 2320.21 90.77 72.7 241.96 74.2 299.53 68.2 S4 25 2320.21 68.5 89.24 72.7 68.0 104.24 72.7 68.3 90.77 72.7 67.8 129.77 72.7 67.6 241.96 74.2 67.6 299.53 68.2 (7.02) (1.04) (3.48) (0.66) (0.00) (0.00) (3.53) 82.75 78.2 63.4 66.3 (6.85) 92.97 83.7 66.2 63.1 63.0 (3.37) 103.56 78.1 (2.56) 146.03 84.0 66.1 286.96 85.2 82.8 66.3 63.4 66.2 63.1 66.1 63.0</phone>
<address confidence="0.5753445">S5 25 2352.01 _ 82.75 78.2 _ 92.97 83.7 103.56 78.1 _ 146.03 84.0 286.96 85.2 391.50 82.8 99.8 99.7 87.4 (433.03) 99.8 85.9 79.6 67.4 99.8 99.8 71.7</address>
<phone confidence="0.930278">(36.90) 99.6 99.6</phone>
<address confidence="0.840809666666667">87.4 99.7 85.9 79.6 71.7 67.4 100 6560.45 &gt;max &gt;max &gt;max 100.0 122.5</address>
<phone confidence="0.62754">114.9 (591.60) 100.0 116.0 100.0 111.6 (703.96) 100.0 99.0 127.4</phone>
<address confidence="0.858381666666667">99.8 99.1 114.9 122.5 116.0 100.0 127.4 111.6 200 11428.16 &gt;max 100.0 &gt;max 100.0 � &gt;max 99.8 �</address>
<phone confidence="0.736397666666667">(1133.36) 974.95 99.8 179.1 196.8 (889.70) 1189.09 99.8 135.4 120.1 64.7 (226.24) 651.23 99.8 99.8 69.4 1158.30 99.6 99.6 196.8 179.1 135.4 120.1 69.4 64.7 50 4160.70 974.95 99.8 ,� „� 1189.09 99.8 � 651.23 99.8 � 1026.55 99.8 1158.30 99.6</phone>
<abstract confidence="0.9653538">Ar f(x) t C f(x) t C f(x) t C f(x) t C f(x) t C f(x) t C statische Reihenfolge dynamische Reihenfolge dynamische Reihenfolge Testlauf 1 Testlauf 2 ohne Umkehren mit Umkehren ohne Umkehren mit Umkehren ohne Umkehren mit Umkehren 8.2: der Testläufe 1 und 2 auf alternativen Lagerplätzen - Durchschnittswerte über 20 Testläufe mit 25, 50, und 200 einzusammelnden Artikeln (Ar). Angeführt sind der Zielfunktionswert (f(x) in Prozent [%]) relativ zur mittels und mit absoluter Standardabweichung in Klammern, die Laufzeit (t in Sekunden [s]) und die Kapazitätsauslastung der (C in Prozent [%]). Getestet wurden die Instanzen (In) auf alternativen Lagerplätzen bei Berechnung innerhalb eines Ganges und bei 8.2 Wahl von Berechnungsparametern</abstract>
<address confidence="0.7878069">55 100.0 124.4 112.5 (393.85) 100.0 106.5 142.0 125.5 100.0 100.0 93.4 99.8 99.8 112.5 124.4 106.5 142.0 93.4 125.5 200 11360.11 100.0 &gt;max 100.0 , &gt;max 99.8 , &gt;max 99.8 99.8 91.1 84.5 (262.57) 99.8 82.6 78.0 67.0 99.8 99.8 72.2</address>
<phone confidence="0.923436">(39.23) 99.6 99.6</phone>
<address confidence="0.8643875">84.5 91.1 82.6 78.0 72.2 67.0 100 6560.45 ,,,,� &gt;max 99.8 ,,,,,,, .,,� ,,,,,, ,,,� ,,,,,, ,,,� ,,,,, ,,,,� ,,,, ,,,-</address>
<phone confidence="0.801736363636364">(497.16) 950.52 99.8 169.6 176.7 (688.33) 1160.87 99.8 138.0 128.1 64.8 (263.29) 684.97 99.8 99.8 68.9 (12.12) 1179.74 99.6 99.6 176.7 169.6 138.0 128.1 68.9 64.8 50 4160.70 „� 950.52 99.8 ,,, „� 1160.87 99.8 ,,, � 684.97 99.8 � 1081.84 99.8 � 1179.74 99.6 (9.99) 20.82 79.3 64.2 67.8 (8.66) 20.82 82.5 66.7 63.5 63.2 (2.68) 91.48 78.1 (3.88) 102.28 79.4 66.5 265.08 81.6 84.5 25 2310.23 79.3 64.2 20.82 82.5 66.7 91.48 78.1 63.5 102.28 79.4 66.5 265.08 81.6 63.2 472.63 84.5</phone>
<title confidence="0.831466">statische Reihenfolge dynamische Reihenfolge dynamische Reihenfolge</title>
<author confidence="0.786366">Testlauf Testlauf</author>
<affiliation confidence="0.800065">ohne Umkehren mit Umkehren ohne Umkehren mit Umkehren ohne Umkehren mit Umkehren</affiliation>
<address confidence="0.7763065">200 10925.71 98.6 (300.98) 99.9 (392.63) 117.0 99.9 101.1 127.8 141.1 99.9 99.9 82.5</address>
<phone confidence="0.8709652">(55.80) 99.7 100.0 100 6448.32 75.5 (33.27) 99.1 (25.18) 71.7 99.1 75.4 71.0 74.1 70.9 (20.19) 1189.46 99.1 (22.46) 99.1 99.0 99.0 M1 50 3658.73 188.6 (448.05) 946.93 99.9 200.4 (461.85) 1096.41 99.9 243.8 191.1 72.7 69.2 (477.00) 650.55 99.9 99.9 99.6 99.6</phone>
<address confidence="0.769136333333333">100 6740.34 99.8 99.8 94.4 94.4 99.8 71.8 67.3 1199.49 99.8 99.6 ,,,- 99.6 L4 100 6740.34 99.8 99.8 99.8 94.4 71.8 &gt;max 99.6 67.3 &gt;max 99.6</address>
<phone confidence="0.974975">(214.82) (286.70) (193.17) (171.96) (73.46) (46.97)</phone>
<address confidence="0.913137666666667">M4 50 3871.34 99.2 99.2 95.0 89.5 70.3 66.3 669.68 99.2 973.45 99.2 99.0 ,,, , 99.0 50 3871.34 99.2 99.2 99.2 89.5 973.45 99.2 99.0 66.3 &gt;max 99.0</address>
<phone confidence="0.969339">(228.32) (226.38) (163.61) (178.11) (11.14) (9.61)</phone>
<address confidence="0.940127">200 11011.98 99.7 98.5 99.7 88.8 99.7 202.8 99.9 83.6 116.6 99.5 99.5 200 11011.98 99.7 98.5 88.8 &gt;max 99.7 202.8 83.6 116.6</address>
<phone confidence="0.967165">(208.04) (291.13) (212.51) (10275.14) (70.99) (4782.30)</phone>
<address confidence="0.6432895">100 6548.31 99.9 92.5 99.9 83.9 88.5 99.9 70.0 66.2 1187.82 99.9 99.6 99.6 100 6588.51 88.1 (147.70) 99.8 93.9 (255.14) 99.8 88.9 84.0 67.9 99.8 99.8 75.1</address>
<phone confidence="0.879963">(59.88) 99.6 99.6</phone>
<address confidence="0.813714">100 6548.31 99.9 92.5 &gt;max 99.9 99.9 88.5 &gt;max 99.9 70.0 &gt;max 99.6 66.2 &gt;max 99.6</address>
<phone confidence="0.974389">(211.54) (366.95) (148.72) (225.18) (25.04) (26.12)</phone>
<address confidence="0.6813573">88.1 93.9 88.9 84.0 .1 100 6588.51 � &gt;max 99.8 75 200 10997.52 99.5 86.0 99.5 84.1 278.2 99.5 81.9 108.5 99.5 99.3 99.3 200 10932.39 135.9 (374.26) 99.9 (528.37) 151.7 99.9 123.9 99.9 99.9 141.9 116.3 (6124.02) 99.6 418.9 99.6 X2 200 10997.52 86.9 4. &gt;max 99.5 86.0 81 278.2 81.9 108.5</address>
<phone confidence="0.919824">(207.66) (296.29) (160.55) (15585.21) (69.20) (3542.61)</phone>
<address confidence="0.881812666666667">135.9 151.7 123.9 116.3 141.9 418.9 200 10932.39 , , &gt;max 99.9 , &gt;max 99.9 , , „ 50 3932.43 99.3 99.3 92.3 85.5 71.2 67.6</address>
<phone confidence="0.76789">797.88 99.3 901.94 99.3 1181.24 99.0 99.0 M3 50 4256.39 130.5 (259.84) 694.81 99.8 (288.40) 123.8 1122.85 99.8 127.5 106.5 62.1 (164.63) 669.46 99.8 99.8 66.8 (10.71) 1173.11 99.6 99.6 50 3932.43 99.3 99.3 99.3 85.5 901.94 99.3 99.0 67.6 (141.95) (179.04) (108.51) (143.83) (8.86) (7.70)</phone>
<address confidence="0.523289">130.5 . 127.5 106.5 6.8 62.1 50 4256.39 ,,, ,� 694.81 99.8 99.8 � 669.46 99.8 973.31 99.8 99.6</address>
<phone confidence="0.786432">(7.43) (6.82) (1.41) (0.97) (0.92) (0.85) S3 25 2368.25 72.9 (0.95) 111.35 85.6 (2.39) 70.3 131.97 85.6 73.0 70.1 70.9 69.4 (1.26) 92.90 85.6 (0.97) 170.86 85.6 86.2 86.2 25 2368.25 111.35 85.6 70&apos;3 131.97 85.6 73.0 92.90 85.6 - 170.86 85.6 86.2 86.2 S1 25 2147.27 74.8 (5.23) 62.30 76.9 (1.76) 72.2 104.79 80.5 74.4 72.1 74.4 72.0 (0.95) 136.75 80.0 (1.74) 178.48 84.5 83.5 90.2</phone>
<address confidence="0.6664015">25 2150.77 69.7 66.8 91.76 73.3 67.5 66.2 143.19 74.6 67.3 66.2 117.70 70.2 360.31 74.8 498.57 78.2 25 2150.77 69.7 66.8 91.76 73.3 67.5 117.70 70.2 66.2 143.19 74.6 67.3 360.31 74.8 66.2 498.57 78.2 S4 25 2320.21 72.7 67.9 122.70 72.7 68.1 67.8 134.27 72.7 67.6 67.6 94.71 72.7 250.91 74.2 325.90 74.2 25 2320.21 72.7 67.9 122.70 72.7 68.1 94.71 72.7 67.8 134.27 72.7 67.6 250.91 74.2 67.6 325.90 74.2</address>
<phone confidence="0.80368">(4.26) (0.99) (1.82) (0.73) (0.00) (0.00)</phone>
<abstract confidence="0.934483340707965">Ar f(x) t C f(x) t C f(x) t C f(x) t C f(x) t C f(x) t C 8.3: der Testläufe 1 und 2 auf alternativen Lagerplätzen - Durchschnittswerte über 20 Testläufe mit 25, 50, und 200 einzusammelnden Artikeln (Ar). Angeführt sind der Zielfunktionswert (f(x) in Prozent [%]) relativ zur mittels und mit absoluter Standardabweichung in Klammern, die Laufzeit (t in Sekunden [s]) und die Kapazitätsauslastung der (C in Prozent [%]). Getestet wurden die Instanzen (In) auf alternativen Lagerplätzen bei Berechnung innerhalb eines Ganges und bei 8 Testergebnisse die Verwendung von dynamischen Nachbarschaftsreihenfolgen bessere Ergebnisse erwarten und sollte wohl im Echtbetrieb bevorzugt verwendet werden. Nun zum Unterschied zwischen den Werten mit und denen ohne Umkehren. Vor allem bei kleineren bis mittleren Instanzen sind klare Vorteile durch das Zulassen des Umkehrens auszumachen. Auch hier sind interessanter Weise die Laufzeiten leicht über denen der Tests ohne Umkehren. Sobald die Instanzen eine Größe erreichen, bei der der Algorithmus abgebrochen wird, lässt sich nur schwer eine Aussage darüber machen, wie repräsentativ die Werte sind. Aber wie auch beim Vergleich zwischen statischer und dynamischer Nachbarschaftsreihenfolge sind keine klaren Vorteile für ein Verfahren auszumachen. Dennoch scheint man mit Umkehren eher bessere Ergebnisse erzielen zu können. Weiters wurden die Instanzen hinsichtlich ihrer Lösbarkeit bei Verwendung von alternativen Lagerplätzen für bestimmte Artikel untersucht. Das heißt also, dass manche Artikel an mehreren Positionen im Lager verfügbar sind und damit zusätzliche Möglichkeiten zur Bildung von Touren vorliegen können. Wirklich klare Unterschiede sind hier nur schwer zu erkennen. Wenn überhaupt, so sind am ehesten in Kombination mit dem Erlauben des Umkehrens leichte Vorteile auszumachen. Das liegt aber sicherlich auch daran, dass nicht alle Artikel an mehreren Positionen verfügbar sind. Somit kann es auch passieren, dass für die angeforderten Artikel keine alternativen Lagerplätze existieren und somit dieselbe Problemstellung vorherrscht wie bei der Berechnung ohne alternative Lagerplätze. Generell sind nach diesen Tests natürlich nur Tendenzen auszumachen, es ist aber zu beachten, dass durchaus die Werte für kleinere Instanzen ausschlaggebend sind, da, wie auch schon in der Problembeschreibung erwähnt, nicht alle angeforderten Artikel auf einmal bekannt sind. Es kann also angenommen werden, dass im Verlauf eines Arbeitstages immer wieder kleinere Instanzen verarbeitet werden. Unter diesem Gesichtspunkt bieten die zuvor gefundenen Unterschiede durchaus eine Entscheidungsgrundlage zur Wahl entsprechender Berechnungsparameter. 8.3 Effizienz einzelner Nachbarschaften Neben den im vorigen Abschnitt erläuterten Ergebnissen, wurde auch das Verhalten der Nachbarschaften im Verlauf des Algorithmus ausgewertet. In Tab. 8.4 ist zu sehen wie hoch der Anteil an Verbesserungen gegenüber allen getesteten Schritten einer Nachbarschaft ist. Wurden also beispielsweise 100 Schritte innerhalb einer Nachbarschaft getestet und führten 80 davon zu einer Verbesserung, so würde in der Tabelle ein Wert von 80% vermerkt werden. Die ersten vier Nachbarschaften stellen grundlegende Operationen zur Lösungsverbesserung dar, weshalb sie auch zu Beginn werden. an erster Stelle, um aus anfänglich meist großen Touren mehrere kleinere zu erzeugen. Die Laufzeiten der folgenden Nachbarschaf- 56 8.4 Rechenzeit der Nachbarschaften abhängig von der Anzahl der Touren insgesamt, vor diesen beiden noch wird. Das ermöglicht das Zusammenführen mancher Touren, falls dies eine Verbesserung bringt. Erst im Anschluss an diese vier Nachbarschaften folgen jene, deren Komplexität größer ist, wobei die Reihenfolge hier auf Basis von kleineren Vortests so gewählt wurde. Es folgen also Selbstverständlich wirkt sich diese Reihenfolge nur direkt bei Verwendung von statischer Nachbarschaftsreihenfolge aus. Das Durchsuchen der Nachbarschaften erfolgte außerunter Verwendung der Strategie Improvement dazu auch Kapitel 5). fallen viele Einträge mit ”0.0%“ auf. Vor allem Nachbarschaft hier sehr dominant, was aber durchaus zu erklären ist, da ein verteiltes Einsammeln eines Artikels von mehreren Positionen bedeutet, eine Position mehr im Lager anfahren zu müssen. Es ist zwar vorstellbar, dass in manchen Szenarien solch eine Aufteilung von Nutzen ist, die Tests haben allerdings gezeigt, dass damit nicht sehr viel verbessert werden kann. Das Verhalten im Echtbetrieb kann leider nur schwer eingeschätzt werden, denn hierzu müsste man auf Basis von echten Daten entsprechende Auserstellen. Weiters sind die Nachbarschaften dann sinnvoll, wenn auch alternative Positionen von Artikeln im Lager verwendet werden, deshalb wurden die entsprechenden Einträge mit ”-“ markiert. Zusätzlich dazu beeinflusst die dynamische Reihung der Nachbarschaften deren Effizienz entscheidend, was sehr bei sehen ist. Da bei statischer Reihenfolge der Nachbarschaften schon so bleiben für kaum mehr Möglichkeiten zur Verbesserung. Anders bei dynamischer Reihenfolge, wo die Nachbarschaften einigermaßen gleichmäßig verteilt zum Einsatz kommen. Eine weitere Beobachtung hinsichtlich werden. Der Prozentsatz ist hier vor allem bei größeren sehr klein, was darauf zurückzuführen ist, dass dann sinnvoll verwendet werden kann, wenn Kommissionierungswagen weit unter ihrer Kapazität ausgelastet sind, was lediglich zu Beginn des Algorithmus sehr wichtig ist, mit zunehmender Laufzeit aber kaum mehr vorkommen dürfte. Besonders effizient hingeverhält sich wo ein sehr hoher Prozentsatz an erzeugten tatsächlich zu einer Verbesserung der Gesamtlösung führt. Dabei steht vor allem das Beseitigen von überfüllten Kommissionierungswagen und damit ungültigen Touren im Vordergrund. 8.4 Rechenzeit der Nachbarschaften Repräsentativ für das Laufzeitverhalten der einzelnen Nachbarschaften soll Tab. 8.5 (Testlauf 1) zeigen, wie hoch der Rechenaufwand der einzelnen Nachbarschaften ausfällt. allem hier mit besonders hohem Aufwand zu Buche, was durch die eihohe Effizienz bei Verwendung dynamisch veränderbarer Nachbarschafts- 57 8 Testergebnisse statische Reihenfolge dynamische Reihenfolge Ar Testlauf 1 ohne Umkehren mit Umkehren ohne Umkehren mit Umkehren 8.4: der Nachbarschaften in Testlauf 1 auf alternativen Lagerplätzen - Durchschnittswerte über 20 Testläufe mit 25, 50, 100 und 200 einzusammelnden Artikeln (Ar). Angeführt ist pro Nachbarschaft der prozentuelle Anteil (alle Werte in Prozent [%]) an erfolgreichen Schritten in Relation zu den insgesamt getesteten Schritten der jeweiligen Nachbarschaft. Getestet wurden die Instanzen (In) auf alternativen Lagerplätzen bei Berechnung innerhalb eines Ganges und bei S1 25 50.3 53.8 62.9 34.9 0.0 2.8 0.0 3.9 38.6 43.3 67.8 46.5 0.0 9.1 0.0 4.7 46.2 44.1 67.6 75.2 14.7 12.8 0.0 62.8 40.6 33.5 71.7 74.8 12.9 16.7 0.0 58.5 S2 25 44.8 47.6 68.5 36.0 0.7 12.3 0.0 6.5 33.2 40.0 73.6 38.4 0.0 10.4 0.0 1.7 46.5 41.5 74.1 68.4 15.1 20.3 0.0 64.8 41.3 36.1 79.9 69.5 10.9 16.6 0.0 62.3 S3 25 100.0 8.1 77.9 64.0 0.0 0.0 0.0 0.0 100.0 10.5 74.4 63.8 0.0 0.0 0.0 0.8 100.0 7.2 76.9 89.2 0.0 0.0 0.0 35.5 100.0 6.4 75.0 87.4 0.0 0.0 0.0 37.3 S4 25 100.0 14.9 71.1 58.1 0.0 0.0 0.0 4.6 93.3 15.9 74.4 55.1 0.0 0.0 0.0 0.7 100.0 13.4 73.6 83.7 0.0 0.0 0.0 31.5 97.8 14.7 76.9 82.1 0.0 0.0 0.0 47.6 S5 25 85.1 57.4 66.4 79.1 0.0 0.0 0.0 62.7 66.4 53.4 84.0 83.9 0.0 0.0 0.0 73.3 69.1 33.6 67.8 81.7 39.1 10.9 0.0 75.4 52.2 38.8 80.1 77.2 25.2 19.1 0.0 68.3 M1 50 100.0 2.2 44.5 96.5 0.0 0.0 0.0 0.0 100.0 1.5 46.0 96.8 0.0 0.0 0.0 0.0 98.0 2.5 66.3 97.0 62.8 49.9 0.0 46.8 100.0 0.1 69.5 97.3 66.3 47.3 0.0 43.6 M2 50 100.0 2.0 53.7 95.3 0.0 0.0 0.0 0.0 100.0 1.4 55.6 96.5 0.0 0.0 0.0 0.0 100.0 3.3 70.0 97.3 0.0 0.0 0.0 17.4 100.0 1.1 71.8 97.6 0.0 0.0 0.0 32.8 M3 50 100.0 2.5 65.7 94.5 0.0 0.0 0.0 0.0 100.0 1.7 64.4 95.8 0.0 0.0 0.0 0.0 100.0 1.7 67.3 96.8 55.3 47.7 0.0 61.3 100.0 0.8 72.4 96.8 58.6 57.9 0.0 56.2 M4 50 100.0 2.1 50.2 94.8 0.0 0.0 0.0 0.0 100.0 1.6 51.5 95.8 0.0 0.0 0.0 0.0 99.0 0.8 65.5 97.1 52.8 58.6 0.0 48.2 100.0 0.3 64.5 97.6 55.0 51.1 0.0 47.8 M5 50 100.0 1.9 57.3 95.3 0.0 0.0 0.0 0.0 100.0 1.6 58.9 96.2 0.0 0.0 0.0 0.0 100.0 0.4 61.4 96.9 37.8 13.9 0.0 63.5 100.0 0.2 68.2 97.2 34.2 11.6 0.0 50.8 L1 100 100.0 2.8 47.8 96.0 0.0 0.0 0.0 0.0 100.0 1.6 52.9 99.0 0.0 0.0 0.0 0.0 100.0 3.8 56.8 97.2 76.7 71.4 0.0 67.6 100.0 0.9 81.9 98.3 62.9 82.6 0.0 61.9 L2 100 100.0 2.6 53.6 97.0 0.0 0.0 0.0 0.0 100.0 1.7 56.2 99.6 0.0 0.0 0.0 0.0 100.0 1.3 72.1 97.3 54.6 70.4 0.0 63.0 100.0 1.2 83.9 98.6 58.1 82.6 0.0 59.0 L3 100 100.0 3.0 52.8 96.5 0.0 0.0 0.0 0.0 100.0 1.4 59.2 99.1 0.0 0.0 0.0 0.0 99.6 2.9 60.7 97.1 70.8 63.8 0.0 70.4 99.6 1.0 87.5 98.1 74.0 72.3 0.0 66.8 L4 100 100.0 2.1 50.6 96.8 0.0 0.0 0.0 0.0 100.0 1.4 53.9 99.7 0.0 0.0 0.0 0.0 100.0 0.9 60.9 97.2 53.7 42.0 0.0 64.4 98.8 2.0 71.7 98.7 62.1 33.7 0.0 75.2 L5 100 100.0 2.2 54.4 96.4 0.0 0.0 0.0 0.0 100.0 1.6 54.4 99.2 0.0 0.0 0.0 0.0 100.0 1.2 67.1 96.9 49.4 52.9 0.0 58.4 100.0 0.1 76.2 98.8 44.5 55.6 0.0 59.1 X1 200 100.0 1.3 75.4 99.1 0.0 0.0 0.0 0.0 100.0 1.1 84.1 100.0 0.0 0.0 0.0 0.0 100.0 8.8 75.5 98.5 69.3 87.0 0.0 82.8 100.0 1.7 91.1 100.0 65.7 93.0 2.6 90.8 X2 200 100.0 0.8 76.4 98.9 0.0 0.0 0.0 0.0 100.0 0.7 86.1 100.0 0.0 0.0 0.0 0.0 100.0 8.2 83.3 98.6 72.1 85.5 0.0 86.4 100.0 2.9 96.1 100.0 65.9 91.7 0.0 88.8 X3 200 100.0 0.8 70.8 99.8 0.0 0.0 0.0 0.0 100.0 0.4 85.7 100.0 0.0 0.0 0.0 0.0 100.0 7.4 66.1 98.6 64.8 84.7 0.0 82.4 100.0 4.3 89.8 100.0 65.2 91.5 0.0 88.7 X4 200 100.0 1.1 76.8 99.0 0.0 0.0 0.0 0.0 100.0 0.5 85.5 100.0 0.0 0.0 0.0 0.0 100.0 2.4 60.7 98.5 58.1 49.9 0.0 89.5 100.0 1.9 86.6 100.0 61.2 53.3 0.0 92.0 X5 200 100.0 1.3 74.0 99.8 0.0 0.0 0.0 0.0 100.0 0.5 86.6 100.0 0.0 0.0 0.0 0.0 99.0 18.9 68.5 98.9 88.0 99.1 0.0 92.1 100.0 24.2 83.4 100.0 80.7 99.6 0.0 95.6 mit alternativen Lagerplätzen ohne alternative Lagerplätze 58 S1 25 46.9 49.2 49.4 45.6 - - - 1.0 40.4 41.9 55.7 49.5 - - - 3.1 54.3 39.1 71.9 76.9 - - - 47.1 48.5 32.3 76.1 78.7 - - - 50.1 S2 25 44.0 46.1 60.8 37.2 - - - 3.3 33.2 32.6 71.7 42.5 - - - 0.6 52.9 32.1 77.9 72.0 - - - 45.8 42.8 29.0 79.9 74.1 - - - 48.6 S3 25 100.0 6.9 77.3 67.6 - - - 0.0 100.0 7.8 75.9 65.6 - - - 0.0 100.0 8.7 76.2 88.7 - - - 34.0 100.0 6.5 80.4 86.8 - - - 39.3 S4 25 100.0 15.6 71.6 58.2 - - - 4.0 93.4 16.0 77.0 53.5 - - - 0.0 100.0 10.1 74.7 82.9 - - - 36.7 94.3 17.8 75.8 82.1 - - - 51.1 S5 25 67.5 38.6 44.3 55.9 - - - 0.0 48.9 40.0 62.4 41.6 - - - 0.0 71.5 33.6 66.0 80.5 - - - 40.0 55.8 31.6 75.2 77.0 - - - 42.8 M1 50 100.0 2.3 47.2 96.0 - - - 0.0 100.0 1.5 43.6 97.1 - - - 0.0 100.0 2.7 69.6 97.1 - - - 14.8 100.0 0.3 65.9 97.4 - - - 28.9 M2 50 100.0 2.4 54.5 95.6 - - - 0.0 100.0 1.4 57.4 96.3 - - - 0.0 100.0 3.9 72.7 97.1 - - - 20.2 100.0 1.5 68.6 97.8 - - - 34.0 M3 50 100.0 2.2 62.3 94.7 - - - 0.0 100.0 1.3 63.5 95.7 - - - 0.0 100.0 3.7 74.5 96.9 - - - 31.3 100.0 0.7 75.5 97.4 - - - 40.6 M4 50 100.0 2.1 57.1 94.5 - - - 0.0 100.0 1.3 51.7 96.1 - - - 0.0 100.0 1.5 75.2 96.6 - - - 23.3 100.0 1.6 71.3 97.4 - - - 34.6 M5 50 100.0 2.1 57.5 95.0 - - - 0.0 100.0 1.7 60.5 96.1 - - - 0.0 100.0 4.3 73.5 97.1 - - - 22.4 100.0 0.9 69.8 97.6 - - - 35.6 L1 100 100.0 2.2 48.7 96.2 - - - 0.0 100.0 1.7 51.6 99.5 - - - 0.0 100.0 3.8 75.4 96.0 - - - 15.4 100.0 2.1 73.2 98.5 - - - 55.4 L2 100 100.0 2.9 47.7 97.3 - - - 0.0 100.0 1.1 57.8 99.5 - - - 0.0 100.0 3.7 79.2 97.1 - - - 32.7 100.0 2.7 78.0 98.5 - - - 55.9 L3 100 100.0 2.6 54.6 96.3 - - - 0.0 100.0 1.4 59.2 99.3 - - - 0.0 100.0 3.1 78.8 96.5 - - - 30.7 100.0 0.8 86.7 98.2 - - - 58.4 L4 100 100.0 2.7 50.8 96.0 - - - 0.0 100.0 1.4 51.2 99.8 - - - 0.0 100.0 2.3 77.8 97.0 - - - 19.8 100.0 1.4 73.8 99.0 - - - 62.2 L5 100 100.0 3.1 53.1 96.5 - - - 0.0 100.0 1.3 57.8 99.2 - - - 0.0 100.0 1.4 71.9 97.0 - - - 34.0 100.0 2.0 75.3 98.8 - - - 63.0 X1 200 100.0 1.1 74.9 100.0 - - - 0.0 100.0 0.7 86.1 100.0 - - - 0.0 100.0 5.7 81.4 98.6 - - - 69.2 100.0 3.3 95.2 100.0 - - - 94.9 X2 200 100.0 0.9 78.4 99.4 - - - 0.0 100.0 0.5 86.2 100.0 - - - 0.0 100.0 1.8 84.5 98.7 - - - 79.8 100.0 3.7 94.9 100.0 - - - 91.5 X3 200 100.0 0.9 74.5 99.6 - - - 0.0 100.0 0.5 87.8 100.0 - - - 0.0 100.0 2.9 74.1 98.7 - - - 77.5 100.0 6.0 95.7 100.0 - - - 97.4 X4 200 100.0 1.1 76.2 99.4 - - - 0.0 100.0 0.4 85.5 100.0 - - - 0.0 100.0 3.9 84.1 98.3 - - - 69.9 100.0 2.5 90.6 100.0 - - - 90.7 X5 200 100.0 1.1 73.0 99.9 - - - 0.0 100.0 0.5 85.7 100.0 - - - 0.0 100.0 6.1 74.6 99.0 - - - 81.2 100.0 1.9 92.7 100.0 - - - 91.4 8.4 Rechenzeit der Nachbarschaften 8.5: - Durchschnittswerte über 20 Testläufe mit 25, 50, 100 und 200 einzusammelnden Artikeln. Zu sehen ist der prozentuelle Anteil (alle Werte in Prozent [%]) an Rechenzeit jeweiligen Nachbarschaft in Relation zur Rechenzeit für alle Nachbarschaften für Instanzen ohauf alternativen Lagerplätzen bei Berechnung innerhalb eines und In Ar Testlauf 1 Testlauf 2 S1 25 1.1 3.0 9.2 11.2 0.2 0.1 0.1 75.1 0.4 1.0 3.5 3.1 0.1 0.1 22.9 0.1 0.1 4.2 18.3 46.3 S2 25 1.2 2.7 7.8 11.6 0.2 0.1 0.1 76.4 0.4 0.9 3.3 3.7 0.1 0.0 23.1 0.1 0.1 5.1 18.5 44.7 S3 25 0.6 5.0 9.3 7.7 0.2 0.1 0.1 77.1 0.3 1.2 3.2 2.2 0.1 0.0 17.3 0.1 0.1 2.7 8.5 64.2 S4 25 0.7 5.5 11.4 9.0 0.2 0.1 0.1 73.0 0.2 1.4 3.8 2.5 0.1 0.0 17.6 0.1 0.1 2.8 8.1 63.3 S5 25 0.9 3.6 9.4 10.0 0.2 0.1 0.1 75.9 0.3 1.1 3.5 3.4 0.1 0.0 22.2 0.1 0.1 3.5 11.0 54.7 M1 50 0.4 3.9 16.1 9.6 0.1 0.0 0.0 69.8 0.2 0.6 2.2 1.7 0.0 0.0 7.8 0.1 0.0 1.3 2.8 83.2 M2 50 0.4 4.1 16.1 8.8 0.1 0.0 0.0 70.5 0.2 0.6 2.1 2.1 0.0 0.0 8.0 0.1 0.0 1.2 2.6 83.0 M3 50 0.4 4.3 16.0 10.0 0.2 0.1 0.1 69.0 0.2 0.7 2.6 2.4 0.0 0.0 7.3 0.1 0.1 1.7 3.4 81.4 M4 50 0.5 4.2 16.1 9.7 0.1 0.1 0.1 69.3 0.2 0.7 2.4 2.0 0.0 0.0 8.4 0.1 0.0 1.3 3.7 81.2 M5 50 0.5 4.1 16.7 9.3 0.2 0.1 0.0 69.1 0.2 0.7 2.1 2.1 0.0 0.0 8.1 0.1 0.1 1.4 2.3 83.0 L1 100 0.6 6.3 24.6 20.7 0.1 0.0 0.0 47.7 0.1 0.4 1.4 3.5 0.0 0.0 3.0 0.0 0.0 0.4 3.9 87.2 L2 100 0.5 3.9 22.3 23.7 0.1 0.1 0.1 49.3 0.1 0.4 0.7 2.3 0.0 0.0 3.0 0.0 0.0 0.4 2.8 90.3 L3 100 0.7 4.2 17.0 27.0 0.1 0.1 0.0 50.8 0.1 0.3 0.8 2.7 0.0 0.0 2.4 0.0 0.0 0.3 2.6 90.7 L4 100 0.5 4.0 25.3 20.4 0.1 0.0 0.0 49.6 0.1 0.3 0.8 2.6 0.0 0.0 2.4 0.0 0.0 0.3 3.1 90.3 L5 100 0.7 8.0 24.8 22.5 0.1 0.1 0.1 43.8 0.1 0.4 0.8 3.1 0.0 0.0 2.6 0.0 0.0 0.3 3.9 88.8 X1 200 2.1 6.8 27.2 39.1 0.1 0.1 0.1 24.4 0.1 0.4 0.5 1.6 0.0 0.0 0.8 0.0 0.0 0.1 1.4 95.0 X2 200 1.9 7.2 25.5 35.1 0.1 0.1 0.1 30.0 0.1 0.4 0.8 5.5 0.1 0.1 1.5 0.0 0.0 0.2 2.3 88.8 X3 200 1.9 7.6 30.7 41.7 0.1 0.1 0.1 17.8 0.1 0.3 0.6 2.5 0.0 0.0 1.0 0.0 0.0 0.1 2.3 92.9 X4 200 1.4 6.2 36.5 28.1 0.1 0.1 0.1 27.5 0.2 0.4 0.7 5.2 0.0 0.0 1.3 0.0 0.0 0.2 1.9 90.0 X5 200 1.8 6.8 31.8 28.9 0.1 0.1 0.1 30.4 0.1 0.4 0.8 5.0 0.0 0.0 1.8 0.0 0.0 0.2 3.5 88.1 S1 25 1.5 3.7 12.7 14.0 0.3 1.3 1.1 65.5 0.4 0.9 3.8 3.5 0.3 0.3 19.2 0.1 0.1 4.0 18.3 49.0 S2 25 1.6 3.5 10.6 16.1 0.4 1.4 1.1 65.3 0.4 0.9 3.7 3.3 0.4 0.3 18.0 0.1 0.1 4.9 16.7 51.1 S3 25 0.6 5.1 10.1 7.2 0.3 0.1 0.1 76.5 0.2 1.3 3.3 2.1 0.1 0.0 17.5 0.1 0.1 2.8 9.0 63.3 S4 25 0.7 5.5 11.0 8.8 0.3 0.1 0.1 73.4 0.2 1.3 3.8 2.3 0.1 0.0 17.4 0.1 0.1 2.7 8.2 63.8 S5 25 1.5 5.7 15.0 16.1 0.5 3.0 3.0 55.1 0.3 1.0 3.7 3.0 0.5 0.5 14.5 0.1 0.1 3.4 9.1 63.7 M1 50 0.4 4.4 17.4 10.9 0.4 2.0 2.9 61.6 0.2 0.6 2.7 2.0 0.2 0.4 6.7 0.1 0.1 1.0 3.7 82.5 M2 50 0.4 4.0 15.3 9.1 0.1 0.0 0.0 71.0 0.2 0.6 1.9 1.8 0.0 0.0 7.5 0.0 0.0 1.1 3.2 83.7 M3 50 0.9 5.0 20.3 12.5 0.4 1.5 2.3 57.1 0.2 0.7 2.9 2.2 0.2 0.3 6.6 0.1 0.1 1.3 3.5 82.1 M4 50 0.7 4.5 20.6 10.6 0.3 1.7 2.1 59.5 0.2 0.7 2.7 2.0 0.2 0.3 6.7 0.1 0.1 1.1 4.9 81.2 M5 50 0.7 4.9 20.6 12.3 0.3 0.6 0.7 60.0 0.2 0.7 2.7 1.9 0.1 0.1 6.4 0.1 0.0 1.1 2.0 84.6 L1 100 0.6 4.3 21.1 26.1 0.4 1.3 3.2 42.9 0.1 0.3 1.4 2.7 0.1 0.2 1.4 0.0 0.0 0.3 4.2 89.2 L2 100 0.6 4.4 18.9 24.8 0.3 1.0 2.0 47.9 0.1 0.4 1.6 3.0 0.1 0.2 1.8 0.0 0.0 0.3 4.2 88.2 L3 100 0.5 8.6 16.0 31.0 0.5 2.9 4.1 36.5 0.1 0.4 1.3 5.0 0.1 0.3 2.6 0.0 0.0 0.3 3.6 86.2 L4 100 0.7 6.0 29.7 27.7 0.3 2.5 2.9 30.2 0.1 0.4 1.5 3.9 0.1 0.2 1.7 0.0 0.0 0.3 4.2 87.4 L5 100 0.9 4.0 24.0 24.9 0.2 1.0 1.4 43.6 0.1 0.3 1.6 3.1 0.1 0.1 1.7 0.0 0.0 0.3 3.5 89.1 X1 200 0.9 5.7 33.0 36.2 0.6 2.1 6.2 15.3 0.1 0.7 1.2 6.4 0.1 0.5 1.3 0.0 0.0 0.4 3.6 85.6 X2 200 1.1 7.0 25.0 33.3 0.7 3.6 6.9 22.4 0.2 0.2 0.8 3.6 0.2 0.4 0.7 0.0 0.0 0.3 2.3 91.3 X3 200 1.1 5.4 38.7 25.0 0.6 2.5 6.3 20.5 0.1 0.2 0.6 3.2 0.1 0.3 0.6 0.0 0.0 0.3 2.4 92.1 X4 200 1.0 5.3 40.2 32.2 0.5 2.4 3.3 15.0 0.2 0.4 1.3 6.1 0.1 0.2 0.7 0.0 0.0 0.2 3.4 87.5 X5 200 0.9 4.8 49.3 21.7 0.6 2.0 12.1 8.6 0.1 0.3 0.8 0.9 0.1 0.6 0.3 0.0 0.0 0.3 2.4 94.2 ohne alternative Lagerplätze mit alternativen Lagerplätzen 59 8 Testergebnisse strukturen durchaus vertretbar ist. Bei statischer Nachbarschaftsreihenfolge hingegen macht die Verwendung dieser Nachbarschaft keinen Sinn und sollte ausgelassen wer- Wie intuitiv außerdem zu erwarten war, benötigen mehr Aufwand zum Durchsuchen, als die übrigen Nachbarschaften. Sind es bei kleinen Instanzen noch je etwa 10% der Rechenzeiten, so steigt der Anteil für große Instanzen auf 30–40% an. 8.5 Laufzeit und Lösungsverbesserung Ein wesentlicher Aspekt des entwickelten Algorithmus ist das Auffinden von guten Lösungen innerhalb möglichst kurzer Zeit, da im Echtbetrieb nicht uneingeschränkt viel Zeit zur Verfügung stehen kann. Aus diesem Grund ist eine Visualisierung des Verlaufs der Lösungsverbesserung durchaus interessant, was anhand von Instanz M3 bei Berechnung mit alternativen Lagerplätzen und dynamischer Nachbarschaftsreihenfolge in Abb. 8.1 dargestellt wird. Es ist dabei eindeutig zu erkennen, dass innerhalb der ersten 100 Iterationen des VND bereits eine sehr gute Lösung erreicht wird, welche im weiteren Verlauf zwar noch geringfügig verbessert wird, aber nicht mehr in so hohem Maß wie zu Beginn. Es sollte darauf hingewiesen werden, dass die Verbesserungen innerhalb der zweiten 100 Iterationen bei weitem nicht so gravierend sind, da hier die veränderte Skalierung der y-Achse für die Tourlänge zwischen 0 und 50000 beachtet werden muss. Dieses Verhalten ist äußerst günstig für die Verwendung im realen Umfeld, wo vor allem schnelle Antwortzeiten von Bedeutung sind. In manchen Fällen wird es dort nötig sein, schon nach kurzer Zeit den Algorithmus abzubrechen und die bis dahin vorliegende Lösung zu verwenden. 8.6 Lösungsqualität bei Verwendung zusätzlicher Nachbarschaften Um das Verhalten des Algorithmus bei der Verwendung zusätzlicher Nachbarschaften beobachten zu können, wurde ein weiterer Testlauf durchgeführt, der unter den gleichen Voraussetzungen wie der in Kapitel 8.2 beschriebene durchgeführt wurde. Hierbei wurde allerdings nur mehr mit dynamischer Nachbarschaftsreihenfolge gerechnet, es kamen aber weitere Nachbarschaften zum Einsatz. Verwendet wurden hier neben Diese Auflistung entspricht wieder gleichzeitig der Anfangsreihenfolge der Nachbarschaften. wurde da diese bereits durch abgedeckt ist. 60 Tourlänge gesamt</abstract>
<address confidence="0.964659133333333">2000000 1800000 1600000 1400000 1200000 1000000 400000 200000 800000 600000 40000 20000 50000 30000 10000</address>
<note confidence="0.932045909090909">0 8.6 Lösungsqualität bei Verwendung zusätzlicher Nachbarschaften Tourlänge Verbesserungen 200 40 20 80 60 0 180 160 140 120 100 Anzahl der Verbesserungen 0 100 200 300 400 500 600 700 Iterationen Abbildung 8.1: Verlauf der Zielfunktion im Vergleich zur Anzahl der gefundenen Verbesserungen (Achtung: Unterschiedliche Skalierung der y-Achse für [0; 50000] und (50000; 2000000]) 61</note>
<abstract confidence="0.959698042553192">8 Testergebnisse In Tab. 8.2 und Tab. 8.3 sind die in diesem Test (Testlauf 2) erzielten Ergebnisse und Laufzeiten des Algorithmus zu sehen. Diese Tabellen enthalten auch die Ergebnisse aus Testlauf 1, was die Gegenüberstellung erleichtert. Es ist zu erkennen, dass von allen berechneten 80 Instanzen nur 11 nicht besser gelöst werden konnten und die Summe aller Zielfunktionswerte bei Instanzen ohne Umkehren innerhalb von Gängen um rund 20% und bei Instanzen mit Umkehren sogar um etwa 22% verbessert werden konnte. Gleichzeitig muss aber auch gesagt werden, dass die Berechnungen zum Teil mehr als die doppelte Laufzeit bei kleineren Instanzen benötigten. Dennoch konnten auch die Zielfunktionswerte großer Instanzen, deren Bearbeitung nach dem Grenzwert von 1200 Sekunden abgebrochen wurde, in derselben Zeit wie im vorigen Testlauf deutlich verbessert werden. Die Auswertung der Effizienz der Nachbarschaften in Tab. 8.6 zeigt ein ähnliches Bild, wie in Tab. 8.4. Zur besseren Übersicht wurden nur die Werte für Berechnungen mit Umkehren innerhalb eines Ganges herangezogen. Zusätzlich ist hier ersichtlich, dass neu hinzugekommenen Nachbarschaften eine durchwegs hohe Verbesserungsquote aufweisen. Die Rechenzeiten aus Testlauf 2, wie in Tab. 8.5 zu sehen ist, weisen Parallelen zu den in Testlauf 1 erhaltenen Werten auf. Im Wesentlichen bestätigt das Ergebnis die bereits zuvor ermittelten Zahlen, wobei es zu leichten Verschiebungen gekommen ist, da die neu hinzugefügten Strukturen mit Kombinationen aus zuvor einzeln angewandten arbeiten. Hier sind die Berechnungen für kombinierte und damit komplexere Strukturen natürlich auch aufwändiger, aufgrund des Erfolgs ist deren Anwendung aber Besonders auffällig ist der hohe Rechenaufwand für SplitMergeComwo im Vergleich dazu im vorangegangenen Testlauf größten Anteil an Rechenzeit benötigte. Es hat sich also gezeigt, dass die neu eingebundenen Nachbarschaftsstrukturen ein durchwegs positives Resultat bringen und die Lösung tatsächlich verbessern konnten. Teilweise konnten die Zielfunktionswerte sogar um 50% verringert werden und nur in wenigen Fällen wurden geringfügig schlechtere Ergebnisse erzielt, als beim vorherigen Testlauf. Abschließend ist zu den Testergebnissen zu sagen, dass durchwegs positive Resultate werden konnten. Auch im Vergleich zur Lösung mittels konnten mehrheitlich bessere Werte berechnet werden. Zusätzlich dazu sollte noch darauf hingewiesen werden, dass unter der Verwendung der keine Nebenbedingungen, wie etwa Kollisionen zwischen Arbeitern, geprüft werden konnten. Es wurde damit lediglich eine Referenzlösung erzeugt. Es bleibt nun noch zu erwähnen, dass die hiermit geschilderten Beobachtungen darauf schließen lassen, dass weitere Verbesserungen etwa in Zusammenhang mit Anpassungen der Nachbarschaftsstrukturen durchaus möglich sind. In jedem Fall bietet sich ein Einsatz im Echtbetrieb an, um die Leistungsfähigkeit des entwickelten Ansatzes unter realen Bedingungen zu ermitteln. 62 8.6 Lösungsqualität bei Verwendung zusätzlicher Nachbarschaften 8.6: der Nachbarschaften in Testlauf 2 auf alternativen Lagerplätzen - Durchschnittswerte über 20 Testläufe mit 25, 50, 100 und 200 einzusammelnden Artikeln (Ar). Angeführt ist pro Nachbarschaft der prozentuelle Anteil (alle Werte in Prozent [%]) an erfolgreichen Schritten in Relation zu den insgesamt getesteten Schritten der jeweiligen Nachbar- Getestet wurden die Instanzen (In) auf alternativen Lagerplätzen bei innerhalb eines Ganges und bei Nachbarschaftsreihenfol- Testlauf 2 / dynamische Reihenfolge / mit Umkehren In Ar S1 25 22.4 26.4 63.7 79.5 - - 48.5 18.2 12.6 72.9 15.6 56.2 S2 25 21.3 28.3 67.5 73.7 - - 50.9 15.5 9.5 68.4 21.2 62.4 S3 25 95.2 14.0 65.0 79.7 - - 39.5 52.6 56.0 76.2 23.8 42.1 S4 25 86.2 15.1 62.2 75.3 - - 47.0 52.3 37.1 78.3 21.6 45.4 S5 25 27.1 27.4 63.9 69.5 - - 41.9 16.8 15.9 73.8 17.6 53.3 M1 50 100.0 0.7 71.4 95.6 - - 43.1 79.2 56.3 72.0 70.3 31.8 M2 50 100.0 0.6 79.1 94.9 - - 47.6 78.7 53.3 76.7 79.0 42.0 M3 50 100.0 1.5 77.8 93.7 - - 57.1 78.3 75.4 66.4 73.0 48.8 M4 50 100.0 0.3 75.4 94.3 - - 44.3 81.9 60.0 75.8 66.0 44.5 M5 50 100.0 0.2 77.4 94.6 - - 45.8 81.9 57.8 70.2 82.3 42.7 L1 100 100.0 2.3 89.7 95.9 - - 72.0 76.6 54.5 90.9 42.1 45.8 L2 100 100.0 3.5 95.5 97.5 - - 70.6 75.8 53.9 89.4 51.5 32.1 L3 100 100.0 0.1 94.3 96.6 - - 77.5 74.7 70.2 93.3 53.2 33.9 L4 100 100.0 0.1 95.1 96.9 - - 73.5 73.8 48.9 93.4 46.0 27.5 L5 100 100.0 1.1 95.8 96.3 - - 74.3 76.3 61.0 93.5 36.2 39.4 X1 200 100.0 4.2 99.1 100.0 - - 98.1 67.4 44.8 98.9 77.9 64.7 X2 200 100.0 4.2 99.2 99.3 - - 88.7 71.0 41.2 97.4 62.3 69.5 X3 200 100.0 2.1 99.2 99.9 - - 93.1 68.2 41.6 98.1 57.7 61.6 X4 200 100.0 6.3 99.3 99.4 - - 93.6 66.9 49.6 98.5 74.7 73.8 X5 200 100.0 2.1 99.0 100.0 - - 90.3 66.7 49.1 97.9 56.0 78.0 S1 25 18.3 26.4 58.7 73.7 34.7 0.0 50.6 13.6 9.5 74.4 9.8 62.7 S2 25 20.9 30.3 63.0 76.0 32.6 0.0 58.8 13.5 10.0 69.7 16.2 63.3 S3 25 95.4 13.3 62.7 79.4 0.0 0.0 38.6 63.5 54.7 75.6 18.3 42.4 S4 25 92.6 17.9 61.0 76.4 0.0 0.0 46.6 45.9 46.2 77.9 12.8 42.6 S5 25 27.7 31.0 63.4 72.5 46.5 0.0 46.3 15.6 12.9 75.0 18.6 58.7 M1 50 100.0 0.2 65.8 94.0 83.8 0.0 52.8 70.9 68.6 80.7 60.0 33.9 M2 50 100.0 0.4 80.5 94.3 0.0 0.0 44.1 78.6 66.7 76.5 70.2 33.7 M3 50 100.0 1.8 72.4 93.4 82.1 0.0 63.1 64.7 69.3 77.5 70.4 47.4 M4 50 100.0 1.0 70.0 94.9 81.4 0.0 55.8 71.2 69.5 78.5 49.4 39.8 M5 50 100.0 0.4 71.9 95.2 49.6 0.0 61.0 70.0 74.5 80.7 86.7 39.5 L1 100 100.0 0.2 89.5 97.7 91.2 0.0 90.6 73.4 58.1 94.4 39.6 38.3 L2 100 100.0 0.8 87.8 96.8 90.3 0.0 85.3 69.5 52.6 91.7 32.1 36.5 L3 100 100.0 0.0 92.1 93.4 94.0 0.0 72.8 76.3 63.8 95.8 50.0 47.7 L4 100 100.0 0.0 90.7 96.3 86.2 0.0 89.8 68.2 57.3 95.5 40.8 42.4 L5 100 100.0 0.0 88.4 96.5 77.2 0.0 87.1 67.9 50.1 95.0 43.3 33.7 X1 200 100.0 10.0 98.0 100.0 96.9 0.0 88.6 63.1 41.2 96.0 56.6 82.3 X2 200 97.5 2.7 99.1 99.4 94.3 0.0 94.8 62.6 42.1 91.2 56.9 66.1 X3 200 100.0 7.4 99.3 100.0 96.6 0.0 95.3 66.9 32.3 97.9 60.8 70.1 X4 200 100.0 0.0 98.1 100.0 78.2 0.0 97.3 63.6 43.6 98.3 47.7 73.2 X5 200 100.0 32.7 97.9 100.0 99.4 0.0 99.0 21.9 21.1 94.4 56.7 63.4 63 ohne alternative Lagerplätze mit alternativen Lagerplätzen 64 9 Fazit Inhalt dieser Arbeit war die Vorstellung eines hybriden Verfahrens, welches zum Lösen von Problemen der Tourenplanung im Echtbetrieb eines Ersatzteillagers einwerden kann. Das Grundgerüst bildet dabei eine Nachbarschaftsintegriertem Neighborhood Descent als lokale Verbesserungsstrategie. Zum Lösen von Teilproblemen innerhalb dieses Algorithmus wird ein eigens entwickeltes Dynamisches Programm verwendet, mit dessen Hilfe es möglich ist, konkrete Touren optimal in polynomieller Zeit abhängig von der Anzahl der bestellten Artikel zu berechnen. Um abschließend eine Zuweisung von Lagerarbeitern zu den im vorhergehenden Schritt berechneten Touren zu berechnen, wird eine zweite VNS verwendet. Aus den präsentierten Ergebnissen der Tests lässt sich ableiten, dass der gefundene Ansatz prinzipiell funktionstüchtig ist und schnell akzeptable Lösungen erzeugt. Sind die Arbeiter des Lagers erst einmal damit beschäftigt den ersten ihnen zugewiesenen Artikel auszufassen, kann die Gesamtlösung weiter optimiert werden. Dies ist möglich, da zu jedem Zeitpunkt eine gültige Lösung verfügbar ist. Von Bedeutung ist dies eventuell auch, wenn eine Erweiterung des Verfahrens zu einem Online- Algorithmus durchgeführt wird. Als solcher muss dieser auf laufend hinzukommende und im Vorhinein nicht bekannte Bestellungen reagieren können. Die Adaptierung von bereits ausgegebenen Touren würde in so einem Algorithmus einen wesentlichen Beitrag zur Flexibilität liefern. Dadurch, dass viele der zu liefernden Artikel erst im Laufe des Tages bestellt werden und zwischen den einzelnen Ausfassungsoperationen der Lagerarbeiter entsprechend viel Berechnungszeit zur Verfügung steht, wird die kontinuierliche Verbesserung einer anfangs schnell generierten Lösung möglich. Weiters scheint eine Aufteilung des Lagers in örtlich voneinander getrennte Bereiche, basierend auf der Lage der Verpackungszone, sinnvoll, wodurch die Größe der so entstehenden (Teil-)Instanzen entsprechend gering ist. Obwohl die in dieser Arbeit präsentierten Testergebnisse implizieren, dass die Größe der tatsächlichen Instanzen mit bis zu 5000 bestellten Artikeln pro Tag zu komist, kann man vermuten, dass nach weiterer und Erweiterung der Nachbarschaftsstrukturen oder Anpassungen der Durchsuchungsstrategie die Ergebnisse weiter verbessert und selbst Instanzen von solcher Größe qualitativ hochwertig gelöst werden können. Leider war es im Rahmen dieser Arbeit nicht möglich, die Auswirkungen von unvorhergesehenen Vorkommnissen (ein Artikel ist nicht in gewünschter Menge verfügbar, 65 9 Fazit Verspätung eines Arbeiters auf seiner Tour, etc.) aussagekräftig zu testen, da aufgrund des erst neu eingeführten Verwaltungssystems die Testdaten nicht dem Echtbetrieb entnommen werden konnten. Daher musste versucht werden, beim Generieren der Testdaten alle bekannten Aspekte und Eigenschaften der Lagerstruktur bestmöglichst zu berücksichtigen. Anzumerken ist noch, dass die Methode zum Berechnen von optimalen Kommissionierungstouren teilweise auf der Annahme basiert, dass ein Mitarbeiter in einem Gang jederzeit umdrehen kann. Je nach Beschaffenheit des Lagers und der verwendeten Fahrzeuge kann es durchaus vorkommen, dass eine solche Richtungsänderung nicht, beziehungsweise nur schwer möglich ist. Sollte dies der Fall sein, kann das Dynamische Programm einfach angepasst werden. Die grundlegende Struktur des Ansatzes ändert sich dadurch nicht. Im Rahmen der Tests hat sich gezeigt, dass die gefundenen Lösungen im Vergleich zu ebenfalls berechneten Referenzlösungen von guter Qualität sind und zusätzlich dazu alle Nebenbedingungen erfüllt werden konnten. Aber auch die Laufzeit des Verfahrens und vor allem die raschen Verbesserungen zu Beginn eines Durchlaufs vermitteln einen positiven Eindruck. In Hinblick auf eine Beschleunigung des Algorithmus gäbe es die Möglichkeit auf die Berechnung exakter Touren zu verzichten. Natürlich würde man in diesem Fall zwar Geschwindigkeit gewinnen können, müßte aber bei der Lösungsqualität Einbu- ßen hinnehmen. Auch ein nochmaliges Überarbeiten der Nachbarschaftsstrukturen könnte die eine oder andere Verbesserung bringen. Es sollte aber erwähnt werden, dass der präsentierte Ansatz bereits mit stabilem Verhalten und vielversprechender Leistung überzeugen kann. Als Fazit lässt sich sagen, dass der Einsatz eines computerunterstützten Entscheidungssystems zur Planung von Kommissionierungstouren durchaus sinnvoll scheint, wenngleich aufgrund der Problemkomplexität auf eine besonders effiziente Implementierung geachtet werden muss. Besonders berücksichtigt werden muss dabei die Tatsache, dass dies ein System sein soll, dass darauf abzielt Menschen in gewisser Hinsicht Befehle zu erteilen, was einerseits soziale Schwierigkeiten mit sich bringt und andererseits aber auch bedeutet, dass Zustände erreicht werden können, die im Vorhinein nur schwer vorherzusehen sind. Das System sollte also nur als Entscheidungsunterstützung eingesetzt werden und kann die Kontrolle und Betreuung durch einen qualifizierten Lagerarbeiter nicht ersetzen. 66 Literaturverzeichnis D. L. Applegate, R. E. Bixby, V. Chvatal, and W. J. Cook. Traveling Salesman Problem: A Computational Study (Princeton Series in Applied Ma- Princeton University Press, January 2007. [2] C. Archetti, M. G. Speranza, and A. Hertz. A tabu search algorithm for the split vehicle routing problem. 40(1):64–73, 2006. R. E. Bellman. Dover Publications, Incorporated, 2003. [4] R. de Koster, T. Le-Duc, and K. J. Roodbergen. Design and control of warehouse picking: A literature review. Journal of Operational 182(2):481–501, 2007. [5] R. de Koster and E. Van Der Poort. Routing orderpickers in a warehouse: a combetween optimal and heuristic solutions. 30(5):469– 480, 1998. E. W. Dijkstra. A note on two problems in connexion with graphs. 1(1):269–271, Dezember 1959. M. Dror and P. Trudeau. Savings by split delivery routing. 23:141–145, 1989. M. Dror and P. Trudeau. Split delivery routing. Research 37:383–402, 1990. [9] C. Feremans, M. Labbe, and G. Laporte. Generalized network design problems.</abstract>
<note confidence="0.779929666666667">Journal of Operational 148(1):1–13, 2003. [10] M. Fischetti, J. J. Salazar Gonzalez, and P. Toth. The symmetric generalized salesman polytope. 26(2):113–123, 1995. [11] P. Hansen, N. Mladenovi´c, and L. C. D. Gerad. A tutorial on variable neighborhood search. Technical report, Les Cahiers du GERAD, HEC Montreal and GERAD, 2003. [12] P. Hansen and N. Mladenovi´c. Variable neighborhood search. In F. W. Glover G. A. Kochenberger, editors, of pages 145–184. Kluwer Academic Publisher, New York, 2003.</note>
<abstract confidence="0.797226809523809">[13] S. C. Ho and D. Haugland. A tabu search heuristic for the vehicle routing 67 LITERATURVERZEICHNIS with time windows and split deliveries. and Operations 31:1947–1964, 2004. [14] B. Hu and G. R. Raidl. Variable neighborhood descent with self-adaptive neighborhood-ordering. In C. Cotta, A. J. Fernandez, and J. E. Gallardo, editors, Proceedings of the 7th EU/MEeting on Adaptive, Self-Adaptive, and Multi-Level 2006. [15] J. Lysgaard, A. N. Letchford, and R. W. Eglese. A new branch-and-cut algofor the capacitated vehicle routing problem. 100(2):423–445, 2004. [16] N. Mladenovi´c. A variable neighborhood algorithm a new metaheuristic for optimization. of papers presented at Optimization page 112, 1995. [17] T. Ralphs, L. Kopman, W. Pulleyblank, and L. T. Jr. On the capacitated vehicle problem. Programming 94(B):1–19, 2003. P. Toth and D. Vigo. Vehicle Routing Monographs on Discrete Mathematics and Applications. SIAM, Philadelphia, 2002. [19] K. Q. Zhu, K. C. Tan, and L. H. Lee. Heuristics for vehicle routing problem time. In 6th AI and 2000.</abstract>
<intro confidence="0.712257">68</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<title>Abbildung 8.1: Verlauf der Zielfunktion im Vergleich zur Anzahl der gefundenen Verbesserungen (Achtung: Unterschiedliche Skalierung der y-Achse für [0; 50000] und (50000; 2000000]) 8.6 Lösungsqualität bei Verwendung zusätzlicher Nachbarschaften Tabelle 8.6: Effizienz der Nachbarschaften in Testlauf 2 ohne bzw. mit Artikeln auf alternativen Lagerplätzen - Durchschnittswerte über 20 Testläufe mit 25, 50, 100 und 200 einzusammelnden Artikeln (Ar). Angeführt ist pro Nachbarschaft der prozentuelle Anteil (alle Werte</title>
<booktitle>in Prozent [%]) an erfolgreichen Schritten in Relation zu den insgesamt getesteten Schritten der jeweiligen Nachbarschaft. Getestet wurden die Instanzen (In) ohne bzw. mit Artikeln auf alternativen Lagerplätzen bei Berechnung mit Umkehren innerhalb eines Ganges und bei dynamischer Nachbarschaftsreihenfolge. (N1: Split; N2: Merge; N3: Shift; N4: Swap; N5: SwapPosition; N6: SwapPositionMerge; N7: SplitPositionMerge; N8: DoubleShift; N9: ShiftSplit; N10: SwapSplit; N11: MultipleSwap; N12: MultipleSplit; N13: SplitMerge.)</booktitle>
<marker></marker>
<rawString> Abbildung 8.1: Verlauf der Zielfunktion im Vergleich zur Anzahl der gefundenen Verbesserungen (Achtung: Unterschiedliche Skalierung der y-Achse für [0; 50000] und (50000; 2000000]) 8.6 Lösungsqualität bei Verwendung zusätzlicher Nachbarschaften Tabelle 8.6: Effizienz der Nachbarschaften in Testlauf 2 ohne bzw. mit Artikeln auf alternativen Lagerplätzen - Durchschnittswerte über 20 Testläufe mit 25, 50, 100 und 200 einzusammelnden Artikeln (Ar). Angeführt ist pro Nachbarschaft der prozentuelle Anteil (alle Werte in Prozent [%]) an erfolgreichen Schritten in Relation zu den insgesamt getesteten Schritten der jeweiligen Nachbarschaft. Getestet wurden die Instanzen (In) ohne bzw. mit Artikeln auf alternativen Lagerplätzen bei Berechnung mit Umkehren innerhalb eines Ganges und bei dynamischer Nachbarschaftsreihenfolge. (N1: Split; N2: Merge; N3: Shift; N4: Swap; N5: SwapPosition; N6: SwapPositionMerge; N7: SplitPositionMerge; N8: DoubleShift; N9: ShiftSplit; N10: SwapSplit; N11: MultipleSwap; N12: MultipleSplit; N13: SplitMerge.)</rawString>
</citation>
<citation valid="true">
<authors>
<author>D L Applegate</author>
<author>R E Bixby</author>
<author>V Chvatal</author>
<author>W J Cook</author>
</authors>
<title>The Traveling Salesman Problem: A Computational Study (Princeton Series in Applied Mathematics).</title>
<date>2007</date>
<publisher>Princeton University Press,</publisher>
<contexts>
<context position="33015" citStr="[1]" startWordPosition="4603" endWordPosition="4603">kte in S ⊆ V haben. Je nachdem welche Randbedingungen definiert werden, entsteht ein entsprechendes konkretes Problem. 3.3 Traveling Salesman Problem Beim sogenannten Traveling Salesman Problem (TSP) [1] handelt es sich um ein weiteres kombinatorisches Optimierungsproblem, das in der Klasse der NP-vollständigen Probleme enthalten ist. Das Ziel hierbei ist es, alle vorhandenen Orte innerhalb einer Run</context>
</contexts>
<marker>[1]</marker>
<rawString>D. L. Applegate, R. E. Bixby, V. Chvatal, and W. J. Cook. The Traveling Salesman Problem: A Computational Study (Princeton Series in Applied Mathematics). Princeton University Press, January 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Archetti</author>
<author>M G Speranza</author>
<author>A Hertz</author>
</authors>
<title>A tabu search algorithm for the split delivery vehicle routing problem.</title>
<date>2006</date>
<journal>Transportation Science,</journal>
<volume>40</volume>
<issue>1</issue>
<contexts>
<context position="29089" citStr="[2]" startWordPosition="4001" endWordPosition="4001">wird dadurch allerdings nicht leichter. 4 5 3 2 1 6 Depot 12 7 9 8 11 10 10 3.1 Vehicle Routing Problem 3.1.2 Split Delivery Vehicle Routing Problem Das Split Delivery Vehicle Routing Problem (SDVRP) [2] beschreibt jene Form des VRP, bei der ein Kunde mehrmals angefahren werden darf oder sogar muss. Wieder sind mehrere Lieferanten im Einsatz und jedes Transportmittel hat die gleiche Kapazität. Nun ka</context>
</contexts>
<marker>[2]</marker>
<rawString>C. Archetti, M. G. Speranza, and A. Hertz. A tabu search algorithm for the split delivery vehicle routing problem. Transportation Science, 40(1):64–73, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R E Bellman</author>
</authors>
<title>Dynamic Programming.</title>
<date>2003</date>
<publisher>Dover Publications, Incorporated,</publisher>
<contexts>
<context position="38047" citStr="[3]" startWordPosition="5320" endWordPosition="5320">t man sich schrittweise anhand optimaler Teillösungen zur Lösung des Gesamtproblems vor. Der Ansatz der Dynamischen Programmierung basiert auf folgendem ursprünglich von Bellman formulierten Postulat [3]: ”Ein optimales Verfahren hat die Eigenschaft, dass, wie auch immer der Anfangszustand und die erste Entscheidung ausfielen, die folgenden Entscheidungen für eine optimale Lösung sich auf den Zustand</context>
</contexts>
<marker>[3]</marker>
<rawString>R. E. Bellman. Dynamic Programming. Dover Publications, Incorporated, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R de Koster</author>
<author>T Le-Duc</author>
<author>K J Roodbergen</author>
</authors>
<title>Design and control of warehouse order picking: A literature review.</title>
<date>2007</date>
<journal>European Journal of Operational Research,</journal>
<volume>182</volume>
<issue>2</issue>
<contexts>
<context position="36853" citStr="[4]" startWordPosition="5159" endWordPosition="5159">Ansatz besonders deshalb, da er später für Vergleiche zu dem in dieser Arbeit vorgestellten Verfahren herangezogen wird. Betrachtungen der S-Shape-Heuristik, sowie Varianten davon finden sich auch in [4], wo außerdem auf die Komplexität solcher Lagerabläufe hingewiesen wird und klar hervorgeht, dass entsprechende Probleme stets sehr speziell sind. Es gibt also kein Konzept und kein globales Optimieru</context>
<context position="99136" citStr="[4]" startWordPosition="14483" endWordPosition="14483">eten wurde. Natürlich werden Gänge, aus denen kein Artikel geholt werden muss, ausgelassen. Zur Veranschaulichung dieser Vorgehensweise soll Abb. 7.10 dienen. Laut den bereits referenzierten Arbeiten [4] sowie [5] kann man auf diese Weise Lösungen finden, die für viele Probleminstanzen nahe am Optimum liegen. Das ist der Grund dafür, weshalb diese Heuristik in Kombination mit TSH im Rahmen dieser Arb</context>
</contexts>
<marker>[4]</marker>
<rawString>R. de Koster, T. Le-Duc, and K. J. Roodbergen. Design and control of warehouse order picking: A literature review. European Journal of Operational Research, 182(2):481–501, 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R de Koster</author>
<author>E Van Der Poort</author>
</authors>
<title>Routing orderpickers in a warehouse: a comparison between optimal and heuristic solutions.</title>
<date>1998</date>
<journal>IIE Transactions,</journal>
<volume>30</volume>
<issue>5</issue>
<pages>480</pages>
<contexts>
<context position="36372" citStr="[5]" startWordPosition="5091" endWordPosition="5091"> Zusammenhang mit Warenlagern, deren Anordnung in klassischer rechteckiger Form vorliegt, ist auch das Aufsuchen von Touren ein interessantes Teilproblem im Zuge der Optimierung von Lagerabläufen. In [5] wird ein Verfahren, die sogenannte S-Shape-Heuristik, betrachtet, das der Erstellung solcher Touren dient. Dabei bewegen sich die Lagerarbeiter S-förmig durch das Lager, das heißt, dass ein Gang komp</context>
<context position="99146" citStr="[5]" startWordPosition="14485" endWordPosition="14485">. Natürlich werden Gänge, aus denen kein Artikel geholt werden muss, ausgelassen. Zur Veranschaulichung dieser Vorgehensweise soll Abb. 7.10 dienen. Laut den bereits referenzierten Arbeiten [4] sowie [5] kann man auf diese Weise Lösungen finden, die für viele Probleminstanzen nahe am Optimum liegen. Das ist der Grund dafür, weshalb diese Heuristik in Kombination mit TSH im Rahmen dieser Arbeit als Re</context>
</contexts>
<marker>[5]</marker>
<rawString>R. de Koster and E. Van Der Poort. Routing orderpickers in a warehouse: a comparison between optimal and heuristic solutions. IIE Transactions, 30(5):469– 480, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E W Dijkstra</author>
</authors>
<title>A note on two problems in connexion with graphs.</title>
<date>1959</date>
<journal>Numerische Mathematik,</journal>
<volume>1</volume>
<issue>1</issue>
<contexts>
<context position="39304" citStr="[6]" startWordPosition="5493" endWordPosition="5493">elnen Teilproblemen bestehen muss. Kürzeste Wege in einem Graphen Ein gutes Beispiel für Dynamische Programmierung bietet der Algorithmus für kürzeste Wege in einem Graphen, welcher 1959 von Dijkstra [6] vorgestellt wurde. Ge15 4 Dynamische Programmierung geben sei ein Graph G = (V, E), bestehend aus einer Menge V = {v1, v2, ... , vn} von Knoten und einer Menge E von Kanten. Weiters bezeichne eij ein</context>
</contexts>
<marker>[6]</marker>
<rawString>E. W. Dijkstra. A note on two problems in connexion with graphs. Numerische Mathematik, 1(1):269–271, Dezember 1959.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Dror</author>
<author>P Trudeau</author>
</authors>
<title>Savings by split delivery routing.</title>
<date>1989</date>
<journal>Transportation Science,</journal>
<volume>23</volume>
<contexts>
<context position="29557" citStr="[7]" startWordPosition="4069" endWordPosition="4069"> die Kapazität eines einzelnen Transportmittels übersteigt oder aber auch einfach aus Effizienzgründen zwei Lieferanten einen Kunden mit Teillieferungen beliefern. Wie bereits bei Dror und Trudeau in [7] und [8] gezeigt, können durch die Aufteilung von Lieferungen beträchtliche Einsparungen erzielt werden, sowie auch die Anzahl an Lieferanten reduziert werden. Dennoch bleibt das Problem an sich NP-sc</context>
<context position="30335" citStr="[7]" startWordPosition="4199" endWordPosition="4199">n die Anzahl an Kunden repräsentiert und cij die Kosten für den Weg von Kunde i zu Kunde j angibt. Es wird dabei angenommen, dass cij = cji gilt. Ein interessanter Aspekt der zuvor erwähnten Arbeiten [7] und [8] ist die Erkenntnis, dass es bei geltender Dreiecksungleichung eine optimale Lösung gibt, bei der je zwei Routen nie mehr als zwei gemeinsame Zielorte mit Teillieferungen anfahren. 3.1.3 Vehic</context>
</contexts>
<marker>[7]</marker>
<rawString>M. Dror and P. Trudeau. Savings by split delivery routing. Transportation Science, 23:141–145, 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Dror</author>
<author>P Trudeau</author>
</authors>
<title>Split delivery routing.</title>
<date>1990</date>
<journal>Naval Research Logistics,</journal>
<volume>37</volume>
<contexts>
<context position="29565" citStr="[8]" startWordPosition="4071" endWordPosition="4071">azität eines einzelnen Transportmittels übersteigt oder aber auch einfach aus Effizienzgründen zwei Lieferanten einen Kunden mit Teillieferungen beliefern. Wie bereits bei Dror und Trudeau in [7] und [8] gezeigt, können durch die Aufteilung von Lieferungen beträchtliche Einsparungen erzielt werden, sowie auch die Anzahl an Lieferanten reduziert werden. Dennoch bleibt das Problem an sich NP-schwer. Di</context>
<context position="30343" citStr="[8]" startWordPosition="4201" endWordPosition="4201">zahl an Kunden repräsentiert und cij die Kosten für den Weg von Kunde i zu Kunde j angibt. Es wird dabei angenommen, dass cij = cji gilt. Ein interessanter Aspekt der zuvor erwähnten Arbeiten [7] und [8] ist die Erkenntnis, dass es bei geltender Dreiecksungleichung eine optimale Lösung gibt, bei der je zwei Routen nie mehr als zwei gemeinsame Zielorte mit Teillieferungen anfahren. 3.1.3 Vehicle Routi</context>
</contexts>
<marker>[8]</marker>
<rawString>M. Dror and P. Trudeau. Split delivery routing. Naval Research Logistics, 37:383–402, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Feremans</author>
<author>M Labbe</author>
<author>G Laporte</author>
</authors>
<title>Generalized network design problems.</title>
<date>2003</date>
<journal>European Journal of Operational Research,</journal>
<volume>148</volume>
<issue>1</issue>
<contexts>
<context position="25808" citStr="[9]" startWordPosition="3519" endWordPosition="3519">ngungen, wie etwa die beschränkte Breite von Gängen, berücksichtigt. Neben der offensichtlichen Verwandtschaft mit Varianten des VRP, besteht auch eine Verbindung zu Generalisierten Netzwerkproblemen [9]. So kann die Möglichkeit einen Artikel von unterschiedlichen Lagerplätzen zu holen als implizite Clusterbildung verstanden werden. Jeweils nur ein Knoten aus einem solchen Cluster soll besucht werden</context>
</contexts>
<marker>[9]</marker>
<rawString>C. Feremans, M. Labbe, and G. Laporte. Generalized network design problems. European Journal of Operational Research, 148(1):1–13, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Fischetti</author>
<author>J J Salazar Gonzalez</author>
<author>P Toth</author>
</authors>
<title>The symmetric generalized traveling salesman polytope.</title>
<date>1995</date>
<journal>Networks,</journal>
<volume>26</volume>
<issue>2</issue>
<contexts>
<context position="26109" citStr="[10]" startWordPosition="3562" endWordPosition="3562"> Clusterbildung verstanden werden. Jeweils nur ein Knoten aus einem solchen Cluster soll besucht werden. Unter diesem Blickwinkel ist eine Verbindung zum Generalized Traveling Salesman Problem (GTSP) [10] offensichtlich, bei dem es gilt, jeweils einen Knoten pro Cluster auszuwählen und anschließend eine Tour zu berechnen, sodass jeder Cluster genau einmal besucht wird. Wie später genauer erklärt wird,</context>
<context position="34520" citStr="[10]" startWordPosition="4835" endWordPosition="4835">ng lösbar werden. Die Komplexität des Suchraumes unter 12 3.4 Bekannte Lösungsansätze Berücksichtigung der Anzahl n an Knoten im Graphen ist dabei in O(nn). Das Generalized Traveling Salesman Problem [10] behandelt die leicht abgeänderte Variante des eigentlichen Problems, welche alle zu besuchenden Orte in Gruppen einteilt und verlangt, dass genau ein Ort aus jeder Gruppe besucht werden muss. Welcher</context>
</contexts>
<marker>[10]</marker>
<rawString>M. Fischetti, J. J. Salazar Gonzalez, and P. Toth. The symmetric generalized traveling salesman polytope. Networks, 26(2):113–123, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Hansen</author>
<author>N Mladenovi´c</author>
<author>L C D Gerad</author>
</authors>
<title>A tutorial on variable neighborhood search.</title>
<date>2003</date>
<booktitle>Technical report, Les Cahiers du GERAD, HEC Montreal and GERAD,</booktitle>
<contexts>
<context position="41655" citStr="[11]" startWordPosition="5860" endWordPosition="5860">le Nachbarschaftssuche Variable Nachbarschaftssuche (VNS) ist eine vergleichsweise junge Metaheuristik, die ihren Ursprung um das Jahr 1995 hat, in dem sie erstmalig vorgestellt wurde (siehe [16] und [11]). Grundsätzlich kann ein Optimierungsproblem allgemein formuliert werden als min {f (x)|x E X, X C Z}. (5.1) Z, X, x und f bezeichnen dabei den Lösungsraum, die Menge der gültigen Lösungen, eine konk</context>
</contexts>
<marker>[11]</marker>
<rawString>P. Hansen, N. Mladenovi´c, and L. C. D. Gerad. A tutorial on variable neighborhood search. Technical report, Les Cahiers du GERAD, HEC Montreal and GERAD, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Hansen</author>
<author>N Mladenovi´c</author>
</authors>
<title>Variable neighborhood search.</title>
<date>2003</date>
<booktitle>Handbook of Metaheuristics,</booktitle>
<pages>145--184</pages>
<editor>In F. W. Glover and G. A. Kochenberger, editors,</editor>
<publisher>Kluwer Academic Publisher,</publisher>
<location>New York,</location>
<contexts>
<context position="26438" citStr="[12]" startWordPosition="3605" endWordPosition="3605">s jeder Cluster genau einmal besucht wird. Wie später genauer erklärt wird, basiert der hier vorgeschlagene Lösungsansatz auf Variabler Nachbarschaftssuche (engl.: Variable Neighborhood Search) (VNS) [12] mit integriertem Variable Neighborhood Descent (VND). Bei VNS/VND handelt es sich um Metaheuristiken, die auf der Idee aufbauen, dass ein globales Optimum stets ein lokales Optimum bezüglich aller mö</context>
<context position="43262" citStr="[12]" startWordPosition="6102" endWordPosition="6102">lt. Ein lokales Minimum x&apos; E X in Bezug auf Nk ist gegeben, wenn es keine Lösung x E Nk(x&apos;) C X mit f (x) &amp;lt; f (x&apos;) gibt. Die Variable Nachbarschaftssuche beruht auf folgenden drei einfachen Tatsachen [12]: (i) Ein lokales Minimum bezüglich einer Nachbarschaftsstruktur ist nicht notwendigerweise auch ein lokales Minimum bezüglich einer anderen. (ii) Ein globales Minimum muss gleichzeitig ein lokales Mi</context>
<context position="65681" citStr="[12]" startWordPosition="9366" endWordPosition="9366">ässlich sein mit Verbesserungsheuristiken weiterzuarbeiten. 7.2.2 Reparatur- und Verbesserungsheuristik Zentraler Bestandteil des Programms ist die Umsetzung einer Variablen Nachbarschaftssuche (VNS) [12] mit Verwendung des Variable Neighborhood Descent (VND) als lokale Verbesserungskomponente, welche sowohl als Reparatur- als auch als Ver30 7.2 Zuordnung von Artikeln zu Touren besserungsheuristik ein</context>
</contexts>
<marker>[12]</marker>
<rawString>P. Hansen and N. Mladenovi´c. Variable neighborhood search. In F. W. Glover and G. A. Kochenberger, editors, Handbook of Metaheuristics, pages 145–184. Kluwer Academic Publisher, New York, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S C Ho</author>
<author>D Haugland</author>
</authors>
<title>A tabu search heuristic for the vehicle routing LITERATURVERZEICHNIS problem with time windows and split deliveries.</title>
<date>2004</date>
<journal>Computers and Operations Research,</journal>
<volume>31</volume>
<contexts>
<context position="35606" citStr="[13]" startWordPosition="4985" endWordPosition="4985">llung bereits für kleine Probleminstanzen eine Vielzahl an möglichen Lösungen existiert, gleichzeitig aber kein Algorithmus bekannt ist, der in polynomieller Zeit eine optimale Lösung konstruiert. In [13] wird etwa beschrieben, wie mittels Tabu-Suche nach einer Lösung für ein SDVRP kombiniert mit einem VRPTW gesucht werden kann, für die die Anzahl der verwendeten Fahrzeuge sowie die Länge der insgesam</context>
</contexts>
<marker>[13]</marker>
<rawString>S. C. Ho and D. Haugland. A tabu search heuristic for the vehicle routing LITERATURVERZEICHNIS problem with time windows and split deliveries. Computers and Operations Research, 31:1947–1964, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Hu</author>
<author>G R Raidl</author>
</authors>
<title>Variable neighborhood descent with self-adaptive neighborhood-ordering.</title>
<date>2006</date>
<booktitle>Proceedings of the 7th EU/MEeting on Adaptive, Self-Adaptive, and Multi-Level Metaheuristics,</booktitle>
<editor>In C. Cotta, A. J. Fernandez, and J. E. Gallardo, editors,</editor>
<contexts>
<context position="80260" citStr="[14]" startWordPosition="11505" endWordPosition="11505">ktur durchaus auch Auswirkungen auf die Effizienz nachfolgender Nachbarschaftsstrukturen hat, ist diese Entscheidungsfindung nicht trivial. Aus diesem Grund wurde entschieden, eine Adaptierung der in [14] vorgestellten Methode zur dynamischen Reihung vorzunehmen. Im Folgenden gilt es stets eine Permutation λ = (λ1, ... , λk) der Nachbarschaftsstrukturen {N1, ... , Nk} zu berechnen, wobei der Nachbarsc</context>
<context position="81466" citStr="[14]" startWordPosition="11686" endWordPosition="11686">r größte, maxj=1,...,k wj, solcher Prädikate ist. Dann wird anhand der aufsteigenden Werte wi eine neue Reihenfolge bestimmt. Das Konzept ist in Alg. 7 ersichtlich, wobei eine kleine Anpassung zum in [14] vorgestellten Algorithmus durchgeführt wurde, um zu vermeiden, dass Nachbarschaften ausgelassen werden können. Das kann vorkommen, da dort vor jeder Umreihung gespeichert wird mit welcher Nachbarscha</context>
</contexts>
<marker>[14]</marker>
<rawString>B. Hu and G. R. Raidl. Variable neighborhood descent with self-adaptive neighborhood-ordering. In C. Cotta, A. J. Fernandez, and J. E. Gallardo, editors, Proceedings of the 7th EU/MEeting on Adaptive, Self-Adaptive, and Multi-Level Metaheuristics, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Lysgaard</author>
<author>A N Letchford</author>
<author>R W Eglese</author>
</authors>
<title>A new branch-and-cut algorithm for the capacitated vehicle routing problem.</title>
<date>2004</date>
<booktitle>Mathematical Programming,</booktitle>
<volume>100</volume>
<issue>2</issue>
<contexts>
<context position="36093" citStr="[15]" startWordPosition="5052" endWordPosition="5052">neare Optimierung (engl.: Integer Linear Programming) (ILP) und Branch &amp; Bound beziehungsweise Branch &amp; Cut werden häufig zur Lösung herangezogen. Ausgehend von einer ILP-Formulierung beschreibt etwa [15] einen solchen Ansatz zur Lösung von CVRP-Instanzen mittels Branch &amp; Cut. In Zusammenhang mit Warenlagern, deren Anordnung in klassischer rechteckiger Form vorliegt, ist auch das Aufsuchen von Touren </context>
</contexts>
<marker>[15]</marker>
<rawString>J. Lysgaard, A. N. Letchford, and R. W. Eglese. A new branch-and-cut algorithm for the capacitated vehicle routing problem. Mathematical Programming, 100(2):423–445, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Mladenovi´c</author>
</authors>
<title>A variable neighborhood algorithm - a new metaheuristic for combinatorial optimization. Abstracts of papers presented at Optimization Days,</title>
<date>1995</date>
<pages>112</pages>
<contexts>
<context position="41646" citStr="[16]" startWordPosition="5858" endWordPosition="5858"> 5 Variable Nachbarschaftssuche Variable Nachbarschaftssuche (VNS) ist eine vergleichsweise junge Metaheuristik, die ihren Ursprung um das Jahr 1995 hat, in dem sie erstmalig vorgestellt wurde (siehe [16] und [11]). Grundsätzlich kann ein Optimierungsproblem allgemein formuliert werden als min {f (x)|x E X, X C Z}. (5.1) Z, X, x und f bezeichnen dabei den Lösungsraum, die Menge der gültigen Lösungen, </context>
</contexts>
<marker>[16]</marker>
<rawString>N. Mladenovi´c. A variable neighborhood algorithm - a new metaheuristic for combinatorial optimization. Abstracts of papers presented at Optimization Days, page 112, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Ralphs</author>
<author>L Kopman</author>
<author>W Pulleyblank</author>
<author>L T Jr</author>
</authors>
<title>On the capacitated vehicle routing problem.</title>
<date>2003</date>
<booktitle>Mathematical Programming Series, 94(B):1–19,</booktitle>
<contexts>
<context position="28230" citStr="[17]" startWordPosition="3855" endWordPosition="3855">er zeitlichen Einschränkungen. Das VRP gehört in die Klasse der NPschweren Probleme. 3.1.1 Capacitated Vehicle Routing Problem Eine Variante des VRP ist das Capacitated Vehicle Routing Problem (CVRP) [17], welches die Kapazitäten der verwendeten Fahrzeuge einschränkt. Das in [17] beschriebene CVRP verlangt die Auslieferung eines einzigen Gutes an n Kunden ausgehend von einem Depot {0} unter Verwendung</context>
</contexts>
<marker>[17]</marker>
<rawString>T. Ralphs, L. Kopman, W. Pulleyblank, and L. T. Jr. On the capacitated vehicle routing problem. Mathematical Programming Series, 94(B):1–19, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Toth</author>
<author>D Vigo</author>
</authors>
<title>The Vehicle Routing Problem.</title>
<date>2002</date>
<booktitle>Monographs on Discrete Mathematics and Applications. SIAM,</booktitle>
<location>Philadelphia,</location>
<contexts>
<context position="24642" citStr="[18]" startWordPosition="3365" endWordPosition="3365">rschickt werden zu können. 7 8 3 Verwandte Arbeiten Aus der detaillierten Problemspezifikation folgt unmittelbar, dass es sich bei dieser Aufgabenstellung um ein mit dem Vehicle Routing Problem (VRP) [18] verwandtes Problem handelt, das zu den im klassischen VRP definierten Nebenbedingungen noch weitere domänenspezifische Einschränkungen enthält. Die ursprüngliche Variante des VRP verlangt, dass ausge</context>
</contexts>
<marker>[18]</marker>
<rawString>P. Toth and D. Vigo. The Vehicle Routing Problem. Monographs on Discrete Mathematics and Applications. SIAM, Philadelphia, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Q Zhu</author>
<author>K C Tan</author>
<author>L H Lee</author>
</authors>
<title>Heuristics for vehicle routing problem with time.</title>
<date>2000</date>
<booktitle>In Windows, 6th AI and Math,</booktitle>
<contexts>
<context position="30797" citStr="[19]" startWordPosition="4265" endWordPosition="4265"> des VRP behandelt jene Problemstellung, bei der die Kunden innerhalb eines definierten Zeitfensters beliefert werden müssen. Bei diesem Problem, dem Vehicle Routing Problem with Time Windows (VRPTW) [19], kann sich die Reihenfolge der zu beliefernden Kunden daher nicht ausschließlich aus den Routen mit kürzesten Wegen definieren, sondern wird zusätzlich von einer zeitlichen Beschränkung beeinflusst. </context>
</contexts>
<marker>[19]</marker>
<rawString>K. Q. Zhu, K. C. Tan, and L. H. Lee. Heuristics for vehicle routing problem with time. In Windows, 6th AI and Math, 2000.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>