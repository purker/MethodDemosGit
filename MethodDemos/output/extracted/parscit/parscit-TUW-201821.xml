<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.003229">
<note confidence="0.978757">
arXiv:1107.2088v1 [cs.AI] 11 Jul 2011
</note>
<title confidence="0.943622">
Advancing Multi-Context Systems by
Inconsistency Management⋆
</title>
<author confidence="0.986999">
Antonius Weinzierl
</author>
<affiliation confidence="0.999518">
Institute of Information Systems
Vienna University of Technology
</affiliation>
<address confidence="0.859721">
Favoritenstraße 9-11, A-1040 Vienna, Austria
</address>
<email confidence="0.984272">
weinzierl@kr.tuwien.ac.at
</email>
<bodyText confidence="0.99064965">
Abstract. Multi-Context Systems are an expressive formalism to model
(possibly) non-monotonic information exchange between heterogeneous
knowledge bases. Such information exchange, however, often comes with
unforseen side-effects leading to violation of constraints, making the
system inconsistent, and thus unusable. Although there are many ap-
proaches to assess and repair a single inconsistent knowledge base, the
heterogeneous nature of Multi-Context Systems poses problems which
have not yet been addressed in a satisfying way: How to identify and
explain a inconsistency that spreads over multiple knowledge bases with
different logical formalisms (e.g., logic programs and ontologies)? What
are the causes of inconsistency if inference/information exchange is non-
monotonic (e.g., absent information as cause)? How to deal with inconsis-
tency if access to knowledge bases is restricted (e.g., companies exchange
information, but do not allow arbitrary modifications to their knowledge
bases)? Many traditional approaches solely aim for a consistent system,
but automatic removal of inconsistency is not always desireable. There-
fore a human operator has to be supported in finding the erroneous
parts contributing to the inconsistency. In my thesis those issues will
be adressed mainly from a foundational perspective, while our research
project also provides algorithms and prototype implementations.
</bodyText>
<sectionHeader confidence="0.994301" genericHeader="abstract">
1 Introduction
</sectionHeader>
<tableCaption confidence="0.4849544">
Multi-Context Systems (MCSs) are an expressive formalism for (possibly) non-
monotonic knowledge exchange between heterogeneous knowledge sources. These
sources are called contexts and formalized as abstract ‘logics’. Information flow
between contexts is specified using bridge rules which look and behave similar
to rules in non-monotonic logic programming (cf. [15]):
</tableCaption>
<note confidence="0.579492">
(k : s) ← (c1 : p1), ... , (cj : pj), not(cj+1 : pj+1), ... , not(cm : pm). (1)
Such a rule states that information s is added to context k if for 1 &lt; i &lt; j
knowledge pi is present in context ci and for j + 1 &lt; i &lt; m knowledge pi is
</note>
<bodyText confidence="0.9713052">
⋆ Supported by the Vienna Science and Technology Fund (WWTF), grant ICT08-020.
absent in ci. Following common terminology p1, ... , pm are called beliefs (each
of their respective context) and s is the head formula of the bridge rule.
Consider a hospital where a database with patient records, a medical on-
tology, and an expert system shall be working together giving decision support
on patient medications. The MCS framework is a good choice to realize this.
Assume for patient Sue, the database knows that a) her X-Ray result indicates
pneumonia, b) a certain blood marker is present, and c) she has no known aller-
gies. The ontology imports information on X-Ray and blood tests using bridge
rules
</bodyText>
<equation confidence="0.9647525">
(Conto : xray(Sue)) (Cpatients : labresult(Sue, xray)).
(Conto : marker (Sue)) (Cpatients : labresult(Sue, marker)).
</equation>
<bodyText confidence="0.997536580645161">
As the ontology contains the axiom xray n marker C_ atyp pneu it concludes that
Sue has a atypical pneumonaia, severe kind of pneumonia. Finally, the expert
system, a logic program containing rules give weak V give strong : —pneumonia.
and give strong : —atyp pneumonia. suggests one out of two kinds of antibiotics
if a patient has pneumonia. But it also respects potential allergies by the con-
straint : —give strong, not allowed strong. As Sue has atypical pneumonia, only
the strong antibiotic will help, so the logic program suggests this.
Now assume that Sue is allergic to strong antibiotics, a case that actually
happens in the real world. Then the expert system can give no valid suggestion as
strong antibiotics have to be given, but at the same time they are forbidden to be
applied. This results in the whole system having no ‘model’ satisfying deductions
of all knowledge bases and bridge rules. We call such an MCS inconsistent. 1
By this example, we identify the following open problems:
– the inconsistency above is present due to tuples in the database, termino-
logical assertions in the ontology, logic programming rules in the expert
system and, a set of bridge rules establishing the information exchange. In
what terms should the inconsistency be described and is there a uniform
description irrespective of the specific formalisms used in contexts? Non-
monotonicity of bridge rules and contexts is an additional challenge to such
a description.
– Given such a description it is very likely that multiple ways exist to restore
consistency. Removing some bridge rules would make the above example con-
sistent, but also removal of tuples describing lab results. Similarly, addition
of new bridge rules could resolve the inconsistency. If multiple options exist,
which is the most preferred to restore consistency? Is it possible to do this
in a heterogeneous way, i.e., can the designer of an MCS use a formalism
of his own choice to specify his preference? Can such preference be given
only for specific parts of an MCS and preference for other parts differently
expressed?
– In the above example, the inconsistency can be dealt with locally, e.g., the
expert system could switch to use paracoherent semantics and the MCS
</bodyText>
<footnote confidence="0.406287">
1 A complete formalisation of this example is available in [12].
</footnote>
<page confidence="0.972215">
18
</page>
<bodyText confidence="0.999007363636364">
becomes consistent. For MCSs with cyclic information flow, however, this
might be impossible as cyclic information flow can be such that each context
returns valid belief sets (“models”), but still for the overall system it does not
fit together. How far does local inconsistency management help to resolve
inconsistency, e.g., for MCSs with acyclic information flow?
— Besides inconsistency, is the MCS framework so versatile as to use other
kinds of rules to connect contexts, e.g., SPARQL queries for information
exchange?
As research on these topics has been started two years ago, the rest of this
paper will briefly present results adressing above questions. Regarding research
methodologies, we built analogies from existing techniques, e.g., Reiter’s diagno-
sis. For algorithms we resorted to reductions to computational logic and meta-
reasoning transformations, e.g., preference is handled in this way. Whenever pos-
sible, our invented methods are open so that legacy systems may be integrated
to achieve certain tasks, e.g., local inconsistency management.
Contributions summary:
— we developed a uniform representation of inconsistency in terms of bridge
rules. This representation leads a) to the notion of inconsistency explanation
which separates different sources of inconsistency and points out those bridge
rules creating inconsistency and b) to the notion of diagnosis which induce
all possible repairs of an inconsistent MCS. Notably, both notions coincide
on the overall set of bridge rules which are marked ‘faulty.
— on top of those notions, we developed a transformation-based technique to
allow meta-reasoning on diagnoses of an inconsistent MCS. This allows sys-
tem designers to express preferences over diagnoses in a formalism of their
own choice. The same techinque also allows to filter out undesired diagnoses.
— for local inconsistency management, a generalization of the MCS formalism
was developed allowing to use existing methods of inconsistency management
locally for a context. The introduced notion of a context manager allows to
employ arbitrary knowledge management techniques locally at a context. It
is important that the employed manager can change a knowledge base in a
broad range and therefore it can also do other operations like view updates,
belief revision, logic program updates, etc.
— for above notions the computational complexity also was analysed.
— to show the versatility of the ideas behind MCS, we also introduced a mod-
ified notion of MCS where knowledge exchange is specified using SPARQL
queries.
Finally, we also implemented prototypes for evaluating MCSs and computing
diagnoses and explanations of inconsistent MCSs.
The remainder of this paper is organized as follows: In Section 2 related work
is discussed while Section 3 recapitulates the formal semantics of MCS and our
basic notion for inconsistency diagnosis/explanation, it is followed by a short
presentation of major achievements in the last two years in Section 4. Finally,
Section 5 is an outlook on future work.
</bodyText>
<page confidence="0.974618">
19
</page>
<sectionHeader confidence="0.999774" genericHeader="related work">
2 Related Work
</sectionHeader>
<bodyText confidence="0.999979581395349">
With the seminal work of [19] and [16] the notion of context has been intro-
duced to artificial intelligence and logic. In these works, a context is a regarded
as a certain point of view in which formal reasoning takes place. The Trento
school (cf. [17,22]) formalized and improved this understanding of context. It is
notable, however, that those first frameworks consider homogeneous, monotonic
logics for representing a context. With [9,21] non-monotonicity was introduced
to Multi-Context Systems. Although default negation is added to bridge rules,
contexts still are homogeneous or monotonic. Only with [7] the framework has
been generalized for non-monotonic bridge rules and heterogeneous contexts.
This finally allows to use arbitrary knowledge sources that are connected by
(possibly) non-monotonic bridge rules. Our research is based on this notion of
MCSs.
To deal with inconsistency, in [5] defeasible rules are introduced as a way of
establishing information exchange in MCS. Defeasible rules are similar to bridge
rules, but their semantics differs as a defeasible rule does not fire if it would cause
an inconsistency by doing so. Several algorithms based on preference orders (or
argumentation frameworks [4]) have been proposed. Inconsistency is resolved
inherently, but no deeper inconsistency analysis is possible. For our hospital
example this would mean that some information simply would not be passed
along, e.g., forgetting the illness of Sue. Most of the proposed algorithms are
based on provenance, which means that context internals have to be exhibited
to other contexts. A company making profit by allowing third parties to use its
knowledge base, however, will not risk its business by providing such information.
Aside from MCS, other areas deal with knowledge integration and its issues.
Peer-to-Peer (p2p) systems [24,10] are similar as knowledge sources interchange
pieces of information. Although the notion of a peer is very similar to a context
in MCS, the essential feature of p2p systems is that peers may leave and join
the system arbitrarily. Therefore research seeks to cope with inconsistency by
isolating faulty contexts and simply ignore their information instead of analysing
the inconsistency and aiming for a consistent system.
Information integration on the other hand deals extensively with issues like
constraint violations that stem from the integration of several databases into
a single one (cf. [6] for a survey on data fusion). Its main differences to MCS
are that the result of data fusion is one single database which usually uses
relational algebra for knowledge representation. MCSs, however, require incon-
sistency management for multiple, heterogeneous knowledge bases which are not
restricted to a relational setting.
For many formalisms, methods of inconsistency handling have been invented,
e.g., belief revision or possibilistic reasoning (e.g. [3]) for classical logic, para-
coherent semantics for logic programs, etc. These methods can resolve inconsis-
tency locally at a context (cf. Section 4), but they can not guarantee a consistent
system. Also, most of those methods are only applicable to a specific formalism
instead of a heterogeneous non-monotonic system.
</bodyText>
<page confidence="0.848083">
20
</page>
<sectionHeader confidence="0.995637" genericHeader="method">
3 MCS Preliminaries
</sectionHeader>
<bodyText confidence="0.995518714285714">
Each context of an MCS is seen as a knowledge base built on an underlying logic.
To capture different kinds of logics, this notion is general and not defined in the
bottom-up style of inductive definitions for syntax and semantics. Instead, its
approach is top-down, directly working with sets of well-formed formulas (wffs)
and models (called belief sets). The semantics of a logic then only maps each set
of wffs to a set of belief sets, i.e., the models of the wffs.
Formally, a logic L = (KBL, BSL, ACCL) consists, of the following compo-
nents: 1) KBL is the set of well-formed knowledge bases of L where each element
of KBL is a set (of formulas). 2) BSL is the set of possible belief sets where we
assume that each element of BSL is a set (i.e.,a model containing all formulas
that are considered true). 3) ACCL : KBL → 2BSL is a function describing
the semantics of L by assigning each knowledge base a set of acceptable belief
sets. This concept of a logic captures many monotonic and non-monotonic logics,
e.g., classical logic, description logics, modal, default, and autoepistemic logics,
circumscription, and logic programs under the answer set semantics.
A Multi-Context System M = (C1, ... , Cn) is a collection of contexts Ci =
(Li, kbi, bri), 1 ≤ i ≤ n, where Li = (KBi, BSi, ACCi) is a logic, kbi ∈
KBi a knowledge base, and bri is a set of bridge rules of form (1) over log-
ics (L1, ... , Ln). Furthermore, for each bridge rule r ∈ bri its head formula s
is compatible with Ci, i.e., for each H ⊆ {s  |r ∈ br and (i : s) is the head of r}
holds kb ∪ H ∈ KBLi.
A belief state S = (S1, ... , Sn) of an MCS M = (C1, ... , Cn) is a belief set
for every context, i.e., Si ∈ BSi for all 1 ≤ i ≤ n. The semantics of MCS is
defined in terms of equilibria, i.e., belief states that reproduce themselves under
the application of bridge rules. Formally, let M be an MCS, Ci a context of M
and S = (S1, ... , Sn) a belief state of M, then an bridge rule r of form (1) is
applicable wrt. S, denoted by S |= body(r), iff pℓ ∈ Scℓ for 1 ≤ ℓ ≤ j and pℓ ∈/ Scℓ
for j &lt; ℓ ≤ m. Let appi(S) = {hd(r)  |r ∈ bri ∧ S |= body(r)} denote the heads
of all applicable bridge rules of context Ci under S, then S = (S1, ... , Sn) is an
equilibrium of M if and only if Si ∈ ACCi(appi(S)) for 1 ≤ i ≤ n.
Basic Notions for Inconsistency Analysis (cf. [12]): We call an MCS M
inconsistent iff no belief state of M is an equilibrium. To analyse and explain
the inconsistency in an MCS, two notions have been developed: consistency-
based diagnosis and entailment-based inconsistency explanation. Both notions
use bridge rules to characterize ‘faulty’ information exchange. Intuitively, a diag-
nosis states how an inconsistent MCS can be changed to get a consistent system
and an explanation shows what parts of the system create the inconsistency.
For an MCS M, brM denotes the set of all bridge rules occuring in M, M[R]
denotes a modified MCS where all bridge rules of M are replaced by those of
R, and M |= ⊥ denotes that M is inconsistent. Given an MCS M, a diagnosis
of M is a pair (D1, D2),D1, D2 ⊆ brM, s.t. M[brM \ D1 ∪ heads(D2)] 6|= ⊥.
An explanation of M is a pair (E1, E2) of sets E1, E2 ⊆ brM of bridge rules
</bodyText>
<page confidence="0.984923">
21
</page>
<bodyText confidence="0.998687857142857">
s.t. for all (R1, R2) where E1 C_ R1 C_ brM and R2 C_ brM \ E2, it holds that
M[R1 U heads(R2)] �= 1.
For a concise characterization, one usually focuses on subset-minimal diag-
noses and explanations. The basic ideas behind both notions appear also in
Reiter’s seminal work on diagnosis [20]. Our diagnosis is similar to his notion
and our explanation is similar to (minimal) inconsistent sets. For differences, we
assume the source of inconsistency to be some faulty information exchange, so we
only consider bridge rules, and because of the non-monotonic nature of MCSs,
a bridge rule can be faulty by firing when it should not and also by not firing
when it should. In classical diagnosis, only the former is relevant as monotonic
logics only become inconsistent by that. The set of minimal diagnoses can also
be seen as describing all minimal repairs, while the set of minimal explanations
show hows inconsistency is caused in the system. The set E2 in an explanation
also shares some ideas with consistency restoring rules (cf. [2]) of logic programs.
</bodyText>
<sectionHeader confidence="0.999145" genericHeader="method">
4 Contributions: Methods of Inconsistency Management
</sectionHeader>
<bodyText confidence="0.999814925925926">
This section presents contributions and answers the motivational questions raised
in the introduction. These are the major published results of my graduate re-
search. Note that authors are listed alphabetically for the respective publications.
Inconsistency Assessment: Having jointly developed and investigated, the
basic notions for inconsistency analysis, the next step was developing methods
to assess inconsistency qualitatively, i.e., filter diagnoses with undesired prop-
erties and select most preferred ones. In the spirit of MCS, we do not apply a
specific formalism for preference or filters on diagnoses, but rather show how
a transformation of the MCS and slight adaption of the notion of diagnosis is
sufficient to achieve the desired effects in [13].
As one of the strengths of MCS is the ability to allow arbitrary formalisms for
knowledge representation inside contexts, we do not want to restrict the users to
a specific kind of representation of filters (or preferences). We therefore devised
a meta-reasoning transformation which allows certain contexts to observe which
diagnosis is applied to the MCS. The desired filter then is realized inside such
an observer context (in a formalisms which is best suited for this task). So an
MCS M is transformed into an MCS Mf where an additional observer context
ob is added together with some additional bridge rules (details cf. [13]). As Mf
contains all contexts and bridge rules of M, every diagnosis of M can also be
applied to Mf. If ob detects an undesired diagnosis D′, then ob simply becomes
inconsistent, i.e., having no acceptable belief set. Therefore D′ is no diagnosis of
Mf, but all other diagnoses of M are diagnoses of Mf. This allows to compute
all filtered diagnoses with the same algorithm as for computing subset-minimal
diagnoses and it also allows to specify the filter in any desired formalism.
The meta-reasoning transformation also can be applied for multiple observa-
tion contexts where each observer only sees some bridge rules instead of all, thus
preserving information hiding. As a similar meta-reasoning transformation can
</bodyText>
<page confidence="0.853918">
22
</page>
<bodyText confidence="0.9999403">
be used for comparison of diagnoses, it is possible to realize any given preference
order on diagnoses and select the most preferred one. In general, however, this
requires exponentially many more bridge rules in the transformed system, but
for restricted classes of preference orders it is feasible.
Inconsistency management at the level of contexts: For many specific
logics and knowledge formalisms, solutions to deal with inconsistency have been
developed in the past, e.g., belief revision and paraconsistency for logics, para-
coherent logic programming for logic programs, etc. For contexts using the un-
derlying formalism it is desireable that MCSs also offer the same methods of
inconsistency handling. Those methods, however, require to modify a knowledge
base in more ways, than just the addition of formulas as bridge rules can do.
We therefore propose managed Multi-Context Systems (mMCS) in [8] where
each context is equiped with a manager that can apply arbitrary changes to
the context’s knowledge base. Bridge rules in an mMCS are like those of MCS,
but their head contains a unary command op, e.g., revise(s), delete(s), add(s),
to apply the resp. operation on the formula s and the knowledge base of the
context.
Managed MCS are a significant generalization of MCS as management func-
tions can be used to realize a multitude of tasks: belief revision, view updates,
updates of logic programs. To us, the most interesting is to ensure that con-
texts have a ‘model’ for any input. Such contexts are called totally coherent.
Most notably even mMCS with totally coherent contexts cannot guarantee that
the overall system has an equilibrium, but they ensure that inconsistency is
only caused by odd-cyclic information flow. It directly follows that any acyclic
mMCS with totally coherent contexts is consistent, thus proving local inconsis-
tency management sufficient for acyclic MCS.
Beyond bridge rules: In [23] we introduce MCS where knowledge exchange is
realised using SPARQL construct-queries. This is surprisingly simple and again
shows the versatility of MCS. The resulting SPARQL-MCS framework is related
to the MWeb approach [1], but our treatment of variables is different.
</bodyText>
<sectionHeader confidence="0.999711" genericHeader="method">
5 Future Work
</sectionHeader>
<bodyText confidence="0.9999455">
As shown above, we were able to answer several foundational questions, give a
uniform representation of inconsistency in heterogeneous MCSs, an open inte-
gration of preference-based inconsistency assessment, investigating the impact of
local inconsistency handling, and making the MCS formalism capable of dealing
with arbitrary changes to the knowledge bases of an MCS.
To evaluate the feasibility of the developed methods, we also aim for a refer-
ence application which is currently in the making: querying of a DNA database
posing questions in (almost) natural language using an ontology and answer-
set programs. Intital steps towards exchanging large amounts of information
(cf. [14]) also showed that more specialised algorithms are needed.
</bodyText>
<page confidence="0.925001">
23
</page>
<bodyText confidence="0.385327666666667">
Investigations whether approximation operators of [11] for logic programs can
be translated to MCSs and transferring optimisations for abductive diagnosis
(e.g.,[18]) to MCSs are also open tasks.
</bodyText>
<sectionHeader confidence="0.997526" genericHeader="conclusions">
6 Acknowledgements
</sectionHeader>
<bodyText confidence="0.987124">
I am very grateful to my advisor Thomas Eiter, the principal investigator of our
research project Michael Fink, and my colleague Peter Schüller who provided
guidance, and helped with many fruitful discussions. Thank you.
</bodyText>
<sectionHeader confidence="0.998958" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.991478979591837">
1. Analyti, A., Antoniou, G., Damasio, C.V.: MWeb: A principled framework for
modular web rule bases and its semantics. ACM Trans. Comput. Logic 12(2) (2011)
2. Balduccini, M., Gelfond, M.: Logic programs with consistency-restoring rules. In:
International Symposium on Logical Formalization of Commonsense Reasoning,
AAAI 2003 Spring Symposium Series. pp. 9–18 (2003)
3. Benferhat, S., Lagrue, S., Yahi, S.: Bridging possibilistic conditional knowledge
bases and partially ordered bases. In: JELIA. pp. 38–50 (2010)
4. Bikakis, A., Antoniou, G.: Contextual argumentation in ambient intelligence. In:
LPNMR. pp. 30–43 (2009)
5. Bikakis, A., Antoniou, G., Hassapis, P.: Alternative strategies for conflict resolution
in multi-context systems. In: AIAI. pp. 31–40 (2009)
6. Bleiholder, J., Naumann, F.: Data fusion. ACM Comput. Surv. 41(1), 1–41 (2008)
7. Brewka, G., Eiter, T.: Equilibria in heterogeneous nonmonotonic multi-context
systems. In: AAAI. pp. 385–390 (2007)
8. Brewka, G., Eiter, T., Fink, M., Weinzierl, A.: Managed multi-context systems. In:
IJCAI (2011), to appear.
9. Brewka, G., Roelofsen, F., Serafini, L.: Contextual default reasoning. In: IJCAI.
pp. 268–273 (2007)
10. Calvanese, D., Giacomo, G.D., Lembo, D., Lenzerini, M., Rosati, R.: Inconsistency
tolerance in p2p data integration: An epistemic logic approach. Inf. Syst. 33(4-5),
360–384 (2008)
11. Denecker, M., Marek, V.W., Truszczynski, M.: Ultimate approximation and its ap-
plication in nonmonotonic knowledge representation systems. Inf. Comput. 192(1),
84–121 (2004)
12. Eiter, T., Fink, M., Schüller, P., Weinzierl, A.: Finding explanations of inconsis-
tency in multi-context systems. In: KR (2010)
13. Eiter, T., Fink, M., Weinzierl, A.: Preference-based inconsistency assessment in
multi-context systems. In: JELIA. pp. 143–155 (2010)
14. Fink, M., Ghionna, L., Weinzierl, A.: Relational information exchange and aggre-
gation in multi-context systems. In: LPNMR. pp. 120–133 (2011)
15. Gelfond, M., Lifschitz, V.: Classical negation in logic programs and disjunctive
databases. New Generation Comput. 9(3/4), 365–386 (1991)
16. Giunchiglia, F.: Abstract contextual reasoning (1993)
17. Giunchiglia, F., Serafini, L.: Multilanguage hierarchical logics or: How we can do
without modal logics. Artif. Intell. 65(1), 29–70 (1994)
18. de Kleer, J.: Focusing on probable diagnoses. In: AAAI. pp. 842–848 (1991)
24
19. McCarthy, J.: Notes on formalizing context. In: IJCAI. pp. 555–562 (1993)
20. Reiter, R.: A theory of diagnosis from first principles. Artif. Intell. 32(1), 57–95
(1987)
21. Roelofsen, F., Serafini, L.: Minimal and absent information in contexts. In: IJCAI.
pp. 558–563 (2005)
22. Roelofsen, F., Serafini, L.: Minimality and non-determinism in multi-context sys-
tems. In: CONTEXT. pp. 424–435 (2005)
23. Schüller, P., Weinzierl, A.: Semantic reasoning with sparql in heterogeneous multi-
context systems. In: Semantic Search over the Web (2011), to appear
24. Serafini, L., Giunchiglia, F., Mylopoulos, J., Bernstein, P.: Local relational model:
A logical formalization of database coordination. In: CONTEXT. pp. 286–299
(2003)
</reference>
<page confidence="0.959259">
25
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.440445">
<pubnum confidence="0.547336">arXiv:1107.2088v1[cs.AI]11 Jul 2011</pubnum>
<title confidence="0.949548">Advancing Multi-Context Systems by</title>
<author confidence="0.999674">Antonius Weinzierl</author>
<affiliation confidence="0.9999655">Institute of Information Systems Vienna University of Technology</affiliation>
<address confidence="0.99953">Favoritenstraße 9-11, A-1040 Vienna, Austria</address>
<email confidence="0.867354">weinzierl@kr.tuwien.ac.at</email>
<abstract confidence="0.9993936">Systems are an expressive formalism to model (possibly) non-monotonic information exchange between heterogeneous knowledge bases. Such information exchange, however, often comes with unforseen side-effects leading to violation of constraints, making the system inconsistent, and thus unusable. Although there are many approaches to assess and repair a single inconsistent knowledge base, the heterogeneous nature of Multi-Context Systems poses problems which have not yet been addressed in a satisfying way: How to identify and explain a inconsistency that spreads over multiple knowledge bases with different logical formalisms (e.g., logic programs and ontologies)? What are the causes of inconsistency if inference/information exchange is nonmonotonic (e.g., absent information as cause)? How to deal with inconsistency if access to knowledge bases is restricted (e.g., companies exchange information, but do not allow arbitrary modifications to their knowledge bases)? Many traditional approaches solely aim for a consistent system, but automatic removal of inconsistency is not always desireable. Therefore a human operator has to be supported in finding the erroneous parts contributing to the inconsistency. In my thesis those issues will be adressed mainly from a foundational perspective, while our research project also provides algorithms and prototype implementations.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>A Analyti</author>
<author>G Antoniou</author>
<author>Damasio</author>
</authors>
<title>C.V.: MWeb: A principled framework for modular web rule bases and its semantics.</title>
<date>2011</date>
<journal>ACM Trans. Comput. Logic</journal>
<volume>12</volume>
<issue>2</issue>
<contexts>
<context position="20279" citStr="[1]" startWordPosition="3302" endWordPosition="3302">e knowledge exchange is realised using SPARQL construct-queries. This is surprisingly simple and again shows the versatility of MCS. The resulting SPARQL-MCS framework is related to the MWeb approach [1], but our treatment of variables is different. 5 Future Work As shown above, we were able to answer several foundational questions, give a uniform representation of inconsistency in heterogeneous MCSs</context>
</contexts>
<marker>1.</marker>
<rawString>Analyti, A., Antoniou, G., Damasio, C.V.: MWeb: A principled framework for modular web rule bases and its semantics. ACM Trans. Comput. Logic 12(2) (2011)</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Balduccini</author>
<author>M Gelfond</author>
</authors>
<title>Logic programs with consistency-restoring rules.</title>
<date>2003</date>
<booktitle>In: International Symposium on Logical Formalization of Commonsense Reasoning, AAAI 2003 Spring Symposium Series.</booktitle>
<pages>9--18</pages>
<contexts>
<context position="15943" citStr="[2]" startWordPosition="2622" endWordPosition="2622">g all minimal repairs, while the set of minimal explanations show hows inconsistency is caused in the system. The set E2 in an explanation also shares some ideas with consistency restoring rules (cf. [2]) of logic programs. 4 Contributions: Methods of Inconsistency Management This section presents contributions and answers the motivational questions raised in the introduction. These are the major pub</context>
</contexts>
<marker>2.</marker>
<rawString>Balduccini, M., Gelfond, M.: Logic programs with consistency-restoring rules. In: International Symposium on Logical Formalization of Commonsense Reasoning, AAAI 2003 Spring Symposium Series. pp. 9–18 (2003)</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Benferhat</author>
<author>S Lagrue</author>
<author>S Yahi</author>
</authors>
<title>Bridging possibilistic conditional knowledge bases and partially ordered bases. In:</title>
<date>2010</date>
<booktitle>JELIA.</booktitle>
<pages>38--50</pages>
<contexts>
<context position="11365" citStr="[3]" startWordPosition="1761" endWordPosition="1761">ous knowledge bases which are not restricted to a relational setting. For many formalisms, methods of inconsistency handling have been invented, e.g., belief revision or possibilistic reasoning (e.g. [3]) for classical logic, paracoherent semantics for logic programs, etc. These methods can resolve inconsistency locally at a context (cf. Section 4), but they can not guarantee a consistent system. Als</context>
</contexts>
<marker>3.</marker>
<rawString>Benferhat, S., Lagrue, S., Yahi, S.: Bridging possibilistic conditional knowledge bases and partially ordered bases. In: JELIA. pp. 38–50 (2010)</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Bikakis</author>
<author>G Antoniou</author>
</authors>
<title>Contextual argumentation in ambient intelligence. In:</title>
<date>2009</date>
<booktitle>LPNMR.</booktitle>
<pages>30--43</pages>
<contexts>
<context position="9676" citStr="[4]" startWordPosition="1505" endWordPosition="1505">bridge rules, but their semantics differs as a defeasible rule does not fire if it would cause an inconsistency by doing so. Several algorithms based on preference orders (or argumentation frameworks [4]) have been proposed. Inconsistency is resolved inherently, but no deeper inconsistency analysis is possible. For our hospital example this would mean that some information simply would not be passed </context>
</contexts>
<marker>4.</marker>
<rawString>Bikakis, A., Antoniou, G.: Contextual argumentation in ambient intelligence. In: LPNMR. pp. 30–43 (2009)</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Bikakis</author>
<author>G Antoniou</author>
<author>P Hassapis</author>
</authors>
<title>Alternative strategies for conflict resolution in multi-context systems.</title>
<date>2009</date>
<journal>In: AIAI.</journal>
<pages>31--40</pages>
<contexts>
<context position="9354" citStr="[5]" startWordPosition="1455" endWordPosition="1455">texts. This finally allows to use arbitrary knowledge sources that are connected by (possibly) non-monotonic bridge rules. Our research is based on this notion of MCSs. To deal with inconsistency, in [5] defeasible rules are introduced as a way of establishing information exchange in MCS. Defeasible rules are similar to bridge rules, but their semantics differs as a defeasible rule does not fire if i</context>
</contexts>
<marker>5.</marker>
<rawString>Bikakis, A., Antoniou, G., Hassapis, P.: Alternative strategies for conflict resolution in multi-context systems. In: AIAI. pp. 31–40 (2009)</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Bleiholder</author>
<author>F Naumann</author>
</authors>
<title>Data fusion.</title>
<date>2008</date>
<journal>ACM Comput. Surv.</journal>
<volume>41</volume>
<issue>1</issue>
<pages>1--41</pages>
<contexts>
<context position="10905" citStr="[6]" startWordPosition="1694" endWordPosition="1694"> for a consistent system. Information integration on the other hand deals extensively with issues like constraint violations that stem from the integration of several databases into a single one (cf. [6] for a survey on data fusion). Its main differences to MCS are that the result of data fusion is one single database which usually uses relational algebra for knowledge representation. MCSs, however, </context>
</contexts>
<marker>6.</marker>
<rawString>Bleiholder, J., Naumann, F.: Data fusion. ACM Comput. Surv. 41(1), 1–41 (2008)</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Brewka</author>
<author>Eiter</author>
</authors>
<title>T.: Equilibria in heterogeneous nonmonotonic multi-context systems.</title>
<date>2007</date>
<journal>In: AAAI.</journal>
<pages>385--390</pages>
<contexts>
<context position="9063" citStr="[7]" startWordPosition="1412" endWordPosition="1412">epresenting a context. With [9,21] non-monotonicity was introduced to Multi-Context Systems. Although default negation is added to bridge rules, contexts still are homogeneous or monotonic. Only with [7] the framework has been generalized for non-monotonic bridge rules and heterogeneous contexts. This finally allows to use arbitrary knowledge sources that are connected by (possibly) non-monotonic bri</context>
</contexts>
<marker>7.</marker>
<rawString>Brewka, G., Eiter, T.: Equilibria in heterogeneous nonmonotonic multi-context systems. In: AAAI. pp. 385–390 (2007)</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Brewka</author>
<author>T Eiter</author>
<author>M Fink</author>
<author>A Weinzierl</author>
</authors>
<title>Managed multi-context systems. In: IJCAI</title>
<date>2011</date>
<note>to appear.</note>
<contexts>
<context position="19038" citStr="[8]" startWordPosition="3104" endWordPosition="3104">dling. Those methods, however, require to modify a knowledge base in more ways, than just the addition of formulas as bridge rules can do. We therefore propose managed Multi-Context Systems (mMCS) in [8] where each context is equiped with a manager that can apply arbitrary changes to the context’s knowledge base. Bridge rules in an mMCS are like those of MCS, but their head contains a unary command o</context>
</contexts>
<marker>8.</marker>
<rawString>Brewka, G., Eiter, T., Fink, M., Weinzierl, A.: Managed multi-context systems. In: IJCAI (2011), to appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Brewka</author>
<author>F Roelofsen</author>
<author>L Serafini</author>
</authors>
<title>Contextual default reasoning. In:</title>
<date>2007</date>
<booktitle>IJCAI.</booktitle>
<pages>268--273</pages>
<contexts>
<context position="8894" citStr="[9,21]" startWordPosition="1389" endWordPosition="1389">school (cf. [17,22]) formalized and improved this understanding of context. It is notable, however, that those first frameworks consider homogeneous, monotonic logics for representing a context. With [9,21] non-monotonicity was introduced to Multi-Context Systems. Although default negation is added to bridge rules, contexts still are homogeneous or monotonic. Only with [7] the framework has been general</context>
</contexts>
<marker>9.</marker>
<rawString>Brewka, G., Roelofsen, F., Serafini, L.: Contextual default reasoning. In: IJCAI. pp. 268–273 (2007)</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Calvanese</author>
<author>G D Giacomo</author>
<author>D Lembo</author>
<author>M Lenzerini</author>
<author>R Rosati</author>
</authors>
<title>Inconsistency tolerance in p2p data integration: An epistemic logic approach.</title>
<date>2008</date>
<journal>Inf. Syst.</journal>
<volume>33</volume>
<issue>4</issue>
<pages>360--384</pages>
<contexts>
<context position="10306" citStr="[24,10]" startWordPosition="1601" endWordPosition="1601">es to use its knowledge base, however, will not risk its business by providing such information. Aside from MCS, other areas deal with knowledge integration and its issues. Peer-to-Peer (p2p) systems [24,10] are similar as knowledge sources interchange pieces of information. Although the notion of a peer is very similar to a context in MCS, the essential feature of p2p systems is that peers may leave and</context>
</contexts>
<marker>10.</marker>
<rawString>Calvanese, D., Giacomo, G.D., Lembo, D., Lenzerini, M., Rosati, R.: Inconsistency tolerance in p2p data integration: An epistemic logic approach. Inf. Syst. 33(4-5), 360–384 (2008)</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Denecker</author>
<author>V W Marek</author>
<author>M Truszczynski</author>
</authors>
<title>Ultimate approximation and its application in nonmonotonic knowledge representation systems.</title>
<date></date>
<journal>Inf. Comput.</journal>
<pages>84--121</pages>
<contexts>
<context position="21140" citStr="[11]" startWordPosition="3430" endWordPosition="3430">werset programs. Intital steps towards exchanging large amounts of information (cf. [14]) also showed that more specialised algorithms are needed. 23 Investigations whether approximation operators of [11] for logic programs can be translated to MCSs and transferring optimisations for abductive diagnosis (e.g.,[18]) to MCSs are also open tasks. 6 Acknowledgements I am very grateful to my advisor Thomas</context>
</contexts>
<marker>11.</marker>
<rawString>Denecker, M., Marek, V.W., Truszczynski, M.: Ultimate approximation and its application in nonmonotonic knowledge representation systems. Inf. Comput. 192(1), 84–121 (2004)</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Eiter</author>
<author>M Fink</author>
<author>P Schüller</author>
<author>Weinzierl</author>
</authors>
<title>A.: Finding explanations of inconsistency in multi-context systems.</title>
<date>2010</date>
<location>In: KR</location>
<contexts>
<context position="5393" citStr="[12]" startWordPosition="848" endWordPosition="848">e above example, the inconsistency can be dealt with locally, e.g., the expert system could switch to use paracoherent semantics and the MCS 1 A complete formalisation of this example is available in [12]. 18 becomes consistent. For MCSs with cyclic information flow, however, this might be impossible as cyclic information flow can be such that each context returns valid belief sets (“models”), but sti</context>
<context position="14043" citStr="[12]" startWordPosition="2286" endWordPosition="2286">ads of all applicable bridge rules of context Ci under S, then S = (S1, ... , Sn) is an equilibrium of M if and only if Si ∈ ACCi(appi(S)) for 1 ≤ i ≤ n. Basic Notions for Inconsistency Analysis (cf. [12]): We call an MCS M inconsistent iff no belief state of M is an equilibrium. To analyse and explain the inconsistency in an MCS, two notions have been developed: consistencybased diagnosis and entailm</context>
</contexts>
<marker>12.</marker>
<rawString>Eiter, T., Fink, M., Schüller, P., Weinzierl, A.: Finding explanations of inconsistency in multi-context systems. In: KR (2010)</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Eiter</author>
<author>M Fink</author>
<author>A Weinzierl</author>
</authors>
<title>Preference-based inconsistency assessment in multi-context systems.</title>
<date>2010</date>
<journal>In: JELIA.</journal>
<pages>143--155</pages>
<contexts>
<context position="16778" citStr="[13]" startWordPosition="2744" endWordPosition="2744">ecific formalism for preference or filters on diagnoses, but rather show how a transformation of the MCS and slight adaption of the notion of diagnosis is sufficient to achieve the desired effects in [13]. As one of the strengths of MCS is the ability to allow arbitrary formalisms for knowledge representation inside contexts, we do not want to restrict the users to a specific kind of representation of</context>
<context position="17411" citStr="[13]" startWordPosition="2848" endWordPosition="2848">in a formalisms which is best suited for this task). So an MCS M is transformed into an MCS Mf where an additional observer context ob is added together with some additional bridge rules (details cf. [13]). As Mf contains all contexts and bridge rules of M, every diagnosis of M can also be applied to Mf. If ob detects an undesired diagnosis D′, then ob simply becomes inconsistent, i.e., having no acce</context>
</contexts>
<marker>13.</marker>
<rawString>Eiter, T., Fink, M., Weinzierl, A.: Preference-based inconsistency assessment in multi-context systems. In: JELIA. pp. 143–155 (2010)</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Fink</author>
<author>L Ghionna</author>
<author>Weinzierl</author>
</authors>
<title>A.: Relational information exchange and aggregation in multi-context systems.</title>
<date>2011</date>
<journal>In: LPNMR.</journal>
<pages>120--133</pages>
<contexts>
<context position="21024" citStr="[14]" startWordPosition="3415" endWordPosition="3415">ly in the making: querying of a DNA database posing questions in (almost) natural language using an ontology and answerset programs. Intital steps towards exchanging large amounts of information (cf. [14]) also showed that more specialised algorithms are needed. 23 Investigations whether approximation operators of [11] for logic programs can be translated to MCSs and transferring optimisations for abd</context>
</contexts>
<marker>14.</marker>
<rawString>Fink, M., Ghionna, L., Weinzierl, A.: Relational information exchange and aggregation in multi-context systems. In: LPNMR. pp. 120–133 (2011)</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Gelfond</author>
<author>V Lifschitz</author>
</authors>
<title>Classical negation in logic programs and disjunctive databases.</title>
<date>1991</date>
<journal>New Generation Comput.</journal>
<volume>9</volume>
<issue>3</issue>
<pages>365--386</pages>
<contexts>
<context position="2039" citStr="[15]" startWordPosition="273" endWordPosition="273">e called contexts and formalized as abstract ‘logics’. Information flow between contexts is specified using bridge rules which look and behave similar to rules in non-monotonic logic programming (cf. [15]): (k : s) ← (c1 : p1), ... , (cj : pj), not(cj+1 : pj+1), ... , not(cm : pm). (1) Such a rule states that information s is added to context k if for 1 &lt; i &lt; j knowledge pi is present in context ci an</context>
</contexts>
<marker>15.</marker>
<rawString>Gelfond, M., Lifschitz, V.: Classical negation in logic programs and disjunctive databases. New Generation Comput. 9(3/4), 365–386 (1991)</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Giunchiglia</author>
</authors>
<title>Abstract contextual reasoning</title>
<date>1993</date>
<contexts>
<context position="8490" citStr="[16]" startWordPosition="1326" endWordPosition="1326">, it is followed by a short presentation of major achievements in the last two years in Section 4. Finally, Section 5 is an outlook on future work. 19 2 Related Work With the seminal work of [19] and [16] the notion of context has been introduced to artificial intelligence and logic. In these works, a context is a regarded as a certain point of view in which formal reasoning takes place. The Trento sc</context>
</contexts>
<marker>16.</marker>
<rawString>Giunchiglia, F.: Abstract contextual reasoning (1993)</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Giunchiglia</author>
<author>L Serafini</author>
</authors>
<title>Multilanguage hierarchical logics or: How we can do without modal logics.</title>
<date>1994</date>
<journal>Artif. Intell.</journal>
<volume>65</volume>
<issue>1</issue>
<pages>29--70</pages>
<contexts>
<context position="8707" citStr="[17,22]" startWordPosition="1364" endWordPosition="1364">n of context has been introduced to artificial intelligence and logic. In these works, a context is a regarded as a certain point of view in which formal reasoning takes place. The Trento school (cf. [17,22]) formalized and improved this understanding of context. It is notable, however, that those first frameworks consider homogeneous, monotonic logics for representing a context. With [9,21] non-monotoni</context>
</contexts>
<marker>17.</marker>
<rawString>Giunchiglia, F., Serafini, L.: Multilanguage hierarchical logics or: How we can do without modal logics. Artif. Intell. 65(1), 29–70 (1994)</rawString>
</citation>
<citation valid="true">
<authors>
<author>J de Kleer</author>
</authors>
<title>Focusing on probable diagnoses.</title>
<date>1991</date>
<journal>In: AAAI.</journal>
<pages>842--848</pages>
<contexts>
<context position="21251" citStr="[18]" startWordPosition="3445" endWordPosition="3445"> specialised algorithms are needed. 23 Investigations whether approximation operators of [11] for logic programs can be translated to MCSs and transferring optimisations for abductive diagnosis (e.g.,[18]) to MCSs are also open tasks. 6 Acknowledgements I am very grateful to my advisor Thomas Eiter, the principal investigator of our research project Michael Fink, and my colleague Peter Schüller who pr</context>
</contexts>
<marker>18.</marker>
<rawString>de Kleer, J.: Focusing on probable diagnoses. In: AAAI. pp. 842–848 (1991)</rawString>
</citation>
<citation valid="true">
<authors>
<author>J McCarthy</author>
</authors>
<title>Notes on formalizing context. In:</title>
<date>1993</date>
<booktitle>IJCAI.</booktitle>
<pages>555--562</pages>
<contexts>
<context position="8481" citStr="[19]" startWordPosition="1324" endWordPosition="1324">planation, it is followed by a short presentation of major achievements in the last two years in Section 4. Finally, Section 5 is an outlook on future work. 19 2 Related Work With the seminal work of [19] and [16] the notion of context has been introduced to artificial intelligence and logic. In these works, a context is a regarded as a certain point of view in which formal reasoning takes place. The </context>
</contexts>
<marker>19.</marker>
<rawString>McCarthy, J.: Notes on formalizing context. In: IJCAI. pp. 555–562 (1993)</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Reiter</author>
</authors>
<title>A theory of diagnosis from first principles.</title>
<date>1987</date>
<journal>Artif. Intell.</journal>
<volume>32</volume>
<issue>1</issue>
<pages>57--95</pages>
<contexts>
<context position="15198" citStr="[20]" startWordPosition="2498" endWordPosition="2498">eads(R2)] �= 1. For a concise characterization, one usually focuses on subset-minimal diagnoses and explanations. The basic ideas behind both notions appear also in Reiter’s seminal work on diagnosis [20]. Our diagnosis is similar to his notion and our explanation is similar to (minimal) inconsistent sets. For differences, we assume the source of inconsistency to be some faulty information exchange, s</context>
</contexts>
<marker>20.</marker>
<rawString>Reiter, R.: A theory of diagnosis from first principles. Artif. Intell. 32(1), 57–95 (1987)</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Roelofsen</author>
<author>L Serafini</author>
</authors>
<title>Minimal and absent information in contexts. In:</title>
<date>2005</date>
<booktitle>IJCAI.</booktitle>
<pages>558--563</pages>
<contexts>
<context position="8894" citStr="[9,21]" startWordPosition="1389" endWordPosition="1389">school (cf. [17,22]) formalized and improved this understanding of context. It is notable, however, that those first frameworks consider homogeneous, monotonic logics for representing a context. With [9,21] non-monotonicity was introduced to Multi-Context Systems. Although default negation is added to bridge rules, contexts still are homogeneous or monotonic. Only with [7] the framework has been general</context>
</contexts>
<marker>21.</marker>
<rawString>Roelofsen, F., Serafini, L.: Minimal and absent information in contexts. In: IJCAI. pp. 558–563 (2005)</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Roelofsen</author>
<author>L Serafini</author>
</authors>
<title>Minimality and non-determinism in multi-context systems.</title>
<date>2005</date>
<journal>In: CONTEXT.</journal>
<pages>424--435</pages>
<contexts>
<context position="8707" citStr="[17,22]" startWordPosition="1364" endWordPosition="1364">n of context has been introduced to artificial intelligence and logic. In these works, a context is a regarded as a certain point of view in which formal reasoning takes place. The Trento school (cf. [17,22]) formalized and improved this understanding of context. It is notable, however, that those first frameworks consider homogeneous, monotonic logics for representing a context. With [9,21] non-monotoni</context>
</contexts>
<marker>22.</marker>
<rawString>Roelofsen, F., Serafini, L.: Minimality and non-determinism in multi-context systems. In: CONTEXT. pp. 424–435 (2005)</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Schüller</author>
<author>Weinzierl</author>
</authors>
<title>A.: Semantic reasoning with sparql in heterogeneous multicontext systems. In: Semantic Search over the Web</title>
<date>2011</date>
<note>to appear</note>
<contexts>
<context position="20054" citStr="[23]" startWordPosition="3269" endWordPosition="3269">formation flow. It directly follows that any acyclic mMCS with totally coherent contexts is consistent, thus proving local inconsistency management sufficient for acyclic MCS. Beyond bridge rules: In [23] we introduce MCS where knowledge exchange is realised using SPARQL construct-queries. This is surprisingly simple and again shows the versatility of MCS. The resulting SPARQL-MCS framework is related</context>
</contexts>
<marker>23.</marker>
<rawString>Schüller, P., Weinzierl, A.: Semantic reasoning with sparql in heterogeneous multicontext systems. In: Semantic Search over the Web (2011), to appear</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Serafini</author>
<author>F Giunchiglia</author>
<author>J Mylopoulos</author>
<author>P Bernstein</author>
</authors>
<title>Local relational model: A logical formalization of database coordination.</title>
<date>2003</date>
<booktitle>In: CONTEXT.</booktitle>
<pages>286--299</pages>
<contexts>
<context position="10306" citStr="[24,10]" startWordPosition="1601" endWordPosition="1601">es to use its knowledge base, however, will not risk its business by providing such information. Aside from MCS, other areas deal with knowledge integration and its issues. Peer-to-Peer (p2p) systems [24,10] are similar as knowledge sources interchange pieces of information. Although the notion of a peer is very similar to a context in MCS, the essential feature of p2p systems is that peers may leave and</context>
</contexts>
<marker>24.</marker>
<rawString>Serafini, L., Giunchiglia, F., Mylopoulos, J., Bernstein, P.: Local relational model: A logical formalization of database coordination. In: CONTEXT. pp. 286–299 (2003)</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>