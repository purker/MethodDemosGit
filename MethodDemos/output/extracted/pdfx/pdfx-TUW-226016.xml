<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>1e10fcf3bf5d6d038521543d90f83745b4ee7aeead26b968f71901e179318fd1</job>
    <base_name>lhz</base_name>
    <doi>http://dx.doi.org/10.1109/icis.2008.34</doi>
    <warning>Name identification was not possible. </warning>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <region class="DoCO:FigureBox" id="Fx1">
        <image class="DoCO:Figure" src="lhz.page_001.image_01.png" thmb="lhz.page_001.image_01-thumb.png"/>
      </region>
      <title-group>
        <article-title class="DoCO:Title" id="2">An Evaluation of Symbol Elimination for Generating First-Order Loop Invariants</article-title>
      </title-group>
      <region class="unknown" id="3">MASTER’S THESIS submitted in partial fulfillment of the requirements for the degree of</region>
    </front>
    <body class="DoCO:BodyMatter">
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="4" page="1" column="1">Diplom-Ingenieurin</h1>
        <region class="unknown" id="5" page="1" column="1">in Computational Intelligence by</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="6" page="1" column="1">Ioana Jucu</h1>
        <region class="DoCO:TextChunk" id="7" confidence="possible" page="1" column="1">Registration Number 1128547 to the Faculty of Informatics at the Vienna University of Technology Advisor: Priv.-Doz. Dr. Laura Kovács Date: 06.10.2013 (Signature of Author) (Signature of Advisor)</region>
        <outsider class="DoCO:TextBox" type="footer" id="8" page="1" column="1">i</outsider>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="9" confidence="possible" page="2" column="1">Erklärung zur Verfassung der Arbeit</h1>
        <region class="DoCO:TextChunk" id="10" confidence="possible" page="2" column="1">Ioana Jucu Martir Herman Sporer, Timisoara, Timis, Romania</region>
        <region class="DoCO:TextChunk" id="11" page="2" column="1">Hiermit erkläre ich, dass ich diese Arbeit selbständig verfasst habe, dass ich die verwendeten Quellen und Hilfsmittel vollständig angegeben habe und dass ich die Stellen der Arbeit - einschließlich Tabellen, Karten und Abbildungen -, die anderen Werken oder dem Internet im Wortlaut oder dem Sinn nach entnommen sind, auf jeden Fall unter Angabe der Quelle als Entlehnung kenntlich gemacht habe.</region>
        <region class="DoCO:TextChunk" id="12" confidence="possible" page="2" column="1">(Ort, Datum)</region>
        <region class="DoCO:TextChunk" id="13" confidence="possible" page="2" column="1">(Unterschrift Verfasserin)</region>
        <outsider class="DoCO:TextBox" type="footer" id="14" page="2" column="1">ii</outsider>
      </section>
      <section class="deo:Acknowledgements">
        <h1 class="DoCO:SectionTitle" id="15" confidence="possible" page="3" column="1">Acknowledgements</h1>
        <region class="DoCO:TextChunk" id="16" page="3" column="1">I would like to express my very great appreciation to Dr. Laura Kovács for her valuable and constructive suggestions during the planning and development of this research work. Her willingness to give her time so generously has been very much appreciated. I would also like to thank Mr. Ioan Dr agan for his support with one of the tools needed.</region>
        <outsider class="DoCO:TextBox" type="footer" id="17" page="3" column="1">iii</outsider>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="18" confidence="possible" page="4" column="1">Abstract</h1>
        <region class="DoCO:TextChunk" id="19" page="4" column="1">Invariant genereation is a critical problem in proving different properties for programs with loops, properties including correctnes. The problem becomes harder with the incresing numbers of quantifiers in the property to be proven. In this paper we study and combine different methods of invariant generation in order to obtain stronger properties.</region>
        <outsider class="DoCO:TextBox" type="footer" id="20" page="4" column="1">iv</outsider>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="21" confidence="possible" page="5" column="1">Kurzfassung</h1>
        <region class="DoCO:TextChunk" id="22" page="5" column="1">Invariant generiert ist ein kritische Problem für Programmen mit Schleife zum Beweisen der Eigenschaften, inclusive die Richtigkeit. Die problem wird schwerer bei hohe Anzhal des Quantoren in die geprüfte Eigenschaft. In diese arbeit wir studiere diese Problem und versuchen combinieren verschieden Methoden für schwarer invariants zu beweisen.</region>
        <outsider class="DoCO:TextBox" type="footer" id="23" page="5" column="1">v</outsider>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="24" confidence="possible" page="6" column="1">Contents</h1>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="25" page="6" column="1">Contents</h1>
        <region class="DoCO:TextChunk" id="26" confidence="possible" page="6" column="1">1 Introduction 1 2 Preliminaries 3 2.1 Propositional logic . . . . . . . . . . . . . . . . . . . . . . . . 3 2.2 SAT solvers . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 2.3 Boogie . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 3 Overview of Invariant Generation Methods 13 3.1 GinPink . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 3.2 Lingva . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 3.3 CppInv . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 4 Experiments 22 4.1 Experiments with Gin-Pink and Cpp-Inv . . . . . . . . . . . . 22 4.2 Experiments with Lingva . . . . . . . . . . . . . . . . . . . . 28 4.3 Discussions of Experimental Results . . . . . . . . . . . . . . 37 5 Invariant Specific Theory Extensions to First Order Theorem Prover 41 5.1 Comparison of invariants strength . . . . . . . . . . . . . . . 41 5.2 Discussions and Conclusions . . . . . . . . . . . . . . . . . . . 53 6 Conclusions 55 7 References 57</region>
        <outsider class="DoCO:TextBox" type="footer" id="27" page="6" column="1">vi</outsider>
      </section>
      <section class="deo:Introduction">
        <h1 class="DoCO:SectionTitle" id="28" page="7" column="1">1 Introduction</h1>
        <region class="DoCO:TextChunk" id="30" page="7" column="1">The complexity of software systems is in a continuous grow. Making sure that different pieces of the same system will work together properly is a hard task. The development of software systems imply the work of more people working at different parts of it, using computer, networks, physical devices, and over millions of lines of code in various languages. Integrating, understanding and ensuring the reliability of such a system are necessary task in order to make it useful. In this paper we give attention to the task of ensuring reliability. In the past years a lot of interest was given to this task and there were developed different methods to do it, but one challenge that was not yet overcome is the analysis of loops. In particular programs dealing with arrays use loops to process the elements, and on the strength to the unbounded nature of this data structures analyzing and inferring properties for elements becomes a challenging problem on its own. One way to approach this problem is to bound the loop [<xref ref-type="bibr" rid="R3" id="29" class="deo:Reference">BCC + 03</xref>], unfolding it just a limited number of times and afterwards analyzing the new obtained program as if no loop would occur in it. Although this approach is successfully used in model checking techniques, the limitations of applying it consist in the loss of completeness of the algorithm. An informal explana- tion of this fact is that obtaining a proof that a bounded subset of elements do not have a certain property is a result strong enough to consider that the property does not hold for the entire loop, but if the property holds for the first n unrollings of the loop it may be the case that it will be falsified in one of the following iterations that were cut off by the bound. Another approach to reason about program loops is to statically analyze the code and extract loop properties automatically. In this thesis we follow this approach. We are going to analyze and compare three methods that automatically extract properties for loops. These methods are the symbol elimination method of [KV09], the constraint-based invariant generation approach of [LRCR13], and the postcondition-based method of [FM10]. We analyze and compare these approaches on series of challenging academic examples which are considered difficult to reason about. The symbol elimination technique is an automatically mechanism that generates invariants based on the static analysis of programs, that does not require other information from the user about the code analyzed. For this method we use a saturation theorem prover and we choose Vampire not only for it’s capability to reason with different theories but also due to the fact that is one of the fastest provers awarded several times in competitions. The constraint-based method first analyses the code discovering every possible path and checking if properties hold in some key points along them. In the next chapters we are going to explain where and why a point in the path becomes such a key point. Properties that are checked are constructed</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="31" page="7" column="1">1</outsider>
        <region class="DoCO:TextChunk" id="32" confidence="possible" page="8" column="1">based on a template following some rules that will also be presented later in the paper. The third method is the only one from the three presented that needs additional input from the user, namely a postcondition in the form of a formula. The program makes certain changes in the formula, that will be described later on, in order to find valid invariants for the program. Using the invariants discovered by the constraint-based and postcondition- based methods, in this thesis we further extend the power of symbol elimination in order to reason about more complex loops and invariants than in [KV09]. For doing so, we strengthen the underlining first-order theory reasoning engine of symbol elimination and add additional mathematical theorems and axioms to the symbol elimination problem. The symbol elimination problem is then further fed into a saturation theorem prover and is successfully used to prove the intended loop invariants and properties of the program. Our results show that theory reasoning in first-order theorem proving is a very challenging problem and requires a good understanding of the necessary theory axiomatizations.</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="33" page="8" column="1">2</outsider>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="34" page="9" column="1">2 Preliminaries</h1>
        <region class="DoCO:TextChunk" id="35" page="9" column="1">In this section we give a brief overview of SAT solving , SMT solving and Saturation theorem prover . Also we give insight of the mechanism of Boogie theorem prover. These are necessary for further understanding the mechanism of the tools we are studying in this paper, and since all of them have at their core first-order logic we also present its syntax and semantics. We present all the above in a step wise manner starting with propositional logic. Based on the syntax and semantic of propositional logic it is easier to understand the ones of first-order logic, since the latter one extends the expressive power of the former by introducing new characters and concepts. In the same step wise manner we present SAT-solving and SMT-solving. The first problem is related to propositional logic, while the second one makes use of the results obtained in SAT-solving as a subroutine in the algorithm for solving problems encoded in first-order logic. Also we present the mechanism of a saturation theorem prover, The understanding of this concept is necessary in order to understand the differences between the methods of invariant generation and the properties that make them efficient in different types of problems. Another point that is touched in this chapter is the higher order logic theorem prover Boogie , that has more expressive power than the other tools introduced in this paper and also uses a language specially created for it that has a syntax harder to understand than the others. We are going to present how these concept interact to each other and with the underlying theory, relating their results with the concept of program verification.</region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="36" page="9" column="1">2.1 Propositional logic</h2>
          <region class="DoCO:TextChunk" id="37" page="9" column="1">Is a part of mathematics important for program verification. The least complex component in the syntax of propositional [DW50] logic is an atom . Every atom has a truth value, either true or false, and it represents a statement (such as “ Roses are red.”) without taking into account its internal structure. In order to get more complex propositions the atoms can be connected with connectives . The propositional syntax is defined as follows:</region>
          <region class="DoCO:TextChunk" id="38" confidence="possible" page="9" column="1">1. If p is an atom, then p is a proposition; 2. and ⊥ are propositions; 3. If p is a proposition, ¬ p is a proposition; 4. if p and q are propositions, then p ◦ q is a proposition, where ◦ ∈ {∧ , ∨ , ⇒ , ⇔}</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="39" page="9" column="1">3</outsider>
          <region class="DoCO:TextChunk" id="40" page="10" column="1">Given two propositions, p and q , the following statements hold for the described connectives: • ¬ (“negation”), if ¬ p is true if p is false, and false otherwise;</region>
          <region class="DoCO:TextChunk" id="41" confidence="possible" page="10" column="1">• ∧ (“and”), if p is true and q is true then p ∧ q is true, otherwise p ∧ q is false; • ∨ (“or”), if one of the the two propositions are set to true then p ∨ q is true, otherwise p ∨ q is false; • ⇒ (“if...then”), if p is true and q is true, or if q is false p ⇒ q is true, otherwise is false;</region>
          <region class="DoCO:TextChunk" id="42" page="10" column="1">• ⇔ (“if and only if...then”), if p and q are set to the same truth value then p ⇔ q is true, otherwise is false; To make the propositions easier to read and write, and to save parenthe- ses the connectives have priorities as follows: ¬ , ∧ , ∨ , ⇒ , ⇔ (meaning that ¬ binds stronger than ∧ , ∧ binds stronger than ∨ , etc.). The problem of determining if the atoms that form a proposition can be given truth values in such a way that the proposition would evaluate to true is called satisfiability problem (abbreviated as SAT). Example: p, r, q are atoms in propositional logic, and p ∨ q ⇒ r ∨ q is a syntax correct formula. Choosing the values as follows: p → f alse , r → f alse and q → true will cause the formula to evaluate to true (since p ∨ q evaluates to true , r ∨ q evaluates to true ). Satisfiability problem is an NP-complete problem[Coo71]. The complexity and nature of this problem makes it useful in modeling different problems such as digital circuits, constraint satisfaction problems, reasoning about specifications.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="43" page="10" column="1">2.2 SAT solvers</h2>
          <region class="DoCO:TextChunk" id="49" page="10" column="1">These are tools that are constructed to solve SAT problems [ES04]. Despite the high complexity of the problem, very good results were obtained in practice with yearly improvements of the solving algorithms and heuristics for the SAT-solving contest. In <xref ref-type="fig" rid="F1" id="44" class="deo:Reference">figure 1</xref> we present a scheme on how a SAT solver is used to solve a problem. The first step is to abstract the problem into a set of propositions. Usu- ally the problem can not be abstracted straightforward so some simplification is needed. After finding a suitable representation of the problem as a set of formulae use a SAT solver to find a solution. If a solution is not find specific improvements are made in order to get a more efficient search. The SAT solvers take the input formulae in a special form named conjunctive normal form . Every propositional formula can be transformed in<marker type="page" number="11"/><marker type="block"/> an equi-satisfiable formula that satisfies the conditions of the CNF [G.S83]. A formula is said to be in conjunctive normal form if it is a conjunction of clauses , where a clause is a disjunction form from atoms or negation of atoms. The next algorithm called boolean constant propagation (BCP) [TH06] is a part of the algorithm that stays at the basis of a lot of modern SAT solvers.This is a very short algorithm with three steps that repeat as long as possible:</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="46" page="10" column="1">4</outsider>
          <region class="DoCO:FigureBox" id="F1">
            <image class="DoCO:Figure" src="lhz.page_011.image_02.png" thmb="lhz.page_011.image_02-thumb.png"/>
            <caption class="deo:Caption" id="48" page="11" column="1">Figure 1: SAT solver structure</caption>
          </region>
          <region class="DoCO:TextChunk" id="50" confidence="possible" page="11" column="1">1. find clause that contains a single literal (also named unit clause ); 2. eliminate all clauses that contain the literal; 3. in all other clauses eliminate the occurrence of the negation of the literal;</region>
          <region class="DoCO:TextChunk" id="53" page="11" column="1">The DPLL[DL62] algorithm was developed in 1962 and still used to this day in the state of the art SAT solvers. One variant of the algorithm is this: DPLL(F) F := BCP(F) if F = return s a t i s f i a b l e if ⊥ ∈ F return u n s a t i s f i a b l e p i c k r e m a i n i n g v a r i a b l e x and l i t e r a l l ∈ { x , ¬ x } i f DPLL(F ∧ { l } ) r e t u r n s s a t i s f i a b l e return s a t i s f i a b l e r e t u r n DPLL(F ∧ {¬ l } ) The idea of the algorithm is simple and efficient. First boolean constant propagation is applied, if there are no more clauses remaining, the algorithm <marker type="page" number="12"/><marker type="block"/> returns satisfiable, if a clause becomes empty after this step the algorithm returns unsatisfiable. Otherwise a literal is selected from the remaining clauses and DPLL is called on these clauses plus an extra unit clause containing the selected literal. The selection of the literal has a great significance in the efficiency of the SMT solver. A lot of heuristics were developed an studied in order to get better results. These are a few ideas that were used for the heuristics:</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="52" page="11" column="1">5</outsider>
          <region class="DoCO:TextChunk" id="55" confidence="possible" page="12" column="1">• Dynamic Largest Individual Sum[MSS99]: the literal that appears most often in the unsatisfied clauses at the current point is chosen; • Jeroslov-Wang heuristic[Wan95]: the choices are made such that a unit clause is soon obtained; • VSIDS[<xref ref-type="bibr" rid="R22" id="54" class="deo:Reference">MMZ 11</xref>]: + is a complex heuristic that takes into account partial assignments that are unsatisfiable, and based on a directed acyclic graph of the solution it chooses a literal that is part of the unsatisfied clause;</region>
          <region class="DoCO:TextChunk" id="56" page="12" column="1">Although SAT cover a significant range of problems, propositional logic is not expressive enough to cover other problems of practical interest, this is why first order logic got attention for this purpose. Since the problem of satisfiability is harder in this logic there were restrictions made with respect to some theory . This new problem is referred to as Satisfiability Modulo Theory (SMT) [dMB11]. The first order logic (FOL) syntax is more complex[And02]. There are two extra logical symbols to propositional logic: the quantifiers ∀ (universal- for representing judgments that are true for all objects) and ∃ (existential- for representing particular judgments). There are also two other types of symbols: functions and predicates . Function symbols together with the predicates symbols along with their arity form the signature . Terms in FOL are defined inductively as follows: • every variable is a term; • if t 1 , t 2 ...t n are terms and f is a function symbol with arity n then f ( t 1 , t 2 , ...t n ) is a term; The signature is a countably set of predicate symbols and function symbols together with their arity. The set of formulas are defined inductively in the following way:</region>
          <region class="DoCO:TextChunk" id="57" confidence="possible" page="12" column="1">• and ⊥ are formulae; • if t 1 , t 2 ...t n are terms and p is a function symbol with arity n then p ( t 1 , t 2 , ...t n ) is a formula; • if φ is a formula then ¬ φ is a formula;</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="58" page="12" column="1">6</outsider>
          <region class="DoCO:TextChunk" id="59" confidence="possible" page="13" column="1">• if φ and φ are formulae then also φ ◦ φ is a formula where ◦ ∈ {∧ , ∨ , ⇒ , ⇔} ; • if φ is a formula and x a variable then ∃ xφ and ∀ xφ are formulae;</region>
          <region class="DoCO:TextChunk" id="60" page="13" column="1">A variable is called free if it is not bounded by a quantifier ( ∃ , ∀ ). Example : ∀ x, p ( x ) ⇒ p ( y ), x is bounded by the existential quantifier while y is a free variable. The semantics of a first order logic formula is given by an interpretation . The interpretation consist of an non-empty domain U and an interpretation function I (). The interpretation function maps in the following way given the domain U :</region>
          <region class="DoCO:TextChunk" id="61" confidence="possible" page="13" column="1">• every function symbol of arity 0 ( constant symbol ) with a element from the domain; • every for every function symbol f with arity &gt; 0 I ( f ) : U n → U (for every n combination of terms the value of the function for the combination is a value in the domain); • for every predicate symbol p with arity n I ( p ) : U n → { 1 , 0 } (for every n combination of terms the value of the function for the combination is a value in the set { 1 , 0 } , 1 representing true and 0 representing f alse )</region>
          <region class="DoCO:TextChunk" id="70" page="13" column="1">The free variables can be interpreted in two ways: either universally quantify the formula or bound the variable to a constant in the domain. A theory in first order logic is considered any set of formulae that do not contain free variables[DP60]. A formula without any free variables is also called sentence . A SMT-solver is a tool that takes as input a set of first order formulae and gives as output the answer satisfiable or unsatisfiable, taking into account information and methods of some first order theories when needed. In <xref ref-type="fig" rid="F2" id="62" class="deo:Reference">figure 2</xref> there is the structure of a modern SMT-solver [DdM06]. The core solver in the figure refers to a solver that can solve the satisfiability problem for equality and uninterpreted functions theory, while the satellite solver handles other theories such as arithmetical, arrays, bit vectors, or data types. Let there be observed that the satellite solver exchanges information only with the core solver, the core solver communicates both with the satellite solver and the SAT-solver, and the SAT solver communicates only with the core solver. A general algorithm for SMT solver [AAR09]is presented in the following lines: SAT − v a l u e SMT solver (T − f o r m u l a φ ) { φ = convert t o c nf ( φ )<marker type="page" number="14"/><marker type="block"/> φ p =T2P( φ ) w h i l e (DPLL( φ p , μ p )==SAT) { ρ, η = T − solver ( P 2 T ( μ p ) ) i f ( ρ == SAT ) r e t u r n s a t φ p = φ p ∧ T 2 P ( ¬ η ) } return unsat } The algorithm takes as input a a formula in the theory T an outputs satisfiable or unsatisfiable. The first step is to convert the formula in it’s CNF form and store this form in a new variable φ . φ is abstracted into its propositional form (by the ( T 2 P ) function) and stores the new propositional formula in φ p . The DPLL algorithm takes as input the propositional formula and either returns unsatisfiable which makes the initial algorithm to return unsatisfiable, or it returns a satisfying assignment on the literals of the formula. The T − solver then checks the mapping of the formula back to the theory (with the assignment proposed by SAT-solver) and either returns satisfiable, which causes the main algorithm to exit with the status satisfiable, or it returns a set η of literals that caused an inconsistency in the theory. η is abstractive to propositional logic and its negation is conjuncted with the rest of the abstractisation of the formula formula, and DPLL is called again on the new obtained formula. Given a hypotheses (in this case this is the formula) if we can reach the empty set (refutation) by using an inference system , this would give us a refutation proof . An inference system is a set of inference rules . An inference rule is can be described as being an n -ary relation on formulas, with n ≥ 0. The elements of such relations are called inferences and usually written as F 1 ...F n . F<marker type="page" number="15"/><marker type="block"/> Algorithms were developed in order to obtain interpolants and invariants from the proofs of unsatisfiability outputted by an SMT-solver. A theorem prover is a tool used to prove theorems in different logics. A specific type of theorem provers are the saturation theorem provers. We say that a set of formulas is saturated with respect to an inference system I if we can find another set of formulas containing the initial one that is closed under inference with respect to I [<xref ref-type="bibr" rid="R19" id="69" class="deo:Reference">KV09</xref>]. The saturation theorem prover. Vampire , used for this study is using a superposition inference system. In order to give a brief description of this system first we introduce the notion of simplification ordering on terms[KVar]. If an ordering has the following properties it is considered a simplification ordering: • is well-founded, that is there exists no infinite sequence of terms t 0 , t 1 , . . . such that t 0 t 1 . . . ; • is monotonic: if l r , then s [ l ] s [ r ] for all terms s, l, r ;</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="64" page="13" column="1">7</outsider>
          <region class="DoCO:FigureBox" id="F2">
            <image class="DoCO:Figure" src="lhz.page_014.image_03.png" thmb="lhz.page_014.image_03-thumb.png"/>
            <caption class="deo:Caption" id="66" page="14" column="1">Figure 2: SMT solver structure</caption>
          </region>
          <outsider class="DoCO:TextBox" type="page_nr" id="68" page="14" column="1">8</outsider>
          <region class="DoCO:TextChunk" id="71" confidence="possible" page="15" column="1">• is stable under substitutions: if l r , then lθ rθ (where a substitution θ is considered a simultaneously replacement of all occurrences of a set of terms with another corresponding set of terms,respectively, in a formula);</region>
          <region class="DoCO:TextChunk" id="72" page="15" column="1">• has the subterm property: if r is a subterm of l and l = r , then l r . A selection function is a function that selects one or more literals from a non-empty clause. In what follows, selected literals will be underlined (if L is a selected literal then it would be written as L ). A unifier of two expression is a substitution that would make the expressions equal. The inference rules for a superposition inference system are the following: Resolution : A ∨ C 1 ¬ A ∨ C 2 ( C 1 ∨ C 2 ) θ where θ is a mgu of A and A . Factoring :</region>
          <region class="DoCO:TextChunk" id="73" confidence="possible" page="15" column="1">A ∨ A ∨ C ( A ∨ C ) θ where θ is a mgu of A and A . Superposition : l = r ∨ C 1 L [ s ] ∨ C 2 l = r ∨ C 1 t [ s ] = t ∨ C 2 ( L [ r ] ∨ C 1 ∨ C 2 ) θ ( t [ r ] = t ∨ C 1 ∨ C 2 ) θ l = r ∨ C 1 t [ s ] = t ∨ C 2 ( t [ r ] = t ∨ C 1 ∨ C 2 ) θ</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="74" page="15" column="1">9</outsider>
          <region class="DoCO:TextChunk" id="75" confidence="possible" page="16" column="1">where the following hold: θ is an mgu for l and s , s is not a variable, rθ lθ , in the first rule L [ s ] is not an quality literal, in the last two rules t θ t [ s ] θ . Equality Resolution : s = t ∨ C Cθ where θ is the mgu of s and t. Equality factoring : s = t ∨ s = t ∨ C ( s = t ∨ t = t ∨ C ) θ</region>
          <region class="DoCO:TextChunk" id="76" page="16" column="1">where θ is an mgu of s and s , tθ sθ , t θ tθ . A set S of clauses is saturated with respect to an inference system if for every possible combination of the clauses and for every rule in the system, a clause that is already in the system is inferred. A saturation algorithm is considered fair if all possible combinations of clauses and every rule get a chance to be applied at one point. In order for such an algorithm to be useful in practice it needs to be sound and complete . A complete saturation algorithm will eventually derive the empty clause if the set of clauses is unsatisfiable, and a sound saturation algorithm will correctly conclude that the set of clauses is unsatisfiable if the empty clause is derivable from it. A complete and sound saturation algorithm can have the following outputs in practice:</region>
          <region class="DoCO:TextChunk" id="77" confidence="possible" page="16" column="1">• unsatisfiable, if the empty clause is generated; • satisfiable, if the set of clauses is saturated; • unknown, if the algorithm runs forever (until it runs out of resources) and the empty clause is not derived.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="78" page="16" column="1">2.3 Boogie</h2>
          <region class="DoCO:TextChunk" id="87" page="16" column="1">Is a modular reusable verifier for object-oriented Programs [ <xref ref-type="bibr" rid="R4" id="79" class="deo:Reference">BCD 05</xref>]. + This tool is made from different components: a source programming language, its usage rules and formal semantics, a logical encoding suitable for automatic reasoning, abstract domains for program analysis and property inference, decision procedures for discharging proof obligations, and a user interface that lets a user understand the results of the verification process[BMSW10]. A representation of how all the components of Boogie interact is represented in <xref ref-type="fig" rid="F3" id="80" class="deo:Reference">figure 3</xref>. The source programming language , Spec#, is a high-level, strong typed language. It is a superset of the C # programming language, giving also<marker type="page" number="17"/><marker type="block"/> the possibility to write preconditions, postconditions and object invariants. Apart from the compilers checks for static types, it also creates conditions for the dynamic types as part of the target code. Boogie tries to checks statically also the dynamic types properties enforced by the compiler along with the ones provided by the user and those defined by the virtual machine. The source code is compiled into CIL language. The CIL code is obtained from an abstract syntax tree either directly from the compiler, which enables Boogie to work as part of the compiler and offer information to the user in a design-time manner, or from an already compiled .dll or .exe file. The intermediate language is obtained by translating the CIL code in BoogiePL code. This process enables the writing of new statements: assert and assume . The assert statements are encode conditions that will be checked by the program verifier, and the assume statements encode properties that can be used by the verifier, these properties being enforced by the source language and the verification process. Also BoogiePL permits the encoding of theories and mathematical symbols. Since BoogiePL has a textual representation small changes can be made in this file without dam- aging the Spec# code. Also the textual representation makes Boogie useful for other verifier, making the verification conditions reusable. At this point the code is replaced with the proof task. The BoogiePL code is transformed into first order logic properties. For this process loop invariants are needed, and since providing this by hand is troublesome and sometimes impossible, Boogie offers a framework that automatically infers loop invariants from BoogiePL code, written in the form of “assume” statements. The next step is to get verification condition from every basic block of<marker type="page" number="18"/><marker type="block"/> the program. These are written in first order logic with arithmetic, and since there are more ways to write the same condition, the chosen form affects the performance of the theorem prover. Also the encoding of the conditions are made in such a way that if the verification fails a trace of failure can be mapped back in the original input language. A failure in verification can also be only spurious since the theorem prover is incomplete, and also it might be the case the the theorem prover could not do the task due to the fact that there were not enough resources.</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="82" page="16" column="1">10</outsider>
          <region class="DoCO:FigureBox" id="F3">
            <image class="DoCO:Figure" src="lhz.page_017.image_04.png" thmb="lhz.page_017.image_04-thumb.png"/>
            <caption class="deo:Caption" id="84" page="17" column="1">Figure 3: Boogie pipeline</caption>
          </region>
          <outsider class="DoCO:TextBox" type="page_nr" id="86" page="17" column="1">11</outsider>
          <outsider class="DoCO:TextBox" type="page_nr" id="88" page="18" column="1">12</outsider>
        </section>
      </section>
      <section class="deo:Methods">
        <h1 class="DoCO:SectionTitle" id="89" page="19" column="1">3 Overview of Invariant Generation Methods</h1>
        <region class="DoCO:TextChunk" id="90" page="19" column="1">There is a large variety of invariant generation approaches researched in the past years. In this chapter we present three of this methods which cover a large area of invariants that can be inferred and represent the state of the art in their representative domain. The tools implementing this methods were made available by their respective researchers. Although other methods were considered for this thesis the tools implementing them were not available at the moment from different reasons. The approach suggested has one of the following starting points for obtaining the result: post-conditions, saturation theorem proving, use of predefined templates. In what follows we are going to give an insight of the idea used in each of the three methods.</region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="91" page="19" column="1">3.1 GinPink</h2>
          <region class="DoCO:TextChunk" id="97" page="19" column="1">This method makes use of the postconditions provided by the user in order to find an invariant for a certain loop in the procedure [FM10]. There are four different heuristics that are used to weaken the postcondition: constant relaxation, variable aging, uncoupling, term dropping. Constant relaxation replaces a constant in the postcondition with a variable. A constant is considered a variable that is not modified by the loop, and a variable - in this context- is a variable modified by the loop. An example were this heuristic is used is: <marker type="block"/> In this program all elements of an array are initialized with the value 0. By relaxing the constant n in the postcondition by the variable i an invariant is obtained. In some cases just substituting a constant with a variable does not yield an invariant, depending on the update time of the variable. Variable aging replaces a constant with an expression involving a variable.<marker type="page" number="20"/><marker type="block"/> Although the above example is similar to the one given for constant relaxation heuristic we observe that the same invariant no longer holds, because of the updating manner of the When invariants are conjunctions of formulas there might be the case that substituting a constant with one variable on both sides of the conjunction does not result in an invariant. Uncoupling is the heuristic that replaces one constant with different variables at different occurrences in the postcondition resulting in an invariant.</region>
          <region class="unknown" id="93" page="19" column="1">procedure ArrayInit &lt;tt&gt; ( A: array tt, left: int, right: int, index: int) returns (i:int) requires left &lt;= right; ensures (forall k: int :: k != n ==&gt; A[k] == 0); { var i: int; i:= left; index:= left; A[left]=0; while(i&lt;= right) invariant (index &lt;= i); { i=i+1; A[i]:=0; } }</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="95" page="19" column="1">13</outsider>
          <region class="unknown" id="96" page="20" column="1">procedure ArrayInit &lt;tt&gt; ( A: array tt, left: int, right: int, index: int) returns (i:int) requires left &lt;= right; ensures (forall k: int :: k != n ==&gt; A[k] == 0); { var i: int; i:= left; index:= left; while(i&lt;= right) invariant (index &lt;= i); { A[i]:=0; i:= i+1; } }</region>
          <region class="DoCO:TextChunk" id="98" confidence="possible" page="20" column="1">partition (A: ARRAY [T]; n: INTEGER; pivot: T): INTEGER require A.length = n ≤ 1 local low index, high index : INTEGER do from low index := 1; high index := n until low index = high index loop from | no loop initialization until low index = high index ∨ A[low index] &gt; pivot loop low index := low index + 1 end from | no loop initialization until low index = high index ∨ pivot &gt; A[high index] loop high index := high index 1 end A.swap (A, low index, high index) end if pivot ≤ A[low index] then low index := low index 1 high index := low index end Result := low index</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="99" page="20" column="1">14</outsider>
          <region class="DoCO:TextChunk" id="100" confidence="possible" page="21" column="1">ensure ( ∀ k 1 ≤ k ∧ k &lt; Result + 1 = A [ k ] ≤ pivot ) ∧ ( ∀ k Result &lt; k ∧ k ≤ n = A [ k ] ≥ pivot )</region>
          <region class="DoCO:TextChunk" id="101" page="21" column="1">The postcondition is assumed to be in conjunction normal form so applying term dropping , means removing some terms from the formula in order to weaken it. An example where this method is applied is if in the function P artition we would like to ensure only ∀ kResult &lt; k ∧ k ≤ n = A [ k ] ≥ pivot . This is still an invariant for the code. In order to find the invariants for the loop, the algorithm considers first the postcondition without any weakening, and afterwards apply the four mentioned heuristics and check if the resulting formulas are invariants for the loop. The first heuristic applied is constant relaxation. There are to sets of candidates resulting from this step. The first set of candidates is obtained by replacing every occurrence of a constant with the same variable. The second set of candidates are obtained by uncoupled replacement of constants with variables. This method relies on the Boogie verification tool to generate and prove verification conditions of programs. Proving verification conditions is done by using SMT reasoning.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="102" page="21" column="1">3.2 Lingva</h2>
          <region class="DoCO:TextChunk" id="103" page="21" column="1">The idea of this method is to generate invariants of the loop in the form of first order logic formulae, by statically analyzing the code [CC77], and afterwards use theorem prover Vampire to eliminate the auxiliary symbols that occurred. For this method the guarded assignments were introduce[Dij75, MP92]. These are expressions of the form G → α 1 ; α 2 ; ...α m , where α i is either a scalar variable assignment or an array variable assignment, and G a formula (called guard). The guards must be mutually exclusive but at least one of them true in every state. There must not be two assignments guarded by the same expression that can modify the same array term at one point, and the left- hand side of all assignments should be different. After the loop is transformed such that it consist only of guarded assignments a static analysis tool is used ( Aligator [HHKR10]) to get invariants over scalar variables. From the invariants obtained loop properties are extracted. In order to deal with loop invariants there are introduced two predicates, named update predicate: upd V ( i, p ) (at iteration i the array V is updated at position p), upd V ( i, p, x ) (at iteration i the array v is updated at position p with the value x). These two predicates help us express two key properties for the arrays:</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="104" page="21" column="1">15</outsider>
          <region class="DoCO:TextChunk" id="105" confidence="possible" page="22" column="1">• an element in the array V , V [ p ], is a constant if V is never updated at position p ; • if an element V [ p ] of an array V is last updated at iteration i , then this is the iteration in which V [ p ] gets its final value.</region>
          <region class="DoCO:TextChunk" id="106" page="22" column="1">Another property that can be extracted from the loop is constant array , meaning that there is an array that is never updated.In this situation, adding in V ampire the property ( ∀ i )( A ( i ) = A 0 ) helps on getting more useful invariants. Monotonicity properties can also be discovered at scalar variables by using a program analysis tool or a light-weight analysis. Variables can be strictly increasing/decreasing ( ∀ i, ( v ( i +1) &gt; v ( i ) )/ ∀ i, ( v ( i +1) &lt; v ( i ) )), increasing/decreasing, dense increasing/decreasing (meaning that the value of the variable is changed with at most 1 from the previous iteration). Another class of properties that can be found are update properties of monotonic variables . These properties refer to the fact that there is an iteration i in the loop that modifies a monotonic variable when the value of this variables can be bounded in an interval. Also the guarded assignments are transformed in properties that can be added to V ampire as theorems in order to get useful invariants. After getting as many properties as possible V ampire is run on them so it would derive invariants without using the auxiliary functions and predicate symbols that were introduced in order to get scalar variables properties. V ampire was chosen for this method because it can reason with linear integer arithmetic and it has implemented procedures to eliminate symbols. New axioms were introduced in V ampire in order to be able to deal with integer arithmetic:</region>
          <region class="DoCO:TextChunk" id="107" confidence="possible" page="22" column="1">• x ≥ y ⇔ x &gt; y ∨ x = y ; • x &gt; y ⇒ x = y ; • x ≥ y ∧ y ≥ z ⇒ x ≥ z ; • s ( x ) &gt; x ;(where s(x) is the successor function); • x ≥ s ( y ) ⇒ x &gt; y ;(where s(x) is the successor function).</region>
          <region class="DoCO:TextChunk" id="110" page="22" column="1">These new axioms enable a sound but incomplete reasoning. Another trick is used to make V ampire deal with symbol elimination. First there are introduced new axioms for every assignment that has on the left hand-side a variable v : v (0) = v 0 , v ( n ) = v , where v (0) , v ( n ) are representing variable v before the first iteration and after n-th iteration respectively. The newly introduced symbols are called target symbols . The goal is to derive only classes that contain only target symbols, interpreted symbols or skolem functions, but at least one target symbol or skolem function. Giving <marker type="page" number="23"/><marker type="block"/> high precedence in the algorithm used by V ampire too the symbols that are not interesting in deriving the new clauses, vampire will eliminate these first. Every clause derived that respects the above conditions and do not contain a skolem function is an invariant. TPTP is the language used by V ampire so in order to encode problems and to understand the proofs outputted we give a short table with the corre- spondence between the first-order logic symbols and mathematical symbols and TPTP:</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="109" page="22" column="1">16</outsider>
          <region class="DoCO:TextChunk" id="111" confidence="possible" page="23" column="1">first-order logic TPTP and mathematics $ true ⊥ $ f alse F 1 ∧ . . . ∧ F n F 1 &amp; . . . &amp; F n F 1 ∨ . . . ∨ F n F 1 | . . . | F n F 1 → F 2 F 1 = &gt; F 2 F 1 ↔ F 1 F 1 &lt; = &gt; F 2 ∀ x 1 . . . ∀ x n F ![ X 1 . . . X n ] : F ∃ x 1 . . . ∃ x n F ?[ X 1 . . . X n ] : F − a $ uminus ( a ) a ≤ b $ lesseq ( a, b ) a&lt;b a&lt;b a + b $ sum ( a, b ) a ∗ b $ product ( a, b )</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="112" page="23" column="1">3.3 CppInv</h2>
          <region class="DoCO:TextChunk" id="113" page="23" column="1">The basic idea of this method is to use a predefined set of template properties and check which ones are invariants. The programs are seen as transition systems of the form P = u, L , l 0 , T , where u is a set of variables, L is a set of locations, l 0 is the initial location and T is the set of transitions. A transition is a tuple l i , l j , pρ t , where l i , l j are locations, and ρ t is a boolean formula representing the transformation of the program variables after the transition. Take for example the following function that initializes an array with the value 0: i n t main ( ) { c o n s t i n t N; assume (N &gt; = 0 ) ; i n t A[N ] ;</region>
          <region class="DoCO:TextChunk" id="114" confidence="possible" page="23" column="1">i n t i =0;</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="115" page="23" column="1">17</outsider>
          <region class="DoCO:FigureBox" id="F4">
            <image class="DoCO:Figure" src="lhz.page_024.image_05.png" thmb="lhz.page_024.image_05-thumb.png"/>
            <caption class="deo:Caption" id="117" page="24" column="1">Figure 4: Transition System</caption>
          </region>
          <region class="DoCO:TextChunk" id="123" page="24" column="1">w h i l e ( i &lt; N) { A[ i ] = 2 ∗ i +3; i ++; } } The corresponding transition system is represented in <xref ref-type="fig" rid="F4" id="118" class="deo:Reference">figure 4</xref> . A cyclic path is a path that contains a cycle. A cut-set is a set of locations such that every cyclic path in the graph contains a location that there is also in the cut-set. The locations in the cut-set are called cutpoints. For this method there are considered the initiation paths, which are the paths in the control-flow graph that connects a location from outside a strongly connected component the a location inside it, and the consecution paths, that label edges only inside the strongly connected component.<marker type="block"/> Theorem 3.1 Let l 1 C , ..., l p C be a cut-set of a strongly connected components. Let P 1 , ...P p be properties over the program variables u such that: • for all initiation paths π I from l to l i C : ∀ u, u ρ φ I ⇒ P i • for all consecution paths π C from l j C to l i C : ∀ u, u ρ φ C ∧ P j ⇒ P i Then P 1 , ..., P p are invariants at l I , ..., l p C . We say P I , ..., P p are inductive invariants.<marker type="block"/> The semantics of the above theorem is given as follows: We have a set of strongly cut-set for a given strongly connected component and a set of properties over some variables. In order for a property to be considered an invariant there are two conditions that must be fulfilled: for all initial paths to one of the cutpoints, for all variables the formula describing the transition<marker type="page" number="25"/><marker type="block"/> relation between the initial value of the variable and the value obtained after the transition must imply the corresponding property. The second condition is that for consecution paths from one point l i C to l j C , for all variables the formula describing the transition relation between the values of the variables from one location to the other in conjunction with the property that holds at the second location (with respect to the value of the variables at the first location), implies the property that holds at the firs location with the values of the variables obtained after the transition. Using the previous theorem and formalizing the implications as constraints containing both program variables and (not yet known) parameters, invariants can be obtained by finding a solution to the constraints. For arrays the method generates invariants of the form: ∀ α : 0 ≤ α ≤ C ( v ) − 1 : m i =1 k j =1 α ij A i [ d ij α + ε ij ( v )] + B ( v ) + b α α ≤ 0 where:</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="122" page="24" column="1">18</outsider>
          <region class="DoCO:TextChunk" id="124" confidence="possible" page="25" column="1">• C, ε ij B are polynomials with integer coefficients and variables in v = ( v 1 , v 2 , ..., v n ) • a ij , d ij , b α ∈ Z , ∀ i ∈ { 1 , ..., m } , j ∈ { 1 , ..., k } • a = ( A 1 , ..., A m ) the tuple of array variables For computational reasons the invariant generation has three steps: • expressions C are generated in such a way that the domain { 0 ...C − 1 } is empty after initial paths, and C is increased with at most one after consecution paths; • find expressions d i α + ε i for every array and every C found such that these are valid access points in the array, after executing a consecution path the already analyzed positions are not changed, and after consecution paths ε i has the same value or the value ε i − d i ; • for every array choose k ε ij that either all stay the same or get new values after consecution paths;</region>
          <region class="DoCO:TextChunk" id="126" page="25" column="1">• find α ij , b α , B to fulfill the property depending on the which case is ε ij ; While theorem 3.1 can be applied in the case of linear scalar properties, this is not the case for the array properties, that is another theorem was formulated for this case: <marker type="block"/> Theorem 3.2 Let C, B , ε ij be linear polynomials with integer variables over the scalar variables, and a ij , d ij , b α ∈ Z for i ∈ { 1 , ..., m } and j ∈ { 1 , ...k } . If 1. Every initiation path π r I with transition relation ρ φ I r satisfies ρ φ r I ⇒ C =0</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="127" page="25" column="1">19</outsider>
          <region class="DoCO:TextChunk" id="128" confidence="possible" page="26" column="1">2. For all consecution paths π s C with transition relation ρ φ C s satisfies ρ φ C s ⇒ C = C ∨ C = C +1 3. For all consecution paths π s C , all i ∈ { 1 ...m } , j ∈ { 1 ...k } , ρ φ C s ∧ C &gt; 0 ⇒ 0 ≤ ε ij ≤ | A i | − 1 ∧ 0 ≤ d ij ( C − 1) + ε ij ≤ | A i | − 1 4. For all consecution paths π s C either:</region>
          <disp-formula class="DoCO:FormulaBox" id="Fb">
            <label class="DoCO:Label" id="129">b</label>
            <content class="DoCO:Formula" id="130" page="26" column="1">ρ φ s C ∧ C &gt; 0 ⇒ ε ij = ε ij for all i ∈ { 1 ...m } , j ∈ { 1 ...k } ρ φ C s ⇒ C = C + 1 ∧ ε ij = ε ij − d ij for all i ∈ { 1 ...m } , j ∈ { 1 ...k }</content>
          </disp-formula>
          <region class="DoCO:TextChunk" id="131" confidence="possible" page="26" column="1">5. For all consecution paths π s C , ρ π s C ⇒ ∀ α : 0 ≤ α ≤ C − 1 : A [ d ij α + ε ij ] = A i [ d ij α + ε ij ] 6. For all consecution paths π s C • ρ π s C ∧ C = C +1 ⇒ i m =1 k j =1 α ij A i [ d ij C + ε ij ] + B + b α C ≤ 0) (case 4a) • ρ π s C ⇒ i m =1 k j =1 α ij A i [ ε ij ] + B ≤ 0) (case 4b) 7. For all consecution paths π s C • ρ π s C ∧ 0 ≤ α ≤ C − 1 ∧ x + B + b α ≤ 0 ⇒ x + B b α α ≤ 0 x is universally quantified fresh variable, when 4a applies • ρ π s C ∧ 0 ≤ α ≤ C − 1 ∧ x + B + b α ≤ 0 ⇒ x + B b α ( α + 1) ≤ 0 x is universally quantified fresh variable, when 4b applies then ∀ α : 0 ≤ α ≤ C − 1 : i m =1 j k =1 a ij A i [ d ij α + ε ij ] + B + b α α ≤ 0 is an invariant.</region>
          <region class="DoCO:TextChunk" id="134" page="26" column="1">The theorem above shows the relation between three linear polynomials C , B , ε i,j , with respect to the paths obtained in the transition systems. The formula expressed by a transition relation from an initial path must imply that polynomial C with the value of the variables obtained after the transition equals 0. The rest of the conditions talk only about consecution paths. The polynomial C can have either the same value or the value increased by one when evaluated with the new values of the variables and the old values. There are also integer variables a ij , d ij , b α that are kept under constraints following some rules. For all consecution paths if the formula expressing the transition relation is true and the polynomial C with the new value of variables (denoted by C ) is greater than 0 then the value of ε ij (with the new value of variables denoted by ε | ) is bounded by 0 to the left and by | A i | − 1 to the right, and the sum d ij ( C − 1) + ε ij is bounded by 0 and | A i | − 1. <marker type="page" number="27"/><marker type="block"/> The fifth condition in the theorem expresses the fact that if the formula expressing the transition relation is true on such a path than also the element of the array at position d ij α + ε ij has the same value at the start location and at end location. There are three more conditions in the theorem (4,6,7) which split the cases of the consecution paths in 2 categories. Each of the three conditions express constraints for the polynomials and the variables in the theorem. The final formula combines all of the above expressing an invariant. For an extended proof of this theorem please refer to [LRCR13]. The conditions of the theorem are encoded into an SMT problem, and a SMT solver gives the formula(s) representing the invariants.</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="133" page="26" column="1">20</outsider>
          <outsider class="DoCO:TextBox" type="page_nr" id="135" page="27" column="1">21</outsider>
        </section>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="136" page="28" column="1">4 Experiments</h1>
        <region class="DoCO:TextChunk" id="137" page="28" column="1">In this section we present the results obtained by running the three tools from Section 3 on a set of loops that were selected from different papers and benchmarks. The experiments reported in this thesis were obatined using machine with an AMD dual-core processor with 800 Mhz, cache of size 256MB. The limitations of this machine did not allow us to reach the full computational power of the tools we tested for some of the loops in question, giving an inconclusive answer. We treated this cases as negative results, and in the case of Lingva we used them in the next section where we try to improve them. Nevertheless these facilities were in most cases enough in order to get a result showing the capabilities of the tools. Lingva is independent on the platform on which is run, but we used Linux, and the same platform was used, as requested, for Cpp − inv . Gin − pink is bounded to Windows platform.</region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="138" page="28" column="1">4.1 Experiments with Gin-Pink and Cpp-Inv</h2>
          <region class="DoCO:TextChunk" id="140" page="28" column="1">The results for this part are presented in a <xref ref-type="table" rid="Tin" id="139" class="deo:Reference">table in</xref> the following form: on the first column of the table there are the loops of interest together with the reference to the paper where it can be found. The programs are written in the C language, and the input for the different differ according to the input language required by each of them. We chose to present them in this manner for the clean look and readability. On the second column of the table on every row there is one or more invariants that were found by the Cpp-inv tool, ran on the corresponding loop. The properties are written in the form of first order formula with mathematics and their characteristics and explanations can be found at the end of this subsection. The third column of the table corresponds to the invariants found by the tool Gin-Pink on the set of loops. These are also written in the form of first-order formulas and mathematics and occasionally there might be expressions written in the Boogie language. The results are explained later at the end of this subsection.</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="141" page="28" column="1">22</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="142" page="29" column="1">1</outsider>
          <region class="DoCO:TextChunk" id="143" confidence="possible" page="29" column="1">program Cpp-inv Gin-Pink Initialization [SS09] a =0; w h i l e ( a &lt; m) do ∀ a, 0 ≤ a ≤ i − 1 ⇒ ∀ k, k = i ⇒ aa [ a ] = 0 ; a=a +1; aa [ a ] = 0 aa [ k ] = 0 end do Insertion [LRCR13] x=aa [ i ] ; j = i − 1; w h i l e ( j &gt; = 0 and ∀ a, a ≤ 0 ≤ i − j − 2 ⇒ ∀ k, k = i − j − 2 ⇒ aa [ j ] &gt; x ) do − aa [ − a + i ] + x + 1 ≤ 0 aa [ i − k ] ≥ x + aa [ j +1] = aa [ j ] ; −− j ; end do Partition [SS09] a =0; b=0; c =0; w h i l e ( a &lt; m) do i f ( aa [ a] &gt; =0) ∀ x, 0 ≤ x ≤ c − 1 ⇒ then bb [ b]= aa [ a ] ; cc [ x ] + 1 ≤ 0 ∀ k, bb [ k ] == aa [ k ] b=b+1; ∀ x, 0 ≤ x ≤ b − 1 ⇒ e l s e c c [ c ]= aa [ a ] ; − bb [ x ] ≤ 0 c=c +1; end i f ; a=a +1; end do Maximum [FM10] i n t i =1; i n t max = aa [ 0 ] ; w h i l e ( i &lt; N) { ∀ a, 0 ≤ a ≤ i − 1 ⇒ i f (max &lt; aa [ i ] ) { is max ( m, A, 1 , n ) aa [ a ] − max ≤ 0 max = aa [ i ] ; } ++i ; }</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="144" page="29" column="1">23</outsider>
          <region class="unknown" id="145" page="30" column="1">∀ a, a i ⇒ aa ≤ aa [2 aa ≤ aa [ aa ≤ aa [2</region>
          <region class="DoCO:TextChunk" id="146" confidence="possible" page="30" column="1">= [ a ] [ a ] [ a ]</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="147" page="30" column="1">a + 1] ik + 1] k + i ]</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="148" page="30" column="1">⇒ x</outsider>
          <region class="unknown" id="149" page="30" column="1">∀ a, ≤ ≤ − − ⇒ x u − ∀ a, aa aa ≤</region>
          <region class="DoCO:TextChunk" id="150" confidence="possible" page="30" column="1">HeapProperty [LRCR13] c o n s t i n t m; // assume (m &gt; =0); ∀ a, 0 ≤ a ≤ i − 1 ⇒ i n t aa [ 2 ∗ m ] ; − aa [2 ∗ a + 1] + aa [ a ] ≤ 0; i n t i =0; ∀ a, 0 ≤ a ≤ i − 1 ⇒ w h i l e ( 2 ∗ i +2 &lt; 2 ∗ m) − aa [2 ∗ a + 2] + aa [ a ] ≤ 0; { ∀ a, 0 ≤ a ≤ i − 1 ⇒ i f ( aa [ i ] &gt; aa [ 2 ∗ i +1] o r 2 a − 2 ∗ aa [2 a + 1] + 2 ∗ aa [ a ] aa [ i ] &gt; aa [ 2 ∗ i +2]) − 2 m + 3 ≤ 0; break ; − aa [2 a + 1] + aa [ a ] ≤ 0; ++i ; − aa [2 ∗ a + 2] + aa [ a ] ≤ 0; } FirstOccurence [LRCR13] i n t aa [m ] ; i n t x = readX ( ) ; int l = 0; 0 a m u 1 i n t u = m; − aa [ m − a − 1] ≤ 0; 4 + x − aa [ m − a − 1] − // aa i s s o r t e d a s s c e n d e n t 2 m − 2 l ≤ 0; while ( l &lt; u) { 0 ≤ a ≤ l − 1 ⇒ i n t m = ( l+u ) / 2 ; [ a ] − x + 1 ≤ 0; i f ( aa [m] &lt; x ) l = m+1; [ a ] − 4 l + 2 u − x + 3 0; e l s e u = m;</region>
          <region class="unknown" id="151" page="30" column="1">}</region>
          <region class="unknown" id="152" page="30" column="1">∀ a, a = m aa [ a ] = ∀ a, a = l ⇒ aa [ a ] = ∀ a, a = m aa [ a ] = ∀ a, a = u aa [ a ] = ∀ a, a = m aa [ a ] =</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="153" page="30" column="1">x ⇒ l ⇒ x ⇒ u</outsider>
          <region class="unknown" id="154" page="30" column="1">{</region>
          <region class="unknown" id="155" page="30" column="1">∀ a, a ⇒ aa aa m aa aa i aa aa m</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="156" page="30" column="1">− a − 1] − a − 1] − a − i ]</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="157" page="30" column="1">i − c</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="158" page="30" column="1">&lt; aa [ k ]</outsider>
          <region class="DoCO:TextChunk" id="159" confidence="possible" page="30" column="1">Palindrome [LRCR13] i n t aa [m ] ; i n t i =0; while ( i &lt; m/ 2 ) { ∀ a, 0 ≤ a ≤ i − 1 ⇒ = i i f ( aa [ i ] != aa [m − i − 1]) aa [ m − a ] − aa [ a ] ≤ 0 [ a ] == [ ∀ a, 0 ≤ a ≤ i − 1 ⇒ [ a ] == [ break ; − aa [ m − a ] + aa [ a ] ≤ 0 [ a ] == [ } i ++; } PartitionInit [SS09] i n t aa [m] , bb [m] , c c [m] ; i n t i =0, c =0; while ( i &lt; m) { i f ( aa [ i ] == bb [ i ] ) ∀ l, 0 ≤ l ≤ c − 1 ⇒ { ∀ l, l = i ⇒ cc [ l ] − i + c − l ≤ 0 cc [ c ] = i ; cc [ l ] ≤ l + l − cc [ l ] ≤ 0 c++; } i ++; } } Vararg [SS09] a =0; aa [m ] ; ∀ 0 ≤ l ≤ i − 1 ⇒ w h i l e ( aa [ a ] &gt; 0 &amp;&amp; a &lt; m) { ∀ k, k = i ⇒ 0 − aa [ l ] + 1 ≤ 0 a=a +1; }</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="160" page="30" column="1">24</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="161" page="31" column="1">aa [0]</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="162" page="31" column="1">] + 1</outsider>
          <region class="unknown" id="163" page="31" column="1">Shift [HKV11] a =0; w h i l e ( a &lt; m) { aa [ a+1]=aa [ a ] ; No i n v a r i a n t s found . ∀ k, k = i ⇒ aa [ k ] == a=a +1; } Sum Of Pairs [LRCR13] i n t m; i n t ∗ aa ; i n t x=getX ( ) , l =0, u=m − 1; / / :$SORTED: aa @ASC while ( l &lt; u) { ∀ a, 0 ≤ a ≤ l − 1 ⇒ ∀ k, k = i − 2 ⇒ i f ( aa [ l ] + aa [ u ] &lt; x ) aa [ a ] + aa [ u ] − x + 1 ≤ 0 aa [ k ] + aa [ u ] &lt; x l = l +1; else i f ( aa [ l ] + aa [ u ] &gt; x ) u = u − 1; e l s e break ; } Sequential Initialization [LRCR13] i n t main ( ) { i n t m; i n t ∗ aa ; ∀ x, 0 ≤ x ≤ i − 2 ⇒ aa [ 0 ] = 7 ; aa [ x + 1] − aa [ x ] − 1 ≤ 0 ∀ k, k = i − 2 ⇒ i n t i =1; ∀ x, 0 ≤ x ≤ i − 2 ⇒ aa [ k + 1] == aa [ k while ( i &lt; m) − aa [ x + 1] + aa [ x ] + 1 ≤ 0 { aa [ i ]= aa [ i − 1]+1; ++i ; } }</region>
          <region class="DoCO:TextChunk" id="181" page="31" column="1">For the program Initialisation we see that both Cpp-inv and Gin-pink got the desired invariant. Gin-pink had as postcondition the formula ∀ k, 0 ≤ k &lt; m ⇒ aa [ k ] = 0. The semantics of both invariants obtained is straightforward, with the observation that in Gin-pinks case k = i has the meaning that for all values of k that were totally/partially processed. <marker type="block"/> The loop Insertion represents a program that takes a random element from an array and places it on the right the array of the array in such a way that all elements starting with the original position of the element and ending with one less than the new position. The invariant that we are looking for is the formula expressing that the value of the chosen element is less than than the values of the element between the original position and the new position of it. Both tools manage to infer this invariant. The form which is extracted by Cpp-Inv is as a inequality with one of the terms 0.<marker type="page" number="32"/><marker type="block"/> The postcondition we used for Gin-pink (translated in first order logic) is : ∀ k, k ! = i − j − 2 , aa [ i − k ] ≥ x + 1.<marker type="block"/> The loop P artition has as input an array aa which is partitioned in array bb for the non-negative elements and array cc for the negative elements. While Cpp-inv was able to find invariants characterizing the elements in cc as being negative and those in bb as non-negative, Gin-pink could get the invariant that every element in bb is equal to one in aa , whit the input postcondition ∀ k, k = b ⇒ 0 ≤ B [ k ].<marker type="block"/> The loop M aximum processes an array by comparing systematically the value of max with the value of every element in the array and assigning the value of the element in the current step to max if max is smaller. At the end of the loop the value of max is the largest value in the array. The invariant inferred by Cpp-inv expresses actually the property that for all elements that were processed, the difference between them and max is at most 0. This property is equivalent with the invariant of interest expressing that max is greater or equal than all elements that were processed. In the case of Gin-Pink, there was necessary a formula expressing that there is a total order on the type of the array. There is also an extra function that takes as input the limits of an array, the array and a variable m and returns true if m is greater or equal than all elements in the array or f alse otherwise.The invariant written in the table above expresses the fact that variable max is greater or equal to all elements in the array, which is the invariant we are looking for in this case.<marker type="block"/> In the case of HeapP roperty the loop checks until which position does the array has the heap property (every element has a value greater than the value of its parent) with the root in aa [0], and such that the element at position i (except the leaves) has children at positions 2 ∗ i + 1 and 2 ∗ i + 2 (taking into account that the array has 2 ∗ m elements). Cpp-Inv infer that invariant in the form that the difference between the “parent” and each of the “children” is less than 0. Also it infers a property expressing the fact that the values of the array grow faster than the value of the indexes. Gin- pink also managed to infer the property having the postcondition f orallk : int :: k ! = i == &gt; A [ k ] &lt; A [2 ∗ k + 1]. It also infers that for the value at position i all values that are past the position 2 k are greater.<marker type="block"/> The loop named F irstOccurence searches in a divide and conquer manner a value in a sorted array. Cpp-Inv finds finds two important invariants for understanding the loops: that all elements that are placed before the lower bound ( l ) are smaller than the value searched, and all elements that are laced before the location u is greater or equal with the value searched. From<marker type="page" number="33"/><marker type="block"/> this two properties on can infer that the value searched can be only between the locations l and u . Gin-pink can also infer these properties but the properties outputted by this tool are harder to understand and less explicit. The properties inferred by Gin-pink express only the fact that the value was not found yet through the elements that were already analyzed.<marker type="block"/> The P alindrome loop checks if an array is a palindrome (i.e. regardless of the way one reads it, it would be the same word). Cpp-inv is able to infer the formula expressing the property of a palindrome, by inferring two invariants in the following manner: restricting the values of a between 0 and i both the difference between aa [ m − a − 1] − aa [ a ] and aa [ a ] − aa [ m − a − 1] are less or equal to 0. Gin-pink inferred the property that all elements in the array that were already analyzed holds aa [ a ] = aa [ m − a ], where a is a location already processed.<marker type="block"/> The P artitionInit loop compares the elements of two arrays aa and bb and keeps in array cc the locations at which the element in aa equals the one in bb . Cpp-inv infers the invariant ∀ l, 0 ≤ l ≤ c − 1 ⇒ l − cc [ l ] ≤ 0 which can be interpreted in different ways, either that the size of cc is at most the size of aa , or that there can be at most elements in cc as there are in aa . The other invariants that Cpp-inv inferred is ∀ l, 0 ≤ l ≤ c − 1 ⇒ cc [ l ] − i + c − l ≤ 0, which describes the property that i grows faster than c , much faster than l with respect to cc [ l ]. The second property is also inferred by Gin-pink.<marker type="block"/> The V ararg is a loop that runs as long as the elements in the array aa are greater than 0. In the loop body there is no modification of the array, only the index is increased. Cpp-inv manages to infer that all elements processed are greater than 0. Gin-pink can also infer the invariant having the postcondition ∀ k, 0 ≤ k &lt; i ⇒ 0 &lt; A [ k ].<marker type="block"/> The loop Shif t gives to every element, starting with the second, to take the value of the previous element. At the end of the loop all elements have the value of the initial value of the first one. For this loop Cpp-Inv does not find any invariant for this piece of code. The possible reason for which this happens is because the invariant does not fall into the template required by this method in order to infer it. Gin-pink uses the postcondition weakening successfully in order to prove the invariant that expresses that at all the processed locations there are values for the elements equal to the value of the first element.<marker type="block"/> The loop Sumof P airs has as input an increasingly ordered array and makes sure that the sum between the elements at location l and u is smaller than same random value x , and either increases l or decreases u , accordingly.<marker type="page" number="34"/><marker type="block"/> Cpp-inv infers the formula expressing that the sum between all values at positions that are between 0 and l and the value in the array at position u minus the value of x plus 1 is smaller or equal to 0. The same invariant is inferred by Gin-pink (in a different form) by weakening the postcondition ∀ k = l ⇒ aa [ k ] + aa [ u ] &lt; x .<marker type="block"/> SequantialInitialisation has as input an array with the first element initialized and processed by initializing the rest of the array with values with one higher than the value of the previous element. At the end of the loop the elements of the array represent a series of consecutive numbers. Cpp-inv manages to infer the invariant expressing this property in the form of two inequalities. Gin-pink can also infer the invariant with the postcondition ∀ k, k = i − 2 ⇒ aa [ k + 1] = aa [ k ] + 1. Although the postcondition is strong the tool still has to check that the invariant holds for the loop.</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="166" page="31" column="1">25</outsider>
          <outsider class="DoCO:TextBox" type="page_nr" id="172" page="32" column="1">26</outsider>
          <outsider class="DoCO:TextBox" type="page_nr" id="179" page="33" column="1">27</outsider>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="182" page="34" column="1">4.2 Experiments with Lingva</h2>
          <region class="DoCO:TextChunk" id="183" page="34" column="1">The table below presents the results obtained by running Lingva on the same set of loops as the other two tools. On the first column are written the loops used for this experiment, on the second column there is written one invariant of interest for the corresponding loop and, on the third column there is either an invariant obtained by Lingva together with the set of axioms and theorems that were used to reach to the result, or a different invariant (than the one on the second column) that could be of interest for the user. In the third column, the name of a variable followed by 0 represents the initial value of the variable. At the end of the subsection we give explanations regarding the proof obtained and the theorems used in order to obtain the invariants.</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="184" page="34" column="1">28</outsider>
          <region class="DoCO:TextChunk" id="185" confidence="possible" page="35" column="1">program Invariant of interest Lingva R e f u t a t i o n found . a, 0 ≤ a i aa [ a ]</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="186" page="35" column="1">0 ∧</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="187" page="35" column="1">⇒</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="188" page="35" column="1">⇒</outsider>
          <region class="unknown" id="189" page="35" column="1">Initialisation a =0; w h i l e ( a &lt; m) do aa [ a ] = 0 ; a=a +1; end do</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="190" page="35" column="1">0</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="191" page="35" column="1">∨</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="192" page="35" column="1">aa 0( X 0)</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="193" page="35" column="1">2 ∨</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="194" page="35" column="1">X 1 ∨ aa 0( X 0)) ∨ aa 0( X 2))</outsider>
          <region class="unknown" id="195" page="35" column="1">∀ ≤ − 1 ⇒ = 0 Theorems : 6 1 6 9 . f alse 5 3 5 . aa ( sK 0) = 0 3 8 2 . 0 ≤ sK 0 ∧ ¬ a ≤ sK 0 ∧ aa ( sK 0) = aa ( sK 0) = aa 0( sK 0) 3 8 1 . ∃ X 0 , ((0 ≤ X 0) ∧ ¬ ( a ≤ X 0) ∧ aa ( X 0) = 0 ∧ aa ( X 0) = aa 0( X 0)) 3 8 0 . ∃ X 0 , (((0 ≤ X 0) ∧ ¬ ( a ≤ X 0)) ∧ ( aa ( X 0) ≤ 0 ∧ aa ( X 0) = aa 0( X 0))) 3 7 9 . ¬∀ X 0 , (((0 ≤ X 0) ∧ ¬ ( a ≤ X 0)) ⇒ ( aa ( X 0) = 0 ∨ aa ( X 0) = aa 0( X 0))) 1 5 3 . ¬∀ X 37 , (((0 ≤ X 37) ∧ ¬ ( a ≤ X 37)) ( aa ( X 37) = 0 ∨ aa ( X 37) = aa 0( X 37))) 1 5 2 . ¬∀ X 37 , (((0 ≤ X 37) ∧ ( X 37 &lt; a )) ( aa ( X 37) = 0 ∨ aa ( X 37) = aa 0( X 37))) ∀ a, 0 ≤ a ≤ i − 1 ⇒ 1 5 1 . ∀ X 37 , (((0 ≤ X 37) ∧ ( X 37 &lt; a )) ⇒ ( aa ( X 37) = 0 ∨ aa ( X 37) = aa 0( X 37))) aa [ a ] = 0 6 1 6 8 . aa ( sK 0) = 0 6 1 6 7 . aa ( sK 0) = aa ( sK 0) ∨ aa ( sK 0) = 1 5 6 7 . aa ( X 0) = aa 0( X 0) ∨ aa ( X 0) = 0 1 5 6 6 . aa ( X 0) = 0 ∨ aa ( X 0) = aa 0( X 0) aa ( X 0) = aa 0( X 0) 3 8 5 . ( a 0 + sK 0( X 0)) = X 0 ∨ aa ( X 0) = 1 6 9 . ∀ X 0 , ( aa ( X 0) = aa 0( X 0) ∨ ( a 0 + sK 0( X 0)) = X 0) 3 . ∀ X 2 , ( aa ( X 2) = aa 0( X 2) ∨ ( a 0 + sK 0( X 2)) = X 2) 5 3 8 . aa (( a 0 + sK 0( X 0))) = 0 ∨ aa ( X 0) = aa 0( X 0) 5 3 7 . aa ( X 0) = aa 0( X 0) ∨ aa ( X 1) = 0 ∨ ( a 0 + sK 0( X 0)) = X 1 3 8 8 . aa ( X 0) = aa 0( X 0) ∨ aa ( X 1) = X 0 = X 2 ∨ ( a 0 + sK 0( X 0)) = X 1 1 7 2 . ∀ X 0 , X 1 , X 2 , (( a 0 + sK 0( X 0)) = 0 = X 2 ∨ aa ( X 1) = X 2 ∨ aa ( X 0) = 6 . ∀ X 2 , X 0 , X 1 , (( a 0 + sK 0( X 2)) = X 0 0 = X 1 ∨ aa ( X 0) = X 1 ∨ aa ( X 2) = 5 3 6 . aa ( sK 0) = aa 0( sK 0)</region>
          <region class="DoCO:TextChunk" id="196" confidence="possible" page="35" column="1">Insertion R e f u t a t i o n not found . x=aa [ i ] ; j = i − 1; ∀ a, a ≤ 0 ∧ Other i n t e r e s t i n g w h i l e ( j &gt; = 0 and p r o p e r t i e s found : a ≤ i − j − 2 ⇒ aa [ j ] &gt; x ) do ∀ X 0 , : ( sK 0( X 0) ≤ ( j − j 0) ∨ aa [ j +1] = aa [ j ] ; x + 1 ≤ aa [ − a + i ] aa ( X 0) = aa 0( X 0))) . −− j ; ∀ X 0 , X 1 : ((1 + j 0) = X 0 | aa 0( j 0) = X 1 | aa ( X 0) = X 1 | end do (( j − j 0) ≤ 0)) .</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="197" page="35" column="1">29</outsider>
          <region class="DoCO:TextChunk" id="198" confidence="possible" page="36" column="1">R e f u t a t i o n found</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="199" page="36" column="1">6 6 0 ]</outsider>
          <region class="unknown" id="200" page="36" column="1">Partition a =0; b=0; c =0; w h i l e ( a &lt; m) do i f ( aa [ a] &gt; =0) then bb [ b]= aa [ a ] ; b=b+1; e l s e c c [ c ]= aa [ a ] ; c=c +1; end i f ; a=a +1; end do</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="201" page="36" column="1">⇒ ]</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="202" page="36" column="1">]</outsider>
          <region class="unknown" id="203" page="36" column="1">1 2 2 4 . f alse ( 1 : 0 ) [ resolution 314 ,968] 9 6 8 . ¬ ( c ≤ X 1) ( 0 : 3 ) [ cnf transformation 661] 6 6 1 . ∀ X 1 : (0 ≤ X 1) ∧ ¬ ( c ≤ X 1)) ∧ (0 ≤ bb ( sK 0)) [ s k o l e m i s a t i o n ∀ a, 0 ≤ a ≤ c − 1 ⇒ 6 6 0 . ∃ X 0 : ( ∀ X 1 : ((0 ≤ X 1) ∧ ¬ ( c ≤ X 1)) ∧ (0 ≤ bb ( X 0))) cc [ a ] &lt; 0 [ ennf transformation 659] ∀ a, 0 ≤ a ≤ b − 1 ⇒ 6 5 9 . ¬∀ X 0 : ( ∀ X 1 : ((0 ≤ X 1) ∧ bb [ a ] ≥ 0 ¬ ( c ≤ X 1)) ⇒ ¬ (0 ≤ bb ( X 0))) 3 0 8 . ¬∀ X 68 : ( ∀ X 68 : ((0 ≤ X 68) ∧ ¬ ( c ≤ X 68)) ⇒ ¬ (0 ≤ bb ( X 68))) 3 0 7 . ¬∀ X 68 : ( ∀ X 68 : ((0 ≤ X 68) ∧ ( X 68 &lt; c )) ⇒ ( bb ( X 68) &lt; 0)) [ negated c o n j e c t u r e 306] 3 0 6 . ∀ X 68 : ((0 ≤ X 68) ∧ ( X 68 &lt; c )) ( bb ( X 68) &lt; 0) [ i n p u t i m p l i c a t i o n 3 1 4 . ( X 0 ≤ X 0) ( 0 : 3 ) [ t h e o r y axiom R e f u t a t i o n not found .</region>
          <region class="DoCO:TextChunk" id="204" confidence="possible" page="36" column="1">Other i n t e r e s t i n g p r o p e r t i e s t h a t were proven : ∀ X ∃ Y, 0 ≤ X, Y &lt; i ⇒ aa [ X ] ≤ aa [ Y ] Theorems :</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="205" page="36" column="1">]</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="206" page="36" column="1">0)))</outsider>
          <region class="unknown" id="207" page="36" column="1">Maximum i n t i =1; i n t max = aa [ 0 ] ; while ( i &lt; m) { ∀ a, 0 ≤ a &lt; i ⇒ i f (max &lt; aa [ i ] ) { aa [ a ] ≤ max max = aa [ i ] ; } ++i ; }</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="208" page="36" column="1">⇒</outsider>
          <region class="unknown" id="209" page="36" column="1">9 0 4 . f alse [ r e s o l u t i o n 1 5 9 , 5 2 9 5 2 9 . ¬ ( i ≤ X 0) [ cnf transformation 375] 3 7 5 . ∀ X 0 , ((0 ≤ sK 2( X 0)) ∧ ¬ ( i ≤ sK 2( X 0)) ∧ (0 ≤ X 0) ∧ ¬ ( i ≤ X 0) ∧ ¬ ( aa ( sK 2( X 0)) ≤ aa ( X [ skolemisation 372] 3 7 2 . ∀ X 0 , ∃ X 1((0 ≤ X 1) ∧ ¬ ( i ≤ X 1) ∧ (0 ≤ X 0) ∧ ¬ ( i ≤ X 0) ∧ ¬ ( aa ( X 1) ≤ aa ( X 0))) [ f l a t t e n i n g 371] 3 7 1 . ∀ X 0 , ∃ X 1(((0 ≤ X 1) ∧ ¬ ( i ≤ X 1) ∧ (0 ≤ X 0) ∧ ¬ ( i ≤ X 0)) ∧ ¬ ( aa ( X 1) ≤ aa ( X 0))) 3 6 8 . ¬∃ X 0 , ∀ X 1((0 ≤ X 1) ∧ ¬ ( i ≤ X 1) ∧ (0 ≤ X 0) ∧ ¬ ( i ≤ X 0) ⇒ ( aa ( X 1) ≤ aa ( X 0))) 1 5 3 . ¬∃ X 37 , ∀ X 36((0 ≤ X 36) ∧ ¬ ( i ≤ X 36) ∧ (0 ≤ X 37) ∧ ¬ ( i ≤ X 37) ( aa ( X 36) ≤ aa ( X 37))) 1 5 0 . ¬∃ X 37 , ∀ X 36((0 ≤ X 36) ∧ ( X 36 &lt; i ) ∧ (0 ≤ X 37) ∧ ( X 37 &lt; i ) ⇒ ( aa ( X 36) ≤ aa ( X 37))) 1 4 9 . ∃ X 37 , ∀ X 36((0 ≤ X 36) ∧ ( X 36 &lt; i ) ∧ (0 ≤ X 37) ∧ ( X 37 &lt; i ) ⇒ ( aa ( X 36) ≤ aa ( X 37))) 1 5 9 . ( X 0 ≤ X 0) ( 0 : 3 ) [ t h e o r y axiom</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="210" page="36" column="1">]</outsider>
          <outsider class="DoCO:TextBox" type="page_nr" id="211" page="36" column="1">30</outsider>
          <region class="unknown" id="212" page="37" column="1">{</region>
          <region class="unknown" id="213" page="37" column="1">Can not be c h e c due t o t h e s t r u o f t h e program</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="214" page="37" column="1">k e d c t u r e .</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="215" page="37" column="1">k e d</outsider>
          <region class="unknown" id="216" page="37" column="1">∀</region>
          <region class="unknown" id="217" page="37" column="1">Can not be c h e c due t o the use o f d i v</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="218" page="37" column="1">i d e .</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="219" page="37" column="1">k e d . l</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="220" page="37" column="1">found . i n g</outsider>
          <region class="unknown" id="221" page="37" column="1">R e f u t a t i o n not Other i n t e r e s t p r o p e r t i e s that were proved : ∀ X 3 , X 4 , X 5 C 0 + X 3 = X 4 ∧ a 0 + X 3 = X 5 ∧ 0 ≤ X 3 ⇒ C [ X 4] = X 5 ∨ c − c 0 ≤ X 3</region>
          <region class="DoCO:TextChunk" id="222" confidence="possible" page="37" column="1">HeapProperty c o n s t i n t m; assume (m &gt; =0); ∀ 0 ≤ a ≤ i − 1 i n t aa [ 2 ∗ m ] ; aa [ a ] ≤ aa [2 a ] i n t i =0; 2 a − aa [2 a + 1] + aa [ a ] w h i l e ( 2 ∗ i +2 &lt; 2 ∗ m) − 2 m + 3 ≤ 0 − aa [ a + 2] + aa [ a ] ≤ 0 i f ( aa [ i ] &gt; aa [ 2 ∗ i +1] o r 2 a − aa [ a + 2] + aa [ a ] aa [ i ] &gt; aa [ 2 ∗ i +2]) − 2 m + 3 ≤ 0 break ; ++i ; } FirstOccurence i n t aa [m ] ; i n t x = readX ( ) ; ∀ a, 0 ≤ a ≤ m − U − 1 ⇒ int l = 0; x ≤ aa [ m − a − 1]; i n t u = m; aa [ u + x ] ≤ aa [ m − a − 1] − − 2 m + 2 l ; // aa i s s o r t e d a s s c e n d e n t a, 0 ≤ a ≤ l − 1 ⇒ while ( l &lt; u) { aa [ a ] ≤ x − 1; i n t m = ( l+u ) / 2 ; aa [ a ] ≤ 4 l − 2 u + x − 3; i f ( aa [m] &lt; x ) l = m+1; e l s e u = m; } Palindrome i n t aa [m ] ; i n t i =0; while ( i &lt; m/ 2 ) { Can not be c h e c ∀ a, 0 ≤ a ≤ i − 1 ⇒ The \ &amp; \ &amp; − l o g i c a i f ( aa [ i ] != aa [m − i − 1]) aa [ m − a ] = aa [ a ] operator i s { not s u p p o r t e d break ; } i ++; } PartitionInit i n t aa [m] , bb [m] , c c [m] ; i n t i =0, c =0; while ( i &lt; m) { i f ( aa [ i ] == bb [ i ] ) ∀ X, 0 ≤ x ≤ c − 1 ⇒ { aa [ cc [ x ]] = bb [ cc [ X ]] cc [ c ] = i ; c++; } i ++; } }</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="223" page="37" column="1">31</outsider>
          <region class="DoCO:TextChunk" id="224" confidence="possible" page="38" column="1">R e f u t a t i o n found . ∀ x, 0 ≤ x ≤ a − 1 ⇒ aa [ x ] &gt; 0</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="225" page="38" column="1">] ∧</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="226" page="38" column="1">∧</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="227" page="38" column="1">3 5 0 ]</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="228" page="38" column="1">1 5 8 ]</outsider>
          <region class="unknown" id="229" page="38" column="1">Theorems : 1 5 3 0 . f alse ( 2 : 0 ) [ subsumption r e s o l u t i o n 1 5 2 9 , 5 7 4 ] 5 7 4 . ¬ ( a ≤ ( a 0 + sK 0)) [ forward demodulation 491 ,142 ] 1 4 2 . ( X 0 + X 1) = ( X 1 + X 0) [ t h e o r y axiom ] 4 9 1 . ¬ ( a ≤ ( sK 0 + a 0)) [ cnf transformation 350] 3 5 0 . (0 ≤ sK 0) ∧ ¬ (0 ≤ aa (( a 0 + sK 0))) ∧ ¬ ( a ≤ ( sK 0 + a 0)) [ s k o l e m i s a t i o n 3 4 9 3 4 9 . ∃ X 0 , ((0 ≤ X 0) ∧ ¬ (0 ≤ aa (( a 0 + X 0))) ¬ ( a ≤ ( X 0 + a 0))) [ f l a t t e n i n g 3 4 8 ] 3 4 8 . ∃ X 0 , (((0 ≤ X 0) ∧ ¬ (0 ≤ aa (( a 0 + X 0)))) ¬ ( a ≤ ( X 0 + a 0))) [ ennf transformation 141] 1 4 1 . ¬∀ X 0 , (((0 ≤ X 0) ∧ ¬ (0 ≤ aa (( a 0 + X 0)))) ⇒ ( a ≤ ( X 0 + a 0))) Vararg [ evaluation 140] a =0; 1 4 0 . ¬∀ X 0 , (((0 ≤ X 0) ∧ ∀ x, 0 ≤ x ≤ a − 1 ⇒ ( aa (( a 0 + X 0)) &lt; 0)) ⇒ ( a ≤ ( X 0 + a 0))) w h i l e ( aa [ a ] &gt; 0) { aa [ x ] &gt; 0 [ negated c o n j e c t u r e 139] a=a +1; 1 3 9 . ∀ X 0 , (((0 ≤ X 0) ∧ } ( aa (( a 0 + X 0)) &lt; 0)) ⇒ ( a ≤ ( X 0 + a 0))) [ input implication ] 1 5 2 9 . ( a ≤ ( a 0 + sK 0)) [ forward demodulation 1528 ,142] 1 5 2 8 . ( a ≤ ( sK 0 + a 0)) [ subsumption r e s o l u t i o n 1 5 1 8 , 4 8 9 ] 4 8 9 . (0 ≤ sK 0) [ c n f t r a n s f o r m a t i o n 1 5 1 8 . ¬ (0 ≤ sK 0) ∨ ( a ≤ ( sK 0 + a 0)) [ resolution 355 ,586] 5 8 6 . ( aa (( a 0 + sK 0)) ≤ 0) [ resolution 149 ,490] 4 9 0 . ¬ (0 ≤ aa (( a 0 + sK 0))) [ cnf transformation 350] 1 4 9 . ( X 0 ≤ X 1) ∨ ( X 1 ≤ X 0) [ t h e o r y axiom ] 3 5 5 . ¬ ( aa (( a 0 + X 0)) ≤ 0) ∨ ¬ (0 ≤ X 0) ∨ ( a ≤ ( X 0 + a 0)) [ c n f t r a n s f o r m a t i o n 1 5 8 . ∀ X 0 , (( a ≤ ( X 0 + a 0)) ∨ ¬ (0 ≤ X 0) ∨ ¬ ( aa (( a 0 + X 0)) ≤ 0)) [ flattening 5] 5 . ∀ X 0 , (( a ≤ ( X 0 + a 0)) ∨ ¬ (0 ≤ X 0) ∨ ¬ ( aa (( a 0 + X 0)) ≤ 0)) [ input inv4 ]</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="230" page="38" column="1">32</outsider>
          <region class="DoCO:TextChunk" id="231" confidence="possible" page="39" column="1">R e f u t a t i o n found . ∀ X, 0 ≤ X ∧ X &lt; a ⇒</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="232" page="39" column="1">] i o n 3 7 9 ]</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="233" page="39" column="1">]</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="234" page="39" column="1">n g 3 7 7 ]</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="235" page="39" column="1">o n 3 7 6 ]</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="236" page="39" column="1">⇒ ] ⇒ u r e 1 5 0 ]</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="237" page="39" column="1">t i o n ]</outsider>
          <region class="unknown" id="238" page="39" column="1">Shift a =0; w h i l e ( a &lt; m) { aa [ a+1]=aa [ a ] ; a=a +1; }</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="239" page="39" column="1">axiom ] ] 3 7 9 ]</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="240" page="39" column="1">1 5 3 , 1 5 5 ]</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="241" page="39" column="1">, 4 9 1 ]</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="242" page="39" column="1">X 0)) X 0)) X 1))</outsider>
          <region class="unknown" id="243" page="39" column="1">aa [ X ] = aa [ X + 1] Theorems used : 1 2 4 7 . f alse ( 1 : 0 ) [ r e s o l u t i o n 1 0 9 6 , 5 3 0 5 3 0 . ¬ ( a ≤ sK 0) ( 0 : 3 ) [ c n f t r a n s f o r m a t 3 7 9 . ∀ [ X 1] : (0 ≤ X 1) ∧ ¬ ( a ≤ sK 0) ∧ aa ( sk 0) = aa ( sk 0 + 1) [ s k o l e m i s a t i o n 3 7 8 3 7 8 . ∃ [ X 0] : ( ∀ [ X 1] : (0 ≤ X 1) ∧ ¬ ( a ≤ X 0) ∧ aa ( X 0) = aa ( X 0 + 1)) [ f l a t t e n i 3 7 7 . ∃ [ X 0] : (( ∀ [ X 1] : (0 ≤ X 1) ∧ ¬ ( a ≤ X 0)) ∧ aa ( X 0) = aa ( X 0 + 1)) [ e n n f t r a n s f o r m a t i 3 7 6 . ¬∀ [ X 0] : (( ∀ [ X 1] : (0 ≤ X 1) ∧ ¬ ( a ≤ X 0)) ⇒ aa ( X 0) = aa ( X 0 + 1)) [ r e c t i f y 1 5 2 ] 1 5 2 . ¬∀ [ X 36] : (( ∀ [ X 36] : (0 ≤ X 36) ∧ ¬ ( a ≤ X 36)) aa ( X 36) = aa ( X 36 + 1)) [ e v a l u a t i o n 1 5 1 1 5 1 . ¬∀ [ X 36] : (( ∀ [ X 36] : (0 ≤ X 36) ∧ ( X 3 &lt; a )) aa ( X 36) = aa ( X 36 + 1)) [ n e g a t e d c o n j e c t 1 5 0 . ( ∀ [ X 36] : (0 ≤ X 36) ∧ ( X 36 &lt; a )) ⇒ aa ( X 36) = aa ( X 36 + 1) [ i n p u t i m p l i c a 1 0 9 6 . ( a ≤ X 0) ( 0 : 3 ) [ subsumption r e s o l u t i o n 9 2 5 , 8 7 8 ] 8 7 8 . ( X 3 ≤ ( X 3 + X 2)) ( 3 : 5 ) [ superposition 853 ,153] ∀ x, 0 ≤ x &lt; a ⇒ 1 5 3 . ( X 0 + X 1) = ( X 1 + X 0) ( 0 : 7 ) [ t h e o r y 8 5 3 . ( X 11 ≤ ( X 12 + X 11)) ( 2 : 5 ) aa [ x ] = aa [0] [ subsumption r e s o l u t i o n 8 4 3 , 5 2 9 5 2 9 . (0 ≤ X 1) ( 0 : 3 ) [ c n f t r a n s f o r m a t i o n 8 4 3 . ( X 11 ≤ ( X 12 + X 11)) ∨ ¬ (0 ≤ X 12) (2:8) [ superposition 161 ,669] 6 6 9 . (0 + X 0) = X 0 ( 1 : 5 ) [ s u p e r p o s i t i o n 1 5 5 . ( X 0 + 0) = X 0 ( 0 : 5 ) [ t h e o r y axiom ] 1 6 1 . (( X 0 + X 2) ≤ ( X 1 + X 2)) ∨ ¬ ( X 0 ≤ X 1) ( 0 : 1 0 ) [ t h e o r y axiom ] 9 2 5 . ¬ ( a 0 ≤ ( a 0 + (0 + X 0))) ∨ ( a ≤ X 0) ( 0 : 1 0 ) [ backward d e m o d u l a t i o n 8 9 7 4 9 1 . ( a ≤ X 0) ∨ ¬ ( a 0 ≤ ( a 0 + ( − a + X 0))) (0:11) [ cnf transformation 337] 3 3 7 . ∀ [ X 0] : ( ¬ ( a 0 ≤ ( a 0 + ( − ( a ) + X 0))) ∨ ( a ≤ [ f l a t t e n i n g 336] 3 3 6 . ∀ [ X 0] : ( ¬ ( a 0 ≤ ( a 0 + ( − ( a ) + X 0))) ∨ ( a ≤ [ r e c t i f y 112] 1 1 2 . ∀ [ X 1] : ( ¬ ( a 0 ≤ ( a 0 + ( − ( a ) + X 1))) ∨ ( a ≤ [ input inv111 ] 8 9 7 . 0 = − ( X 0) ( 4 : 4 ) [ subsumption r e s o l u t i o n 8 9 5 , 5 2 9 ] 8 9 5 . ¬ (0 ≤ − ( X 0)) ∨ 0 = − ( X 0) (4:8) [ resolution 877 ,164] 1 6 4 . ¬ ( X 1 ≤ X 0) ∨ ¬ ( X 0 ≤ X 1) ∨ X 0 = X 1 ( 0 : 9 ) [ t h e o r y axiom ] 8 7 7 . ( − ( X 1) ≤ 0) ( 3 : 4 ) [ s u p e r p o s i t i o n 8 1 5 7 . ( X 0 + ( − X 0)) = 0 ( 0 : 6 ) [ t h e o r y axiom</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="244" page="39" column="1">5 3 , 1 5 7 ] ]</outsider>
          <outsider class="DoCO:TextBox" type="page_nr" id="245" page="39" column="1">33</outsider>
          <region class="unknown" id="246" page="40" column="1">Sum Of P a i r s i n t m; i n t ∗ aa ; i n t x=getX ( ) , l =0 , u=m − 1;</region>
          <outsider class="DoCO:TextBox" type="sidenote" id="247" page="40" column="1">found .</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="248" page="40" column="1">s t i n g t was</outsider>
          <outsider class="DoCO:TextBox" type="sidenote" id="249" page="40" column="1">⇒ X 0) ⇒ X 1) X 2) ⇒</outsider>
          <region class="unknown" id="250" page="40" column="1">/ / :$SORTED: A @ASC ∀ x, 0 ≤ x ≤ m − u − 2 ⇒ while ( l &lt; u) { R e f u t a t i o n not x + 1 ≤ A [ m − x − 1] + A [ l ] i f ( aa [ l ] + aa [ u ] &lt; x ) l = l +1; else i f ( aa [ l ] + aa [ u ] &gt; x ) u = u − 1; e l s e break ; } Sequential I n i t i a l i s a t i o n i n t main ( ) timelimit reached { a t 200 i n t m; Other i n t e r e i n t ∗ aa ; p r o p e r t y t h a proven : aa [ 0 ] = 7 ; ∀ x, 0 ≤ x ≤ i ⇒ i − i 0 &lt; sk 0( X 0) aa ( X 0) = aa 0( i n t i =1; aa [ x + 1] = aa [ x ] + 1 m ≤ i 0 + sk 0( X 1) while ( i &lt; m) aa ( X 1) = aa 0( { sk 0( X 2) ≤ 0 ⇒ aa [ i ]= aa [ i − 1]+1; aa ( X 2) = aa 0( ++i ; m ≤ i + i 0 ∧ 0 ≤ i } 0 ≤ i 0</region>
          <region class="DoCO:TextChunk" id="251" confidence="possible" page="40" column="1">} For the loop Initialisation first vampire proves that aa ( sk 0) = 0(6168) and afterwards that aa ( sk 0)! = 0(535). We explain the proof in three steps:</region>
          <region class="DoCO:TextChunk" id="252" page="40" column="1">1. the formula representing the invariant of interest being negated and after a series of transformations, evaluation, rectify, flattening and skolemisation, the negated formula is put in a standard form $ lesseq (0 , sK 0)&amp; $ lesseq ( a, sK 0)&amp; aa ( sK 0)! = 0&amp; aa ( sK 0)! = aa 0( sK 0) (382). From this formula it is easy to see that formula 6168 can be deduced</region>
          <region class="DoCO:TextChunk" id="253" confidence="possible" page="40" column="1">2. For the second formula (535) the proof starts with on of the formulas that lingva inferred ![ X 2 , X 0 , X 1] : ($ sum ( a 0 , sK 0( X 2))! = X 0 | 0! = X 1 | aa ( X 0) = X 1 | aa ( X 2) = aa 0( X 2))(6). After cnf transformation and equality resolution the following formula is obtained aa ($ sum ( a 0 , sK 0( X 0))) = 0 | aa ( X 0) = aa 0( X 0)(538). 3. Using another formula (after processing it) that is automatically deduced by Lingva , $ sum ( a 0 , sK 0( X 0)) = X 0 | aa ( X 0) = aa 0( X 0), V ampire uses superposition that has as result aa ( X 0) = aa 0( X 0) | aa ( X 0) = 0(1567), after eliminating the duplicate literals. From</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="254" page="40" column="1">34</outsider>
          <region class="DoCO:TextChunk" id="255" confidence="possible" page="41" column="1">the formula (382) also used in the first step V ampire infers also aa ( sK 0)! = aa 0( sK 0)(536). Using superposition on (536) and (1567) and after eliminating trivial inequalities aa ( sk 0) = 0 results. For the loop P artition two invariants were proved by V ampire , one formulating that for every non-negative element in aa there is an element in bb , and one formulating that for every negative element in aa there is an element in cc . We are going to explain only the former proof because of the similari- ties between the two. From the input implication after processing it vampire infers the clause $ lesseq (0 , X 1)(982). Vampire use the property obtained by Lingva that expresses the fact that the iterator c grows as most as fast as iterator a , ![ X 66 , X 67] : ($ lesseq ( X 66 , $ sum ( c, X 67)) | $ lesseq ( X 66 , c 0) | $ lesseq (0 , $ sum ( a, $ sum ($ uminus ( a 0) , X 67))))(1429). Using resolution on (1429) and (982) the formula $ lesseq ( X 0 , $ sum ( c, X 1)) | $ lesseq ( X 0 , c ) (1447) is inferred. Using the following three theory axioms $ sum ( X 0 , X 1) = $ sum ( X 1 , X 0), $ lesseq ($ sum ( X 0 , 1) , X 1) | $ lesseq ( X 1 , X 0), $ lesseq ( X 0 , X 0) and the previous inferred formula and the theory of superposition the following formula is inferred $ lesseq ($ sum (1 , $ sum (0 , X 4)) , 0) (1714). From the formula tagged with (1714) and the theory axiom $ sum (0 , X 0) = X 0 the following formula is inferred $ lesseq ($ sum (1 , X 4) , 0). The contradiction is inferred from the las formula and the axiom that every number summed with its opposite will result to zero. This proof makes use of a large number of theory axioms together with input axioms discovered by Lingva and because of this fact its complexity is higher than that of other discussed proofs. The invariant that expresses the property for array cc has a similar proof with corresponding differences where these apply.</region>
          <region class="DoCO:TextChunk" id="266" page="41" column="1">For the loop Insertion we try to prove the inductive formula representing the invariant. Since V ampire has not yet a mechanism that deals with induction this invariant is harder to prove. On the other hand Lingva automatically infers two properties that are necessary in understanding the program. The first one expresses the fact that from a certain position the elements of the array do not modify their value. The second property automatically inferred shows that the invariant holds for the first value of j . In the next chapter we show that by adding the right axioms to the ones already outputted by Lingva the theorem prover can find a proof for the searched invariant. <marker type="block"/> For the loop M aximum , although the invariant we were looking for could not be proven V ampire proved that for every iteration of the loop there exists an element that was already processed and that is greater or equal to all other processed elements. V ampire proves this by simply getting a contradiction with the axiom X ≤ X . In the next chapter we show what<marker type="page" number="42"/><marker type="block"/> properties can be added in order to prove the invariant of interest. For the moment Lingva has some limitation that do not permit the analysis of loops that have more than one condition. Also the analysis of statements that use division is impossible. Even if the statements are modified in such a way that multiplication is used instead of division the analysis of the statements is still troublesome.For the three loops HeapP roperty , F irstOccurence , P alindrome , the properties automatically inferred do not offer information about array elements, but rather information about the iterators that could not be used in order to prove any invariants of interest. Because of the current limitations in the analysis system of Lingva we consider that these three loops could not be representative for the capabilities of proving invariants.<marker type="block"/> For the loop P artitionInit the invariant that we are interested in is also an inductive invariant. As we specified before, this type of invariant is, for V ampire , harder to prove. Lingva managed to automatically infer a different invariant expressing the property that every elements in the array cc is a valid position in the array aa . There are no properties inferred regarding the array bb , so in order to infer the invariant of interest there are other properties that have to be added to the list of formulas outputted by Lingva .<marker type="block"/> For the loop vararg the invariant is proved by V ampire only based on the input obtained from Lingva . With a few transformation from the (fourth) input invariant the following formula can be obtained: $ lesseq ( aa ($ sum ( a 0 , X 0)) , 0) | $ lesseq (0 , X 0) | $ lesseq ( a, $ sum ( X 0 , a 0)) (355). This property can be rewritten into an implication expressing that if X 0 is positive and the element at position a 0 + X 0 is also positive then the position a 0 + X 0 is smaller than a . After transforming the formula representing the invariant V ampire inferred three new clauses ¬ $ lesseq (0 , aa ($ sum ( a 0 , sK 0))) (490), $ lesseq (0 , sK 0) (350) and $ lesseq ( a, $ sum ( sK 0 , a 0)) (491). The formula (490) can be transformed in the formula $ lesseq ( aa ($ sum ( a 0 , X 0)) , 0) (586) using resolution and a theory axiom. Using resolution a few times on this formula V ampire infers the following formula $ lesseq ( a, $ sum ( a 0 , sK 0)) (1529). Using forward demodulation on (491) an the theory axiom $ sum ( X 0 , X 1) = $ sum ( X 1 , X 0) and get the formula ¬ $ lesseq ( a, $ sum ( a 0 , sK 0)) which is the opposite of formula (1529).<marker type="block"/> For the loop Shif t the proof of refutation for the invariant of interest was found. We give a sketch of the proof for easier understanding of it. From the negated conjuncture the clause ¬ ( a ≤ sk 0) (530) can be inferred. This<marker type="page" number="43"/><marker type="block"/> clause is in contradiction with clause a ≤ X 0 (1096) which is inferred as follows. From the negated conjunction together with theory axioms one can infer X 11 ≤ X 12 + X 11 ∨ ¬ (0 ≤ X 12) (853). From theory axioms and negate input invariant one can also infer 0 = − X 0 (897). From the previous clause and the input invariant ∀ [ X 1] : ( ¬ ( a 0 ≤ ( a 0 + ( − ( a ) + X 1))) ∨ ( a ≤ X 1) the clause ¬ ( a 0 ≤ ( a 0+(0+ X 0))) ∨ ( a ≤ X 0)(925) can be inferred. From the latter formula and formula labeled with (853) one can infer the clause labeled (1096) making the refutation proof complete.<marker type="block"/> For the loop Sumof P airs the invariant that we are trying to prove is based on a property that is not explicitly expressed in the program. The fact that the input array is ordered has a great impact in the proving power of the theorem prover. In the next chapter we show how the addition of this property makes possible the proof of the invariant of interest.<marker type="block"/> For the loop SequentialInitialisation the invariant of interest expresses the property that the elements of the array have consecutive values. Although for this specific loop Lingva discovered many invariants that could be used in order to get a proof of the invariant of interest, the limitations of the machine did not make this possible, the computations being too slow. Nevertheless we introduce new theorems to the already formed set in order to get faster results. This situation is also discussed in the next chapter. From the direct output of Lingva we can distinguish a few properties that give understanding with respect to the loop. More precisely it shows that if a position was not visited yet, the value of the element did not change.</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="258" page="41" column="1">35</outsider>
          <outsider class="DoCO:TextBox" type="page_nr" id="263" page="42" column="1">36</outsider>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="267" page="43" column="1">4.3 Discussions of Experimental Results</h2>
          <region class="DoCO:TextChunk" id="274" page="43" column="1">From the experiments above we can draw a few conclusions about the invariants that these tools can infer. Cpp − inv has very good results with most of the experiments. The running time necessary to infer the invariants is appreciable even when run on a machine with not too many resources. A lot of invariants studied fell into the template that this tool is using, being able to automatically find them without any guidance from the user. It can also analyze more complex loops that have in the body if . . . then . . . else statements and loops with more than one condition which gives better flexibility and expressibility when writing the code to be analyzed. One important class of invariants that this tool is able to infer is the induction type. This type of properties usually indicate a relation between an element of the array and the element or elements prior to it. In the benchmark used we found a single loop that could not be analyzed properly by this tool, Shif t . The invariant we were looking for was a relation between an element at a certain position i and the element at position <marker type="page" number="44"/><marker type="block"/> i + 1. Since this property needed reasoning about a position that was not reached yet, this did not meet the requirements for the template used by Cpp − inv . For the invariant P artitionInit the invariant that were discovered did not give insight on the relation between the elements of the three arrays processed in the loop. All other invariants that were concluded for the respective loops were the invariant of interest. The tool was able to extract useful information about the usage of the array in the loop and yield formulas of great usage in order for the user to understand the task done in the snippet of code. What seems to be the drawback of this method is the fact that one can not independently use it to check a certain property of interest if it is not already inferred by the tool. One can not add new information that can not be automatically inferred in order to get a result about the property of interest. On the other hand if a user decides to check for properties a piece of code seen for the first time, this tool might give useful information regarding the elements of the processed array. In the case of Gin − pink there is a large set of invariants that can be inferred from the postcondition and proved by Boogie . The advantage of using postconditions is that the invariants that will be derived from them are usually useful for understanding the program. Since the program has as starting point for searching an invariant a property that is of interest for the user it is natural that the invariant found by weakening the formula would also be of interesting when the code is analyzed by the user. On the other hand it might the case that the invariant would contain auxiliary variables that are not part of the postcondition. In this case the invariant of interest is not going to be derived by the tool. Although Gin − pink is not able to infer (without any interference from the user) an invariant containing auxiliary variables with respect to the postcondition there are walk-arounds this problems. One variant to work this problem out is to augment postconditions with one clause that specifies properties of the auxiliary variable. At this point Gin − pink might have a chance to derive the wanted invariant by weakening the new postcondition. One of this loops is the one tagged with M aximum which was modified in order to see if the tool would successfully infer the invariant we were looking for. Another type of invariants that cause problems to this tool is the one that include product operation. In this case the problem comes from the theorem prover that is embedded in the tool, namely Z 3. This theorem prover does not have the background theory necessary to handle formulas that have product of numeric in their composition. Unfortunately for this case there is no workaround to make the tool infer the invariant since there is no way to include new theories that could be used for processing such formulas. From the experiments seen above we can see that there are a lot of<marker type="page" number="45"/><marker type="block"/> useful invariants derived by this tool, and making use of the method that helps derive invariants with auxiliary variables would give the user better results. For the tool Lingva we observe from the experiments that it obtains a lot of properties from analyzing the code. To get an idea of how precise the code is analyzed, the number of invariants that are outputted after eliminating the trivial ones is somewhere around 150, for a piece of code with 10 lines. Also the invariants that are inferred can also express properties between different variables and also between initial values and new values of the variables, feature that was not present for the other two tools. The drawback of this method is that some loops that contain more that have more than one condition to be checked can not be analyzed because the tool has not yet implemented the analysis of &amp;&amp; and || operators from C programming language. This problem can be solved if the loop does not contain any if . . . then . . . else statements, because at the moment the loop can be successfully analyzed if it is not nested and does not contain nested if statements. An operation from which is hard to infer invariants is the product over integer. This method is able to infer such invariants from the direct analysis of the loop. In order to see the efficiency of this feature of the tool we modified some of the above loops and processed them with Lingva . Although the invariants obtained were expressing properties that need the multiplication operation we could not get any interesting invariants (since also the loops were not have a real purpose in processing an array). In the set of loops that we studied there was a significant number that had as invariants of interest invariants that needed induction in order to be proven. Unfortunately the theory of induction is not yet implemented in V ampire so even though the invariants inferred by Lingva were enough to prove them this did not happen. In the next section we show how we can nevertheless infer this invariants if we study the properties deduced by Lingva and add the missing properties in order for the induction to be complete. This method has the advantage that if the user knows some information about the analyzed loop, or any theory that might not be implemented in V ampire yet it can easily encode the formulas representing the rules in V ampire and run the theorem prover in order to see if a proof of refutation for the invariant of interest is possible, with the new information. We took advantage of this fact and use it to prove all the invariants that were not automatically proved. In the next chapter we show in detail how the proof of refutation were obtained for each invariant. The three methods have different strong points, Cpp − inv can infer induction properties without any supplementary information from the user, while for Lingva this is not a trivial task, although it is achievable. Gin − pink can also deduce such invariants as long as the postcondition mentions<marker type="page" number="46"/><marker type="block"/> the variable used as an index, otherwise the task is impossible because it does not have a method to add information about other variables. Lingva is the only one from the three tools that can infer properties about the initial values and the modified values of the variables, by introducing a new variable name for the initial value of the variable. This feature offers the user a more expressive way to reason about the program. It brings more information to the output as it can infer that starting with one position of the array the elements don’t further change, information that can not be rendered by the other two tools. Lingva is more flexible in the sens that knowing that some information can not be inferred from the loop ( such as if the array is sorted) the use can add this information to the output of lingva in order to obtain a possibly better result from V ampire . Gin − pink also accepts in the input new information from the user, in the form of assume statements, but in this case the type of formula that one can provide is not as expressible as first order logic. Gin − pink has a great advantage by being a goal oriented method. The invariants inferred by this tool are certainly of interest for the user, since they have as starting point the postcondition that is interesting for the program. From this point of view Lingva tries to infer as many invariants as possible, to make sure it covers as many properties that might be of interest as possible, while Cpp − inv looks for properties that fall in a certain pattern, between specific point of the program analyzed.</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="269" page="43" column="1">37</outsider>
          <outsider class="DoCO:TextBox" type="page_nr" id="271" page="44" column="1">38</outsider>
          <outsider class="DoCO:TextBox" type="page_nr" id="273" page="45" column="1">39</outsider>
          <outsider class="DoCO:TextBox" type="page_nr" id="275" page="46" column="1">40</outsider>
        </section>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="276" page="47" column="1">5 Invariant Specific Theory Extensions to First Order Theorem Prover</h1>
        <region class="DoCO:TextChunk" id="277" page="47" column="1">In this chapter we proceed to analyze the programs for which the properties of interest could not be proven by Lingva/Vampire and try to find additional properties of the variables in these programs that we could add such that the computing power of the prover is increased.</region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="278" page="47" column="1">5.1 Comparison of invariants strength</h2>
          <region class="DoCO:TextChunk" id="281" page="47" column="1">The Maximum Example. The first program to be analyzed is the one with the name “Maximum”. In plain English what this program does is to put the value of the first element of an array aa into the variable max and iterate through the rest of the array comparing max with the rest of elements and changing the current value of max with the greater value of the elements if it is the case. The followings are the lines in the loop: <marker type="block"/> Analyzing the output of Lingva we observe that the properties with respect to the iterator i are not strong enough so we add one to assure that the initial value of i is 0:</region>
          <region class="unknown" id="280" page="47" column="1">int i=1; int max = aa[0]; while (i&lt;m) { if (max&lt;aa[i]) { max = aa[i]; } ++i; }</region>
          <region class="DoCO:TextChunk" id="282" confidence="possible" page="47" column="1">Property. 1 tff(prop1,axiom, i0=0). and one to make ensure that i is increasing: Property. 2 tff(prop2,axiom, $ less(i0,i) ).</region>
          <region class="DoCO:TextChunk" id="283" page="47" column="1">These two axioms are necessary to ensure that the first part of the implication will not be invalidated by a false positive. We also add two properties regarding the variable max . The first one ensures that the initial value for max is equal with the value of the first element in aa :</region>
          <region class="DoCO:TextChunk" id="284" confidence="possible" page="47" column="1">Property. 3 tff(prop3, axiom, max0=aa(0) ). While the second one ensures that max takes its values only from the values of elements in aa :</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="285" page="47" column="1">41</outsider>
          <region class="unknown" id="286" page="48" column="1">Property. 4 tff(prop4, axiom, ?[Z: $ int]: $ lesseq(0,Z) &amp; $ lesseq(Z,n) &amp; max=aa(Z)).</region>
          <region class="DoCO:TextChunk" id="287" page="48" column="1">Since the properties inferred by Lingva did not show any relation between the variable max and the elements in the array it is hard to infer such a property. The two axioms above have the role to make this connection in order for the reasoning to be possible. With the above properties added to the output of Lingva the theorem prover can prove that all elements in the array that were already examined have the value at most the value of max expressed in the following formula:</region>
          <region class="DoCO:TextChunk" id="288" confidence="possible" page="48" column="1">Property. 5 tff(implication, conjecture, ![X: $ int]: ( $ lesseq(0,X) &amp; $ less(X,i) = &gt; $ lesseq(aa(X),max) )). The proof of refutation outputted by Vampire is given in the following lines: Refutation found. Thanks to Tanya! 981. $false (0:0) [subsumption resolution 980,906] 906. sP5 (1:1) [resolution 903,530] 530. $lesseq(X0,i) (0:3) [cnf transformation 374] 374. ! [X0] : ($lesseq(0,i) &amp; $lesseq(0,sK2(X0)) &amp; $lesseq(sK2(X0),i)&amp; $lesseq(0,X0) &amp; $lesseq(X0,i) &amp; ~$lesseq(aa(sK2(X0)),aa(X0))) [skolemisation 371] 150. ? [X37] : ! [X36] : (($lesseq(0,i) &amp; $lesseq(0,X36) &amp; $lesseq(X36,i) &amp; $lesseq(0,X37) &amp; $lesseq(X37,i)) =&gt; $lesseq(aa(X36),aa(X37))) [input implication] 903. ~$lesseq(1,i) | sP5 (0:4) [splitting component introduction] 980. ~sP5 (0:1) [subsumption resolution 953,529] 529. $lesseq(0,X0) (0:3) [cnf transformation 374] 953. ~$lesseq(0,$uminus(i)) | ~sP5 (0:5) [backward demodulation 923,904] 904. ~$lesseq(0,$sum(0,$uminus(i))) | ~sP5 (0:7) [splitting 669,903] 669. ~$lesseq(1,i) | ~$lesseq(0,$sum(0,$uminus(i))) (0:9) [definition unfolding 512,517,517] 517. i0 = 0 (0:3) [cnf transformation 143] 143. i0 = 0 [input prop1] 512. ~$lesseq(1,i) | ~$lesseq(i0,$sum(i0,$uminus(i))) (0:9) [cnf transformation 357] 357. ~$lesseq(i0,$sum(i0,$uminus(i))) | ~$lesseq(1,i) [flattening 138] 138. ~$lesseq(i0,$sum(i0,$uminus(i))) | ~$lesseq(1,i) [input inv137] 923. $sum(0,X0) = X0 (1:5) [superposition 153,155]</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="289" page="48" column="1">42</outsider>
          <region class="unknown" id="290" page="49" column="1">155. $sum(X0,0) = X0 (0:5) [theory axiom] 153. $sum(X0,X1) = $sum(X1,X0) (0:7) [theory axiom]</region>
          <region class="DoCO:TextChunk" id="299" page="49" column="1">From inv137 inferred by Lingva and the property 1 V ampire deduces that either i is less or equal to 1 or − 1 is smaller than 0. At proposition 903 a new splitting component in a disjunction with i smaller than 1. From this formula and the negation of the invariant V ampire infers sP 5. From the negated conjunction also the fact that X 0 is greater than 0 is inferred and use this to deduce sP 5. The refutation can now be completed. Although Vampire could not automatically find a refutation proof for the formula representing the property of max , the extra-formulae that were added by hand was just information about the variables and not new theories. <marker type="block"/> The Partial Initialization Example. The second loop we are going to look at is “ Partial Initialization ”. This program has as input two arrays, aa and bb , and saves the indexes for which the element in aa equals the one in bb in the array cc .<marker type="block"/> We add properties that give information about the initial values of the iterators a and c :<marker type="block"/> The properties inferred by Lingva with respect to these iterators are too weak and it can not be inferred that all their values start with the same value, and that the value at which they start is non-negative. We also limit the the execution of the programs to the situation when the number of elements in the array aa , m , is greater than 0:<marker type="page" number="50"/><marker type="block"/> This property is necessary because from the static analysis of the program it can not be inferred that the array has a positive number of elements, but we know that any other case would not make sense. We also add a property that expresses the upper and lower limit of that an element in cc can get, and also a property that establish a relation between the elements in the array cc and the value of c for the corresponding element:</region>
          <region class="unknown" id="293" page="49" column="1">int aa[m], bb[m], cc[m]; int i=0, c=0; while (i&lt;m) { if (aa[i] == bb[i]) { cc[c] = i; c++; } i++; } }</region>
          <region class="unknown" id="295" page="49" column="1">Property. 6 tff(prop2, axiom, a0=0). Property. 7 tff(prop4, axiom, c0=0).</region>
          <region class="unknown" id="297" page="49" column="1">Property. 8 tff(prop5, axiom, $ lesseq(0, m))</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="298" page="49" column="1">43</outsider>
          <region class="DoCO:TextChunk" id="300" confidence="possible" page="50" column="1">Property. 9 tff(prop1, axiom, ![Y: $ int]: $ lesseq(0,cc(Y))&amp; $ less(cc(Y),m)). Property. 10 tff(prop6, axiom, ![Y0: $ int]:( $ lesseq(0,Y0)&amp; $ less(Y0,c) = &gt; $ lesseq(Y0,cc(Y0)))).</region>
          <region class="DoCO:TextChunk" id="301" page="50" column="1">With this new axioms added although Vampire can not prove the initial property: ∀ X, 0 ≤ X ∧ X &lt; c ⇒ aa [ cc [ X ]] == bb [ cc [ X ]], it can prove another formula with one quantifier alternation: ∀ X, ∃ Y, 0 ≤ X ∧ X &lt; m ∧ 0 ≤ Y ∧ Y &lt; c ∧ aa ( X ) = bb ( X ) ⇒ cc ( Y ) = X . Here is the proof of refutation that was outputted by Vampire :</region>
          <region class="unknown" id="302" page="50" column="1">Refutation found. Thanks to Tanya! 2064. $false (1:0) [subsumption resolution 2061,2048] 2048. ~$lesseq(c,0) (1:3) [resolution 2019,1058] 1058. $lesseq(X1,c) (0:3) [cnf transformation 746] 746. ! [X1] : ($lesseq(0,X1) &amp; $lesseq(X1,c) &amp; bb(sK0) = aa(sK0)&amp; cc(X1) != sK0 &amp; cc(X1) != cc0(X1)) [skolemisation 745] 310. ! [X48] : ? [X49] : (($lesseq(0,X49) &amp; $lesseq(X49,c) &amp; bb(X48) = aa(X48)) =&gt; (cc(X49) = X48 | cc(X49) = cc0(X49))) [input implication] 2019. ~$lesseq(1,c) | ~$lesseq(c,0) (0:6) [forward demodulation 2018,316] 316. $sum(X0,0) = X0 (0:5) [theory axiom] 2018. ~$lesseq(c,0) | ~$lesseq(1,$sum(c,0)) (0:8) [forward demodulation 1374,1613] 1613. c = a (0:3) [forward demodulation 1612,316] 1612. a = $sum(c,0) (0:5) [subsumption resolution 1611,1580] 1580. $lesseq(c,a) (0:3) [evaluation 1065] 1065. ~$lesseq(0,0) | $lesseq(c,a) (0:6) [definition unfolding 751,1053,1054] 1054. a0 = 0 (0:3) [cnf transformation 307] 307. a0 = 0 [input prop4] 1053. c0 = 0 (0:3) [cnf transformation 306] 306. c0 = 0 [input prop2] 751. ~$lesseq(c0,a0) | $lesseq(c,a) (0:6) [cnf transformation 330] 330. $lesseq(c,a) | ~$lesseq(c0,a0) [flattening 5] 5. $lesseq(c,a) | ~$lesseq(c0,a0) [input inv4]</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="303" page="50" column="1">44</outsider>
          <region class="DoCO:TextChunk" id="304" confidence="possible" page="51" column="1">1611. ~$lesseq(c,a) | a = $sum(c,0) (0:8) [forward demodulation 1545,316] 1545. ~$lesseq($sum(c,0),a) | a = $sum(c,0) (0:10) [evaluation 1115] 1115. ~$lesseq(0,0) | ~$lesseq($sum(c,$uminus(0)),a) | a = $sum(c,$uminus(0))(0:15) [definition unfolding 801,1054,1053,1053] 801. ~$lesseq(a0,0) | ~$lesseq($sum(c,$uminus(c0)),a) | a = $sum(c,$uminus(c0)) (0:15) [cnf transformation 381] 381. a = $sum(c,$uminus(c0)) | ~$lesseq($sum(c,$uminus(c0)),a) | ~$lesseq(a0,0) [flattening 55] 55. a = $sum(c,$uminus(c0)) | ~$lesseq($sum(c,$uminus(c0)),a) | ~$lesseq(a0,0) [input inv54] 1374. ~$lesseq(a,0) | ~$lesseq(1,$sum(c,0)) (0:8) [evaluation 1350] 1350. ~$lesseq(a,0) | ~$lesseq(1,$sum(c,$uminus(0))) (0:9) [definition unfolding 1036,1054,1053] 1036. ~$lesseq(a,a0) | ~$lesseq(1,$sum(c,$uminus(c0))) (0:9) [cnf transformation 720] 720. ~$lesseq(1,$sum(c,$uminus(c0))) | ~$lesseq(a,a0) [flattening 290] 290. ~$lesseq(1,$sum(c,$uminus(c0))) | ~$lesseq(a,a0) [input inv289] 2061. $lesseq(c,0) (1:3) [resolution 1852,1057] 1057. $lesseq(0,X1) (0:3) [cnf transformation 746] 1852. ~$lesseq(0,$uminus(c)) | $lesseq(c,0) (0:7) [forward demodulation 1256,1732] 1732. $sum(0,X0) = X0 (0:5) [backward demodulation 1731,1648] 1648. $sum(0,X0) = $sum(c,$sum(0,$sum($uminus(c),X0))) (0:12) [forward demodulation 1129,1613] 1129. $sum(0,X0) = $sum(a,$sum(0,$sum($uminus(c),X0))) (0:12) [definition unfolding 815,1054,1053] 815. $sum(a0,X0) = $sum(a,$sum(c0,$sum($uminus(c),X0))) (0:12) [cnf transformation 396] 396. ! [X0] : $sum(a0,X0) = $sum(a,$sum(c0,$sum($uminus(c),X0))) [rectify 69] 69. ! [X1] : $sum(a0,X1) = $sum(a,$sum(c0,$sum($uminus(c),X1))) [input inv68] 1731. $sum(c,$sum(0,$sum($uminus(c),X0))) = X0 (0:10) [forward demodulation 1730,316] 1730. $sum(X0,0) = $sum(c,$sum(0,$sum($uminus(c),X0))) (0:12) [forward demodulation 1195,1613] 1195. $sum(X0,0) = $sum(a,$sum(0,$sum($uminus(c),X0))) (0:12) [definition unfolding 881,1054,1053] 881. $sum(X0,a0) = $sum(a,$sum(c0,$sum($uminus(c),X0))) (0:12</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="305" page="51" column="1">45</outsider>
          <region class="unknown" id="306" page="52" column="1">) [cnf transformation 501] 501. ! [X0] : $sum(X0,a0) = $sum(a,$sum(c0,$sum($uminus(c),X0))) [rectify 135] 135. ! [X28] : $sum(X28,a0) = $sum(a,$sum(c0,$sum($uminus(c),X28))) [input inv134] 1256. $lesseq(c,0) | ~$lesseq(0,$sum(0,$uminus(c))) (0:9) [definition unfolding 942,1053,1053] 942. $lesseq(c,0) | ~$lesseq(c0,$sum(c0,$uminus(c))) (0:9) [cnf transformation 604] 604. ~$lesseq(c0,$sum(c0,$uminus(c))) | $lesseq(c,0) [flattening 196] 196. ~$lesseq(c0,$sum(c0,$uminus(c))) | $lesseq(c,0) [input inv195]</region>
          <region class="DoCO:TextChunk" id="307" page="52" column="1">Starting from inv54 inferred by Lingva stating that either a is equal to c − c 0 or c is not less or equal to a or the initial value of a is greater than 0 and with the two properties enforcing the initial values of the iterators V ampire infers formula (1611) stating that either c is grater than a or a equals c . Due to the fact that a is at least equal to c , property enforced by formula (1580). From the input inv289 expressing the fact that either c is greater than c 0 or a is greater than a 0 and the property stating the equality between a and c , V ampire infers that either c is equal to 0 or is greater or equal to 1(2019). From this formula and the negation of the invariant we are trying to prove 0 ≤ c (2048) is inferred. From input invariants inv195 and inv68 V ampire infers that c is less or equal to 0. Applying resolution on the two formulas we obtain a refutation.</region>
          <region class="DoCO:TextChunk" id="308" confidence="possible" page="52" column="1">The Sum of Pairs Example. The next loop we analyze is “Sum of pairs”. int m; int *aa; int x=getX(), l=0, u=m-1; //:$SORTED: A @ASC while (l &lt; u) { if (aa[l] + aa[u] &lt; x) l = l+1; else if (aa[l] + aa[u] &gt; x) u = u-1;</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="309" page="52" column="1">46</outsider>
          <region class="unknown" id="310" page="53" column="1">else break; % }</region>
          <region class="DoCO:TextChunk" id="311" page="53" column="1">This loop is particularly difficult to analyze with this method because it is constructed with a nested if . . . then . . . else statement, which makes it difficult for Lingva to extract properties - as specified in the previous chapter, and the invariant we want to infer is inductive, type of property that can not be inferred straight forward by V ampire . For this specific loop we introduce the invariants inferred by Cpp − inv and check if the theorem prover can deduce the invariant:</region>
          <region class="DoCO:TextChunk" id="312" confidence="possible" page="53" column="1">Property. 11 aa [ l ] + aa [ u ] − x + 1 ≤ 0 The proof obtained by V ampire is shown as follows: Refutation found. Thanks to Tanya! 1898. $false (2:0) [subsumption resolution 1897,355] 355. $lesseq(0,l) (2:3) [resolution 208,103] 103. $lesseq(0,sK0) (0:3) [cnf transformation 80] 80. $lesseq(0,sK0) &amp; $lesseq(sK0,l) &amp; ~$lesseq($sum(aa(l),$sum(aa(u),$sum($uminus(x),1))),0) [skolemisation 79] 79. ? [X0] : ($lesseq(0,X0) &amp; $lesseq(X0,l) &amp; ~$lesseq($sum(aa(l),$sum(aa(u),$sum($uminus(x),1))),0)) [flattening 78] 78. ? [X0] : (($lesseq(0,X0) &amp; $lesseq(X0,l)) &amp; ~$lesseq($sum(aa(l),$sum(aa(u),$sum($uminus(x),1))),0)) [ennf transformation 59] 59. ~! [X0] : (($lesseq(0,X0) &amp; $lesseq(X0,l)) =&gt; $lesseq($sum(aa(l),$sum(aa(u),$sum($uminus(x),1))),0)) [rectify 24] 24. ~! [X3] : (($lesseq(0,X3) &amp; $lesseq(X3,l)) =&gt; $lesseq($sum(aa(l),$sum(aa(u),$sum($uminus(x),1))),0)) [negated conjecture 23] 23. ! [X3] : (($lesseq(0,X3) &amp; $lesseq(X3,l)) =&gt; $lesseq($sum(aa(l),$sum(aa(u),$sum($uminus(x),1))),0)) [input implication] 208. ~$lesseq(X16,sK0) | $lesseq(X16,l) (1:6) [resolution 31,104] 104. $lesseq(sK0,l) (0:3) [cnf transformation 80] 31. ~$lesseq(X1,X2) | ~$lesseq(X0,X1) | $lesseq(X0,X2) (0:9) [theory axiom] 1897. ~$lesseq(0,l) (2:3) [subsumption resolution 1889,30] 30. $lesseq(X0,X0) (0:3) [theory axiom] 1889. ~$lesseq(l,l) | ~$lesseq(0,l) (2:6) [resolution 390,309] 309. ~$lesseq($sum(1,$sum($uminus(x),$sum(aa(u),aa(l)))),0) (0:12)</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="313" page="53" column="1">47</outsider>
          <region class="DoCO:TextChunk" id="314" confidence="possible" page="54" column="1">[forward demodulation 308,25] 25. $sum(X0,X1) = $sum(X1,X0) (0:7) [theory axiom] 308. ~$lesseq($sum(1,$sum($uminus(x),$sum(aa(l),aa(u)))),0) (0:12) [forward demodulation 307,25] 307. ~$lesseq($sum(1,$sum($sum(aa(l),aa(u)),$uminus(x))),0) (0:12) [forward demodulation 306,279] 279. $sum(X7,$sum(X8,X9)) = $sum(X9,$sum(X7,X8)) (1:11) [superposition 26,25] 26. $sum(X0,$sum(X1,X2)) = $sum($sum(X0,X1),X2) (0:11) [theory axiom] 306. ~$lesseq($sum($uminus(x),$sum(1,$sum(aa(l),aa(u)))),0) (0:12) [forward demodulation 305,279] 305. ~$lesseq($sum($uminus(x),$sum(aa(l),$sum(aa(u),1))),0) (0:12) [forward demodulation 304,25] 304. ~$lesseq($sum($uminus(x),$sum($sum(aa(u),1),aa(l))),0) (0:12) [forward demodulation 296,279] 296. ~$lesseq($sum(aa(l),$sum($uminus(x),$sum(aa(u),1))),0) (0:12) [backward demodulation 279,143] 143. ~$lesseq($sum(aa(l),$sum(aa(u),$sum(1,$uminus(x)))),0) (0:12) [forward demodulation 105,25] 105. ~$lesseq($sum(aa(l),$sum(aa(u),$sum($uminus(x),1))),0) (0:12) [cnf transformation 80] 390. $lesseq($sum(1,$sum($uminus(x),$sum(aa(u),aa(X0)))),0) | ~$lesseq(X0,l) | ~$lesseq(0,X0) (1:18) [superposition 314,25] 314. $lesseq($sum(1,$sum($uminus(x),$sum(aa(X0),aa(u)))),0) | ~$lesseq(X0,l) | ~$lesseq(0,X0) (0:18) [forward demodulation 313,25] 313. $lesseq($sum(1,$sum($sum(aa(X0),aa(u)),$uminus(x))),0) | ~$lesseq(X0,l) | ~$lesseq(0,X0) (0:18) [forward demodulation 312,279] 312. $lesseq($sum($uminus(x),$sum(1,$sum(aa(X0),aa(u)))),0) | ~$lesseq(X0,l) | ~$lesseq(0,X0) (0:18) [forward demodulation 311,279] 311. $lesseq($sum($uminus(x),$sum(aa(u),$sum(1,aa(X0)))),0) | ~$lesseq(X0,l) | ~$lesseq(0,X0) (0:18) [forward demodulation 310,26] 310. $lesseq($sum($uminus(x),$sum($sum(aa(u),1),aa(X0))),0) | ~$lesseq(X0,l) | ~$lesseq(0,X0) (0:18) [forward demodulation 297,279] 297. $lesseq($sum(aa(X0),$sum($uminus(x),$sum(aa(u),1))),0) | ~$lesseq(X0,l) | ~$lesseq(0,X0) (0:18) [backward demodulation 279,140] 140. $lesseq($sum(aa(X0),$sum(aa(u),$sum(1,$uminus(x)))),0) | ~$lesseq(X0,l) | ~$lesseq(0,X0) (0:18) [forward demodulation 100,25] 100. $lesseq($sum(aa(X0),$sum(aa(u),$sum($uminus(x),1))),0) | ~$lesseq(X0,l) | ~$lesseq(0,X0) (0:18) [cnf transformation 73] 73. ! [X0] : (~$lesseq(0,X0) | ~$lesseq(X0,l) | $lesseq($sum(aa(X0),$sum(aa(u),$sum($uminus(x),1))),0)) [flattening 72] 72. ! [X0] : ((~$lesseq(0,X0) | ~$lesseq(X0,l)) |</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="315" page="54" column="1">48</outsider>
          <region class="unknown" id="316" page="55" column="1">$lesseq($sum(aa(X0),$sum(aa(u),$sum($uminus(x),1))),0)) [ennf transformation 56] 56. ! [X0] : (($lesseq(0,X0) &amp; $lesseq(X0,l)) =&gt; $lesseq($sum(aa(X0),$sum(aa(u),$sum($uminus(x),1))),0)) [rectify 20] 20. ! [X3] : (($lesseq(0,X3) &amp; $lesseq(X3,l)) =&gt; $lesseq($sum(aa(X3),$sum(aa(u),$sum($uminus(x),1))),0)) [input pro3]</region>
          <region class="DoCO:TextChunk" id="320" page="55" column="1">From the input property that represents one of the invariants discovered by Cpp − inv , ∀ X 3((0 ≤ X 3 ∧ X 3 ≤ l ⇒ aa ( X 3) + aa ( u ) + 1 − x ≤ 0)) using forward demodulation in combination with theory axioms V ampire infers that $ lesseq (0 , l ). But in the negated conjecture we have the negation of this clause resulting into a refutation. This result is not surprising, taking into account that Cpp − inv can infer most of the invariants that are inductive so the formulas added to Lingva s result cover the V ampire s lack using induction. The great number of theories that are implemented in the theorem prover makes the inference of the invariant possible, the formula introduced as an axiom being processed and modeled by this theorems to take the form we were looking for. <marker type="block"/> The Sequential Initialization Example. Also in the case of the loop for the program “Sequential initialization ” proving the property of interest is not straight forward.<marker type="block"/> Since in the program there are specified initial values for the iterator i and for the first element in the array aa but Lingva did not infer them automatically we introduce them by hand in the form of two properties:</region>
          <region class="unknown" id="319" page="55" column="1">int main() { int m; int *aa; aa[0]=7; int i=1; while (i&lt;m) { aa[i]=aa[i-1]+1; ++i; } }</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="321" page="55" column="1">49</outsider>
          <region class="DoCO:TextChunk" id="322" confidence="possible" page="56" column="1">Property. 12 tff(prop1, axiom, i0=1 ). and Property. 13 tff(prop3, axiom, aa0(0)=7).</region>
          <region class="DoCO:TextChunk" id="323" page="56" column="1">We observe that Lingva managed to infer some very useful invariants stating that the value of an element in aa that is in a position beyond the boundaries (less than 0, or greater than i , greater than m ) the value of the element does not change. We introduce a property expressing the fact that if the element lies between the boundaries of the processed array its value is changed:</region>
          <region class="DoCO:TextChunk" id="324" confidence="possible" page="56" column="1">Property. 14 tff(propx, axiom, ![X: $ int]: ( ( $ lesseq( $ sum(i, $ uminus(i0)),sK0(X)) &amp; $ sum(i0,sK0(X)) = X &amp; $ lesseq(0,sK0(X)) &amp; $ lesseq(m, $ sum(i0,sK0(X)))) = &gt; ¬ aa(X)=aa0(X) )).</region>
          <region class="DoCO:TextChunk" id="325" page="56" column="1">Since there is no property inferred about the way a value is changed by this loop (although we already have this information from the output of Cpp-inv) we introduce a new formula stating this relation:</region>
          <region class="DoCO:TextChunk" id="326" confidence="possible" page="56" column="1">Property. 15 tff(prop10, axiom, ![X: $ int]: (aa(X)=aa0(X) | aa(X)= $ sum(aa( $ sum(X, $ uminus(1))),1) )). With these new formulae added Vampire can prove that: ∀ X, (0 ≤ X ) ∧ ( X &lt; i ) ⇒ aa ( X ) == aa ( X − 1) + 1. The proof outputted is give as follows: Refutation found. Thanks to Tanya! 5511. $false (0:0) [subsumption resolution 5508,702] 702. sP2(sK0) (0:2) [inequality splitting 697,701] 701. ~sP2($sum(1,sK0(sK0))) (0:5) [inequality splitting name introduction] 697. $sum(1,sK0(sK0)) != sK0 (0:6) [definition unfolding 544,539] 539. i0 = 1 (0:3) [cnf transformation 151] 151. i0 = 1 [input prop1] 544. $sum(i0,sK0(sK0)) != sK0 (0:6) [cnf transformation 388] 388. $lesseq($sum(i,$uminus(i0)),sK0(sK0)) &amp; $sum(i0,sK0(sK0))!= sK0 &amp; ~$lesseq(0,sK0(sK0)) &amp; $lesseq(m,$sum(i0,sK0(sK0))) &amp; aa(sK0) != $sum(aa($sum(sK0,$uminus(1))),1) [skolemisation 387] 155. ! [X37] : (($lesseq($sum(i,$uminus(i0)),sK0(X37)) &amp; ~$sum(i0,sK0(X37)) = X37 &amp; ~$lesseq(0,sK0(X37)) &amp; $lesseq(m,$sum(i0,sK0(X37)))) =&gt; aa(X37) = $sum(aa($sum(X37,$uminus(1))),1)) [input implication] 5508. ~sP2(sK0) (0:2) [backward demodulation 5504,701] 5504. $sum(1,sK0(sK0)) = sK0 (1:6)</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="327" page="56" column="1">50</outsider>
          <region class="unknown" id="328" page="57" column="1">[subsumption resolution 5503,545] 545. ~$lesseq(0,sK0(sK0)) (0:4) [cnf transformation 388] 5503. $lesseq(0,sK0(sK0)) | $sum(1,sK0(sK0)) = sK0 (1:10) [subsumption resolution 5497,696] 696. $lesseq(m,$sum(1,sK0(sK0))) (0:6) [definition unfolding 546,539] 546. $lesseq(m,$sum(i0,sK0(sK0))) (0:6) [cnf transformation 388] 5497. ~$lesseq(m,$sum(1,sK0(sK0))) | $lesseq(0,sK0(sK0)) | $sum(1,sK0(sK0)) = sK0 (1:16) [resolution 909,912] 912. $lesseq($sum(-1,i),sK0(sK0)) (0:6) [forward demodulation 703,157] 157. $sum(X0,X1) = $sum(X1,X0) (0:7) [theory axiom] 703. $lesseq($sum(i,-1),sK0(sK0)) (0:6) [evaluation 698] 698. $lesseq($sum(i,$uminus(1)),sK0(sK0)) (0:7) [definition unfolding 543,539] 543. $lesseq($sum(i,$uminus(i0)),sK0(sK0)) (0:7) [cnf transformation 388] 909. ~$lesseq($sum(-1,i),sK0(X0)) | ~$lesseq(m,$sum(1,sK0(X0))) | $lesseq(0,sK0(X0)) | $sum(1,sK0(X0)) = X0 (0:22) [forward demodulation 908,157] 908. ~$lesseq(m,$sum(1,sK0(X0))) | $lesseq(0,sK0(X0)) | $sum(1,sK0(X0)) = X0 | ~$lesseq($sum(i,-1),sK0(X0)) (0:22) [subsumption resolution 705,548] 548. ~$lesseq(m,$sum(1,sK0(X0))) | aa(X0) = aa0(X0) (0:11) [definition unfolding 389,539] 389. ~$lesseq(m,$sum(i0,sK0(X0))) | aa(X0) = aa0(X0) (0:11) [cnf transformation 170] 170. ! [X0] : (aa(X0) = aa0(X0) | ~$lesseq(m,$sum(i0,sK0(X0)))) [flattening 1] 1. ! [X0] : (aa(X0) = aa0(X0) | ~$lesseq(m,$sum(i0,sK0(X0)))) [input inv0] 705. aa(X0) != aa0(X0) | ~$lesseq(m,$sum(1,sK0(X0))) | $lesseq(0,sK0(X0)) | $sum(1,sK0(X0)) = X0 | ~$lesseq($sum(i,-1),sK0(X0)) (0:27) [evaluation 695] 154. ! [X37] : (($lesseq($sum(i,$uminus(i0)),sK0(X37)) &amp; ~$sum(i0,sK0(X37)) = X37 &amp; ~$lesseq(0,sK0(X37)) &amp; $lesseq(m,$sum(i0,sK0(X37)))) =&gt; ~aa(X37) = aa0(X37)) [input propx]</region>
          <region class="DoCO:TextChunk" id="329" page="57" column="1">V ampire infers from the input negated implication, from the invariant inv 0 deduced by Lingva , stating the connection between the relation between the values of i and m and not modifying the values in array aa ,</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="330" page="57" column="1">51</outsider>
          <region class="DoCO:TextChunk" id="331" confidence="possible" page="58" column="1">property (5504) $ sum (1 , sK 0( sK 0)) = sK 0. From this formula and ¬ sP 2($ sum (1 , sK 0( sK 0))) (701), which is an inequality splitting name introduction, formula sP 2( sK 0)(5508) is inferred. From this formula and the negated invariant V ampire obtains a refutation.</region>
          <region class="DoCO:TextChunk" id="334" page="58" column="1">The Insertion Example. The loop Insertion requires an invariant that is inductive so V ampire can not prove this invariant without some extra knowledge added to the invariants inferred by Lingva . <marker type="block"/> We observe a few properties that were already discovered by Lingva : there are four properties that express the fact that if the position in the array is out of the bounds (smaller than 0, greater than j ) the value of the elements is not modified. There is also a property communicating the fact that if j is greater than 0, than for the element at the initial value of j (at j 0) the property that the value is shifted one to the right holds. Based on this formulas we take the decision of introducing the following property stating that all elements that are at a position higher than j are greater than the element at this position.</region>
          <region class="unknown" id="333" page="58" column="1">x=aa[i]; j = i-1; while (j &gt;= 0 and aa[j] &gt; x) do aa[j+1] = aa[j]; --j; end do</region>
          <region class="DoCO:TextChunk" id="335" confidence="possible" page="58" column="1">Property. 16 tff(prop4, axiom, ![X: $ int]:( $ lesseq(j,X) | $ lesseq(X,j0) | $ less(aa(j),aa(X)))). The proof found by V ampire for the invariant is reproduced in the following lines: Refutation found. Thanks to Tanya! 1299. $false (1:0) [subsumption resolution 1298,160] 160. $lesseq(X0,X0) (0:3) [theory axiom] 1298. ~$lesseq(j,j) (1:3) [subsumption resolution 1295,856] 856. ~$lesseq(X0,j) | $lesseq(X0,j0) (3:6) [resolution 839,161] 161. ~$lesseq(X1,X2) | ~$lesseq(X0,X1) | $lesseq(X0,X2) (0:9) [theory axiom] 839. $lesseq(j,j0) (2:3) [resolution 809,639] 639. $lesseq(j,sK0) (1:3) [resolution 162,530] 530. ~$lesseq(sK0,j) (0:3) [cnf transformation 379] 379. ~$lesseq(sK0,j) &amp; $lesseq(sK0,j0) &amp; $lesseq(aa(sK0),x) [skolemisation 378]</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="336" page="58" column="1">52</outsider>
          <region class="unknown" id="337" page="59" column="1">378. ? [X0] : (~$lesseq(X0,j) &amp; $lesseq(X0,j0) &amp; $lesseq(aa(X0),x)) [ennf transformation 377] 377. ~! [X0] : ($lesseq(X0,j) | ~$lesseq(X0,j0) | ~$lesseq(aa(X0),x)) [flattening 376] 376. ~! [X0] : (~~$lesseq(X0,j) | ~$lesseq(X0,j0) | ~$lesseq(aa(X0),x))[rectify 154] 154. ~! [X36] : (~~$lesseq(X36,j) | ~$lesseq(X36,j0) | ~$lesseq(aa(X36),x)) [evaluation 152] 152. ~! [X36] : (~$less(j,X36) | ~$lesseq(X36,j0) | ~$lesseq(aa(X36),x))[negated conjecture 151] 151. ! [X36] : (~$less(j,X36) | ~$lesseq(X36,j0) | ~$lesseq(aa(X36),x))[input implication] 162. $lesseq(X0,X1) | $lesseq(X1,X0) (0:6) [theory axiom] 809. ~$lesseq(X24,sK0) | $lesseq(X24,j0) (1:6) [resolution 161,531] 531. $lesseq(sK0,j0) (0:3) [cnf transformation 379] 1295. ~$lesseq(j,j0) | ~$lesseq(j,j) (1:6) [resolution 529,160] 529. ~$lesseq(aa(X0),aa(j)) | ~$lesseq(X0,j0) | ~$lesseq(j,X0) (0:11)[cnf transformation 375] 375. ! [X0] : (~$lesseq(j,X0) | ~$lesseq(X0,j0) | ~$lesseq(aa(X0),aa(j)))[flattening 374] 374. ! [X0] : (~$lesseq(j,X0) | ~$lesseq(X0,j0) | ~$lesseq(aa(X0),aa(j)))[rectify 153] 153. ! [X36] : (~$lesseq(j,X36) | ~$lesseq(X36,j0) | ~$lesseq(aa(X36),aa(j)))[evaluation 150] 150. ! [X36] : (~$lesseq(j,X36) | ~$lesseq(X36,j0) | $less(aa(j),aa(X36)))[input prop4]</region>
          <region class="DoCO:TextChunk" id="338" page="59" column="1">The proof for this invariant is less complex than the other proofs. From the formula 839 stating that j ≤ j 0 V ampire infers that X is either grater than j or smaller than j 0(856). From this and negated invariant j &gt; j is inferred which is in contradiction with the property introduced above.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="339" page="59" column="1">5.2 Discussions and Conclusions</h2>
          <region class="DoCO:TextChunk" id="342" page="59" column="1">We seen that every one of the studied tools has its own advantage regarding the strength or type of inferred invariant. We observe that we get signifi- cantly better results when we use the invariant inferred by one tool as input for the others in order to get even stronger invariants. One remark is in order at this step and that is that the form of the formula that we try to infer with V ampire is important with respect to the set of formulas that are provided as input. Although using human intuition the invariant may be <marker type="page" number="60"/><marker type="block"/> found just as hard to infer regardless of the form that it has, for the theorem prover a decision must be made on how many times should the basic theorems (such as commutativity, associativity) be applied on a formula and in which order. An important step in this field is the automatization of the inference process and the combination of techniques.</region>
          <outsider class="DoCO:TextBox" type="page_nr" id="341" page="59" column="1">53</outsider>
          <outsider class="DoCO:TextBox" type="page_nr" id="343" page="60" column="1">54</outsider>
        </section>
      </section>
      <section class="deo:Conclusion">
        <h1 class="DoCO:SectionTitle" id="344" page="61" column="1">6 Conclusions</h1>
        <region class="DoCO:TextChunk" id="347" page="61" column="1">We have provide an extensive evaluation of the state of the art in invariant generation techniques. Although the techniques are not mutually exclusive, in the sens that the same invariant can be generated by more than one technique, we found a pattern of invariants that can or can’t be generated by a certain method. In order to infer certain properties about programs, this classification can point to the user the method that is most likely to infer it. The set of programs for which we studied the behavior of these tools were chosen from a series of loops on which either one of the tools had difficulties analyzing, the loops were representative for the type of invariants that a certain tool could infer or the invariants of interest for the loop had an interesting structure. Although this set is not large, the invariants that were inferred cover a series of patterns that occur often in program verification. We further studied the disadvantages of Lingva and V ampire and improve their functionality by either combining the result of Lingva with results of other methods or by adding properties that are easy to observe by the user. We choose the set of properties to add for each loop depending on its structure and also on the known functionality of the tool. To this end we managed to infer invariants of interest for every loop studied only with the cost of writing theorems hard to infer by this tool. Invariants of interest for the user are hard to fined since there might be a large number of properties between two or more variables from the program. Nevertheless the three tools managed to infer invariants that would help the user understand the program better. Also the saturation theorem prover and post-condition weakening methods are goal oriented since both require input from the user, having an advantage of inferring the invariant the user is interested in. Due to program verification undecidability the task of inferring invariants is hard. Selecting a suitable benchmark for an evaluation of techniques developed for this task is not trivial since the programs come in a large variety of languages and combination of statements. We seen in our evaluation that combining such techniques have a positive influence on the result. This observation take as to the conjecture that a promising path for future work is to combine methods that have different advantages and evaluate them on loops that have a more complicated behavior. We also observed that there is significant amount of cases in which human interfering with the procedure (such as adding theorems or stating postconditions) provides a better result from the users point of view. This information provides the intuition that combining human intuition can play an important part in solving the invariant generation task. Algorithms used <marker type="page" number="62"/><marker type="block"/> in machine learning, that simulate human rationality can be an asset for this section of program verification. To the best of our knowledge this concept was not used yet so for future work this is an interesting path that could be followed.</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="346" page="61" column="1">55</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="348" page="62" column="1">56</outsider>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="349" page="63" column="1">7 References</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="350" page="63" column="1">[AAR09] Cimatti A., Griggio A., and Sebastiani R. Efficient Generation of Craig Interpolants in Satisfiability Modulo Theories. In ACM Transactions on Computational Logic , volume 12, October 2009.</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="351" page="63" column="1">[And02] Peter B. Andrews. An Introduction to Mathematical Logic and Type Theory: To Truth Through Proof . 2002.</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="352" page="63" column="1">[BCC + 03] Armin Biere, Alessandro Cimatti, Edmund M. Clarke, Ofer Strichman, and Yunshan Zhu. Bounded Model Checking . 58, 2003.</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="353" page="63" column="1">[BCD + 05] Michael Barnett, Bor-Yuh Evan Chang, Robert DeLine, Bart Jacobs, and K. Rustan M. Leino. Boogie: A Modular Reusable Verifier for Object-Oriented Programs . FMCO , 4111:364–387, 2005.</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="354" page="63" column="1">[BMSW10] Sascha Böhme, Michal Moskal, Wolfram Schulte, and Burkhart Wolff. HOL-Boogie—An Interactive Prover-Backend for the Ver- ifying C Compiler. 44:111–144, February 2010.</ref>
          <ref rid="R6" class="deo:BibliographicReference" id="355" page="63" column="1">[CC77] Patrick Cousot and Radhia Cousot. Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Con- struction or Approximation of Fixpoints . pages 238–252, 1977.</ref>
          <ref rid="R7" class="deo:BibliographicReference" id="356" page="63" column="1">[Coo71] Stephen A. Cook. The complexity of theorem-proving procedures. pages 151–158, 1971.</ref>
          <ref rid="R8" class="deo:BibliographicReference" id="357" page="63" column="1">[DdM06] Bruno Dutertre and Leonardo de Moura. A Fast Linear- Arithmetic Solver for DPLL(T) . pages 81–94, 2006.</ref>
          <ref rid="R9" class="deo:BibliographicReference" id="358" page="63" column="1">[Dij75] E.W. Dijkstra. Guarded Commands, Nondeterminacy and For- mal Derivation of Programs. 18:453–457, 1975.</ref>
          <ref rid="R10" class="deo:BibliographicReference" id="359" page="63" column="1">[DL62] Martin Davis, George Logemann , and Donald Loveland. A machine program for theorem-proving. 5:394–397, July 1962.</ref>
          <ref rid="R11" class="deo:BibliographicReference" id="360" page="63" column="1">[dMB11] Leonardo de Moura and Nikolaj Bjørner. Satisfiability modulo theories: introduction and applications. 54:69–77, 2011.</ref>
          <ref rid="R12" class="deo:BibliographicReference" id="361" page="63" column="1">[DP60] Martin Davis and Hilary Putnam. A Computing Procedure for Quantification Theory. 7:201–215, July 1960.</ref>
          <ref rid="R13" class="deo:BibliographicReference" id="362" page="63" column="1">[DW50] Hilbert D. and Ackermann W. Principles of Mathematical Logic . Chelsea Publishing Company, 1950.</ref>
          <ref rid="R14" class="deo:BibliographicReference" id="364" page="64" column="1">[ES04] Niklas Eén and Niklas Sörensson. An Extensible SAT-solver. 2919:502–518, 2004.</ref>
          <ref rid="R15" class="deo:BibliographicReference" id="365" page="64" column="1">[FM10] Carlo A. Furia and Bertrand Meyer. Inferring Loop Invariants using Postconditions . In Fields of Logic and Computation: Es- says Dedicated to Yuri Gurevich on the Occasion of His 70th Birthday . 2010.</ref>
          <ref rid="R16" class="deo:BibliographicReference" id="366" page="64" column="1">[G.S83] G.S.Tseitin. On the Complexity of Derivation in Propositional Calculus. pages 466–483, 1983.</ref>
          <ref rid="R17" class="deo:BibliographicReference" id="367" page="64" column="1">[HHKR10] Thomas A. Henzinger, Thibaud Hottelier, Laura Kovács, and Andrey Rybalchenko. Aligators for Arrays (Tool Paper) . 6397: 348–356, 2010.</ref>
          <ref rid="R18" class="deo:BibliographicReference" id="368" page="64" column="1">[HKV11] Krystof Hoder, Laura Kovacs, and Andrei Voronkov. Case Stud- ies on Invariant Generation Using a Saturation Theorem Prover. In 10th Mexican International Conference on Artificial Intelligence, MICAI , 2011.</ref>
          <ref rid="R19" class="deo:BibliographicReference" id="369" page="64" column="1">[KV09] Laura Kovacs and Andrei Voronkov. Finding Loop Invariants for Programs over Arrays Using a Theorem Prover. In International Symposium on Symbolic and Numeric Algorithms for Scientific Computing, SYNASC , 2009.</ref>
          <ref rid="R20" class="deo:BibliographicReference" id="370" page="64" column="1">[KVar] Laura Kovacs and Andrei Voronkov. First-Order Theorem Proving and Vampire. In Proceedings of the International Conference on Computer Aided Veri cation (CAV), LNCS , 2013 to appear.</ref>
          <ref rid="R21" class="deo:BibliographicReference" id="371" page="64" column="1">[LRCR13] Daniel Larraz, Enric Rodriguez-Carbonell, and Albert Rubio. SMT-Based Array Invariant Generation. In 14th International Conference Verification, Model Checking, and Abstract Interpretation, VMCAI , 2013.</ref>
          <ref rid="R22" class="deo:BibliographicReference" id="372" page="64" column="1">[MMZ + 11] Matthew W. Moskewicz, Conor F. Madigan, Ying Zhao, Lintao Zhang, and Sharad Malik. Chaff: Engineering an Efficient SAT Solver . 2011.</ref>
          <ref rid="R23" class="deo:BibliographicReference" id="373" page="64" column="1">[MP92] Z. Manna and A. Pnueli. The Temporal Logic of Reactive and Concurrent Systems . Springer, 1992.</ref>
          <ref rid="R24" class="deo:BibliographicReference" id="374" page="64" column="1">[MSS99] J. Marques-Silva and K. Sakallah. GRASP: a search algorithm for propositional satisfiability . pages 506–521, May 1999.</ref>
          <ref rid="R25" class="deo:BibliographicReference" id="375" page="64" column="1">[SS09] Strivastava S. and Gulwani S. Program Verification using Tem- plate over Predicate Abstraction. In Proc. of PLDI , 2009.</ref>
          <ref rid="R26" class="deo:BibliographicReference" id="376" page="64" column="1">[TH06] Dmitry Tsarkov and Ian Horrocks. FaCT++ Description Logic Reasoner: System Description. 4130:292–297, 2006.</ref>
          <ref rid="R27" class="deo:BibliographicReference" id="378" page="65" column="1">[Wan95] Jinchang Wang. A branching heuristic for testing propositional satisfiability . 5, October 1995.</ref>
        </ref-list>
        <outsider class="DoCO:TextBox" type="page_nr" id="363" page="63" column="1">57</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="377" page="64" column="1">58</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="379" page="65" column="1">59</outsider>
      </section>
    </body>
  </article>
</pdfx>
