<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  SYSTEM "http://dtd.nlm.nih.gov/archiving/3.0/archivearticle3.dtd">
<article xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:xlink="http://www.w3.org/1999/xlink">
   <front>
      <journal-meta>
         <journal-id/>
         <journal-title-group>
            <journal-title/>
         </journal-title-group>
         <issn/>
         <publisher>
            <publisher-name/>
         </publisher>
      </journal-meta>
      <article-meta>
         <title-group>
            <article-title>FROM STATIC TO DYNAMIC PROCESS TYPES</article-title>
         </title-group>
         <supplement>
            <p>Franz Puntigam Technische Universität Wien Argentinierstr. 8, 1040 Vienna, Austria Email: <email>franz@complang.tuwien.ac.at</email> Keywords: Process types, synchronization, type systems, race-free programs.</p>
         </supplement>
         <abstract>
            <sec>
               <p>Abstract:  Process types – a kind of behavioral types – specify constraints on message acceptance for the purpose of synchronization and to determine object usage and component behavior in object-oriented languages. So far process types have been regarded as a purely static concept for Actor languages incompatible with inherently dynamic programming techniques. We propose solutions of related problems causing the approach to become useable in more conventional dynamic and concurrent languagues. The proposed approach can ensure message acceptability and support local and static checking of race-free programs.</p>
            </sec>
         </abstract>
      </article-meta>
   </front>
   <body>
      <sec>
         <title>1 INTRODUCTION</title>
      </sec>
      <sec>
         <title>2 STATIC PROCESS TYPES</title>
      </sec>
      <sec>
         <title>3 DYNAMIC TOKENS</title>
         <p>The language TL2 (see <xref id="XR21" ref-type="fig" rid="F2">Figure 2</xref>) slightly extends TL1 with dynamic tokens for synchronization. This concept resembles more conventional synchronization like that in Java. There is no need to anticipate such synchronization at compilation time. We associate each object with a multi-set of tokens (token set for short) to be manipulated dynamically. TL2 differs from TL1 by optional when -clauses in routines and optional initial dynamic tokens (following -&gt; ) in creators. Tokens to the left of -&gt; in when clauses must be available and are removed before executing the body, and tokens to the right are added on return. Different from with -clauses, when -clauses require dynamic tokens to be in the object’s token set and change this token set. If required dynamic tokens are not available, then the execution is blocked until they become available. Checks for token availability occur only at run time. The following variant of the buffer example uses static tokens to avoid buffer overflow and underflow, and dynamic tokens to ensure mutual exclusion: class Buffer50 &lt; Buffer is token sync lst: List new(): Buffer50[empty.50] -&gt;sync do lst = List.new() put(e:E with empty-&gt;filled) when sync-&gt;sync do lst.addLast(e) get(with filled-&gt;empty): E when sync-&gt;sync do return lst.getAndDeleteFirst() The creator introduces just a single token sync . Both put and get remove this token at the begin and issue a new one on return. Clients need not know about the mutual exclusion of all buffer operations. Of course we could use only dynamic tokens which is more common and provides easier handling of buffers. Static and dynamic tokens live in mostly indepen- dent worlds. Nonetheless we have possibilities to move tokens from the static to the dynamic world and vice versa as shown in the following example: class StaticAndDynamic is token t beDynamic(with t-&gt;) when -&gt;t do null beStatic(with -&gt;t) when t-&gt; do null new(): StaticAndDynamic[t] do null There always exists only a single token t for each instance, no matter how often and from how many threads we invoke beDynamic and beStatic . The major advantage of our approach compared to concepts like semaphores and monitors is the higher level of abstraction. It is not so easy to “forget” to release a lock as often occurs with semaphores, and it is not necessary to handle wait queues using wait and notify commands as with monitors. For static tokens we need not execute any specific synchronization code at all. This synchronization is implicit in the control flow.</p>
         <p>decl ::= m ( v * [ with ctok ] opt ) def ::= v : | decl [ when ctok ] opt do s + | new( v * ): t [ -&gt; tok + ] opt do s + s ::= v := e | v = e | e | return [ e ] opt | fork e</p>
         <fig id="F3">
            <caption>
               <p>Figure 3: Syntax of TL3 (Differences to TL1–TL2)</p>
            </caption>
            <graphic xlink:href=""/>
         </fig>
      </sec>
      <sec>
         <title>4 DYNAMIC TYPING</title>
         <p>In TL1 and TL2 we constrained the flexibility of the language to get efficient static type checking: Types of instance variables cannot carry tokens. In this sec- tion we take the position that static type checking is no precondition for the token concept to be useful. We want to increase the language’s flexibility (by supporting tokens on instance variables) and nonetheless ensure that synchronization conditions expressed in with -clauses are always satisfied. An error shall be reported before invocations if required tokens are not available. <xref id="XR27" ref-type="fig" rid="F3">Figure 3</xref> shows the grammar of TL3 that differs form TL2 just by missing type annotations on formal parameters and declarations. However, without type annotations there is no explicit information about available tokens. We handle this information dynamically. One kind of type annotation is left in TL3: Types of new instances returned by creators must be specified explicitly because tokens in this type together with with -clauses determine which routines can be invoked. Such types are part of behavior specifications. Except of type annotations the following example in TL3 equals Buffer50 : class Buffer50Dyn &lt; BufferDyn is token sync lst: new():Buffer50Dyn[empty.50]-&gt;sync do lst = List.new() put(e with empty-&gt;filled) when sync-&gt;sync do lst.addLast(e) get(with filled-&gt;empty) when sync-&gt;sync do return lst.getAndDeleteFirst() The following example gives an intuition about the use of static tokens in a dynamic language. An open window is displayed on a screen or shown as icon: type Window is token displ icon closed setup(with closed-&gt;displ) iconify(with displ-&gt;icon) display(with icon-&gt;displ) close(with displ-&gt;closed) class WManager is win: new(w):WManager do win=w win.setup() onButton1() do win.iconify() onButton2() do win.close() onButton3() do win.display() Some state changes (directly from an icon to closed, etc.) are not supported. Class WManager specifies actions to be performed when users press buttons. Under the assumption that a displayed window has only Button 1 and 2 and an icon only Button 3 the constraints on state changes are obviously satisfied. Since the assumption corresponds to the existence of at most one token for each window we need nothing else to ensure a race-free program. We express the assumption by with -clauses and dynamically ensure them to be satisfied. The variable win must be associated with a (static) token specifying the window’s state. In TL1 and TL2 we cannot express such type information that is implicit in TL3. TL3 deals with dynamic tokens in the same way as TL2. To dynamically handle information about available static tokens we consider two approaches – TL3flex as a simple and flexible approach, and TL3strict as a more restrictive and safer approach. TL3flex. In TL3flex we tread static tokens in a similar way as dynamic tokens: Each objects contains a pool of static tokens. On invocations tokens to the left of -&gt; in with -clauses are taken from the pool, and on return those to the right are added to the pool. An error is reported if the pool does not contain all required tokens. This approach is very flexible. Each thread can use all previously issued static tokens no matter which thread caused the tokens to be issued. A disadvantage is a low quality of error messages because there is no information about the control flow causing tokens not to be available. Furthermore, there is a high probabil- ity for program runs not to uncover synchronization problems. Thus, program testing is an issue. TL3strict. To improve error messages and the prob- ability of detecting problems we dynamically sim- ulate static type checking: Instead of storing static tokens centralized in the object we distribute them among all references to the object. On invocation we check and update only tokens associated with the corresponding reference. We must find an appropriate distribution of tokens among references. In TL1 and TL2 the programmer had to determine the distribution by giving type annotations. In TL3strict we distribute tokens lazily as needed in the computation. Instead of splitting a token set on parameter passing or assignment we associate the two references with pointers to the (unsplit) token set as well as with a new empty token set for each of the two references. Whenever required tokens are not available in the (after assignment or parameter passing empty) token set of a reference we follow the pointers and take the tokens where we find them. New tokens are stored in the references’ own token sets. This way all references get the tokens they need (if available) and we need not foresee how to split token sets. Repeated application leads to a tree of token sets with pointers from the leaves (= active references) toward the root (= token set returned by creator). We report an error only if tokens required at a leaf cannot be collected from all token sets on the path to the root. On return of invocations we let actual parameters point to token sets of corresponding formal parameters. <xref id="XR35" ref-type="fig" rid="F4">Figure 4</xref> shows an example: Immediately after cre- ating a window there is only one reference n to it (a). The box contains the single token in the corresponding token set. When invoking new in WManager using n as actual parameter we construct new token sets for n and for the formal parameter w (b). When the creator assigns w to win we add new token sets for w and win (c). An invocation of setup on win removes the token closed and adds displ . On return from the creator we let the token set of n point to that of w (d). Now only win carries the single token. We cannot change the window’s state through n . Therefore, TL3strict is safer and less flexible than TL3flex. We can build large parts of the structures shown in <xref id="XR36" ref-type="fig" rid="F4">Figure 4</xref> already at compilation time by means of ab-</p>
         <p>type BufferDyn is token empty filled put(e with empty-&gt;filled) get(with filled-&gt;empty)</p>
         <p>class WindowImpl &lt; Window is new(): WindowImpl[closed] do ... ...</p>
         <p>n := WindowImpl.new() WManager.new(n) closed s n n   d w closed</p>
         <p>closed s s n   d n d</p>
         <p>s w   d win</p>
         <fig id="F4">
            <caption>
               <p>Figure 4: Token Sets per Reference</p>
            </caption>
            <graphic xlink:href=""/>
         </fig>
         <p>stract interpretation. Most checks for the availability of tokens can be performed statically. In fact we need dynamic checks of token availability only for tokens associated with instance variables.</p>
      </sec>
      <sec>
         <title>5 RACE-FREE PROGRAMS</title>
         <p>It is possible to ensure race-free programs just by ana- lyzing the tokens in classes. We use only a single sufficient (but not always necessary) criterion: No two preconditions in with -clauses and when -clauses of routines accessing the same variable (where an access is a write) can be satisfied at the same time. To check this criterion we compute upper bounds on the token sets that can be constructed from the tokens of new instances. We analyze each class separately. In the following description of the algorithm to determine upper bounds of token sets we first consider only static tokens as in TL1. We start with the set of token sets declared in the result types of the ana- lyzed class’ creators (one token set per creator). For each with -clause in the class we repeatedly construct new token sets by removing tokens to the left of -&gt; and adding those to the right from/to each token set constructed so far containing all required tokens. If a token set contains all tokens occurring in another token set, then we remove the smaller token set. And if a token set differs from the token set from which it was constructed just by containing more tokens, then we increment the token numbers that differ to the spe- cial value ∞ indicating infinite grow. Because of this treatment the algorithm always reaches a fixed point. The algorithm is accurate in the sense that • the token set produced for an instance of the class is always a subset of a token set returned by the algorithm,  • if a token set returned by the algorithm does not contain ∞ , then there exists a sequence of invocations producing exactly this token set, • and if a token set returned by the algorithm contains ∞ , then there exist invocation sequences producing corresponding tokens without upper bounds. In TL2 and TL3 we must consider static and dynamic tokens together to get most accurate results. Since the static and the dynamic world are clearly separated, static and dynamic tokens must not be in- termixed. We have to clearly mark each token as ei- ther static or dynamic (for example, by an index) and regard differently marked tokens as different. The algorithm starts with one token set for each creator containing both static and dynamic tokens. A new token set is constructed by simultaneously removing and adding tokens as specified in the with - and when clause of a routine. The result shows which dynamic tokens can exist together with static tokens. For example, applied to StaticAndDynamic (see Section 3) the algorithm returns two token sets, one containing only a static token t and the other only a dynamic token t ; in this case no dynamic token can exist at the same time as a static one. Once we know the upper bounds it is easy to perform our check of race-free programs as shown in the following pseudo-code: let U be the upper-bound set of token sets of class c ; for each instance variable v of c for each routine r write-accessing v for each routine s (read or write) accessing v let p be the union of the token sets to the left of -&gt; in r and s ; if there is a u ∈ U containing all tokens in p then issue a warning about a potential race; otherwise c is race-free As an example we apply this check to Buffer1 (see Section 2). As upper-bound set of token sets S we have {{ empty } , { filled }} ; there is always at most one token empty or filled . The only instance variable s is written in put and read in get . Hence, r ranges just over put , s over put and get , and p over { empty . 2 } and { empty , filled } . The class is race-free because no token set in S contains two empty or an empty and a filled . The set S can become quite large because of com- binatorial explosion. For example, S constructed for Buffer50Dyn contains 51 different token sets – all possibilities of summing up tokens of two names to 50 tokens. Fortunately, a simple change in the algorithm to compute upper bounds can reduce the size of S considerably: When computing the fixed point we replace all token numbers larger than 2 · n 2 · i by ∞ , where n is the largest total number of tokens to the left of -&gt; in the with - and when -clause of the same routine, and i is the number of different token names in the class. For Buffer50Dyn we have n = 2 , i = 3 , 2 · n 2 · i = 24 , and S contains just a single token set { sync , empty . ∞ , filled . ∞} . This optimization does not change the output of the race- freeness check: Soundness is not affected because the multi-set of supposedly reachable tokens in a system can just get larger. No token set p (as in the algorithm) can contain more than 2 · n tokens, and a single token of some name can be generated from no more than n · i tokens of another name. Therefore, more than 2 · n 2 · i tokens of one name can be ignored for our purpose. Probably there are more accurate estimations, but we expect this simple one to be sufficient because token numbers to the left of -&gt; are usually small. All information needed to check race-free classes is explicit in TL1, TL2, and TL3. We need no information about formal parameter types and no aliasing information. No global program analysis is necessary.</p>
      </sec>
      <sec>
         <title>6 DISCUSSION, RELATED WORK</title>
         <p>The idea of integrating process types into dynamic languages is new and at a first glance unexpected because such types were developed to move dynamic aspects like synchronization to the static language level whenever possible ( <xref id="XR52" ref-type="bibr" rid="R21">Puntigam, 1995</xref>; Puntigam, 1997; Puntigam, 2000). In some sense the integration of more advanced static concepts into dynamic languages is a consistent further development allowing us to use the appropriate (static or dynamic) concept for each task. Such integration helps us to deepen our understanding of related concepts. We usually regard synchronization of concurrent threads as a purely dynamic concept: If there is a dependence between two control flows, then one of the corresponding threads must wait until the other thread has caught up to meet the synchronization point. Since threads usually run asynchronously and at statically unpredictable speed, it is only possible to decide at run time whether a thread must wait at a synchronization point. However, these considerations are valid only at a very low level (close to the hardware) point of view. From the programmers’ higher level point of view it is quite often not clear whether there exist dependences between threads or not. Using explicit synchronization as with monitors, semaphores, rendezvous communication, etc. programmers must add much more synchronization points than are actually necessary. There are optimization techniques that can statically eliminate up to about 90% (about 60% in average) of all locks from Java programs and thereby considerably improve program performance (von Praun and Gross, 2003). Probably even more synchronization points are actually not necessary. Current programming languages allow program- mers to write programs with races although there are many proposals to ensure race-free programs (Bacon et al., 2000; <xref id="XR54" ref-type="bibr" rid="R5">Boyapati and Rinard, 2001</xref>; Brinch- <xref id="XR55" ref-type="bibr" rid="R6">Hansen, 1975</xref>; <xref id="XR56" ref-type="bibr" rid="R11">Flanagan and Abadi, 1999</xref>). Applica- tions of such techniques may lead to further increase of unnecessary synchronization because no approach can accurately decide between necessary and unnecessary locks. Nonetheless, these techniques are very useful because races are an important practical prob- lem in concurrent programming. Process types were developed as abstractions over expressions in process calculi (<xref id="XR57" ref-type="bibr" rid="R21">Puntigam, 1995</xref>). These abstractions specify acceptable messages of active objects and allow the acceptability to change over time (thereby specifying synchronization constraints). Static type checking ensures that only acceptable messages can be sent and enforces all synchronization constraints to be satisfied. In this sense type checking in process types has a similar purpose as ensuring race-free programs. However, process types allow us to specify arbitrary constraints on message acceptability, not just synchronization necessary to avoid races. In fact, the underlying calculi do not support shared data that could suffer from races. There is a clear tendency toward more and more complex interface specifications going far beyond simple signatures of available routines (<xref id="XR58" ref-type="bibr" rid="R2">Arbab, 2005</xref>; de <xref id="XR59" ref-type="bibr" rid="R10">Alfaro and Henzinger, 2001</xref>; Heuzeroth and Reussner, 1999; <xref id="XR60" ref-type="bibr" rid="R13">Jacobsen and Krämer, 1998</xref>; <xref id="XR61" ref-type="bibr" rid="R16">Lee and Xiong, 2004</xref>; <xref id="XR62" ref-type="bibr" rid="R23">Mezini and Ostermann, 2002</xref>; Nierstrasz, 1993; <xref id="XR63" ref-type="bibr" rid="R28">Plasil and Visnovsky, 2002</xref>; Yellin and Strom, 1997). We consider such interfaces to be partial specifications of object behavior (<xref id="XR64" ref-type="bibr" rid="R17">Liskov and Wing, 1993</xref>). They are especially valuable to specify the behavior of software components as far as needed for component composition. Process types are useful as partial behavior specifications (Puntigam, 2003; Südholt, 2005). We regard behavior specifications as the major reason for using process types. Pre- and postconditions in with -clauses allow us to specify a kind of contracts between components (<xref id="XR65" ref-type="bibr" rid="R20">Meyer, 1997</xref>; <xref id="XR66" ref-type="bibr" rid="R22">Meyer, 2003</xref>). Such contracts clearly specify responsibilities of software and help us to move responsibilities from one component to another. For example, we move the responsibility of proper synchronization from the server to the client if we use with -clauses instead of when -clauses. Behavioral types and synchronization of concurrent threads are related topics: Specifications of object behavior cannot ignore necessary synchronization if we expect components composed according to their behavioral types to work together in concurrent environments, and constraints on message acceptability specify a kind of synchronization. The present work allows programmers to decide between synchronization globally visible through the interface ( with clauses) and local synchronization regarded as an im- plementation detail ( when -clauses). While with clauses just ensure that clients coordinate themselves (for example, through the control flow allowing m2() to be invoked only after m1() ) when -clauses ensure proper synchronization using more conventional techniques. Locking does not get visible in interfaces, just synchronization requirements are visible. There are good reasons for using locking only for local synchronization: Uncoordinated locking easily leads to deadlocks and other undesirable behavior, and it is much easier to coordinate locking within a single unit. The monitor concept supports just local locking for similar reasons. Furthermore, it is very difficult to deal with globally visible locking at the presence of subtyping and inheritance (Matsuoka and <xref id="XR68" ref-type="bibr" rid="R18">Yonezawa, 1993</xref>). Process types express just synchronization conditions in interfaces, they do not provide for locking. Another approach directly expresses locking conditions in interfaces (<xref id="XR69" ref-type="bibr" rid="R7">Caromel, 1993</xref>; <xref id="XR70" ref-type="bibr" rid="R19">Meyer, 1993</xref>). As experience shows, that approach easily leads to undesirable locking where it would be more appropriate to raise exceptions. There are several approaches similar to process types. Nierstrasz (<xref id="XR71" ref-type="bibr" rid="R27">Nierstrasz, 1993</xref>) and Nielson and Nielson (<xref id="XR72" ref-type="bibr" rid="R26">Nielson and Nielson, 1993</xref>) define behavioral types where subtypes show the same deadlock behavior as supertypes, but message acceptability is not ensured. Many further approaches consider dynamic changes of message acceptability, but do not guarantee message acceptability in all cases (Caromel, 1993; <xref id="XR73" ref-type="bibr" rid="R9">Colaco et al., 1997</xref>; <xref id="XR74" ref-type="bibr" rid="R15">Kobayashi and Yonezawa, 1994</xref>; <xref id="XR75" ref-type="bibr" rid="R19">Meyer, 1993</xref>; Ravara and Vasconcelos, 1997). Well known in the area of typed π -calculi (<xref id="XR76" ref-type="bibr" rid="R24">Milner et al., 1992</xref>) is the work of Kobayashi, Pierce and Turner on linearity (<xref id="XR77" ref-type="bibr" rid="R14">Kobayashi et al., 1999</xref>) which ensures all sent messages to be acceptable. Work of Najm and Nimour (<xref id="XR78" ref-type="bibr" rid="R25">Najm and Nimour, 1997</xref>) is very similar to process types except that in their approach at each time only one user can interact with an object through an interface (no type splitting). These approaches specify constraints on the acceptability of messages in a rather direct way and do not make use of a token concept. The use of tokens in behavior specifications gives us high expressiveness and flexibility, allows us to express synchronization in a way similar to well-known concepts like monitors and semaphores, and is easily understandable.</p>
      </sec>
      <sec>
         <title>7 CONCLUSION</title>
         <p>Behavioral types like process types gain more and more importance especially together with component composition. By partially specifying object behavior these types express synchronization in the form of software contracts clearly determining who is respon-  sible for proper synchronization. Process types use simple token sets as abstractions over object states. In this paper we explored how to add process types to rather conventional object-oriented programming languages. As a showcase we developed the languages TL1 to TL3. Static type checking in TL1 ensures that all conditions in with -clauses are satisfied, this is, all required tokens are available. We can syn- chronize concurrent threads just by waiting for messages. To overcome the restriction, TL2 adds a new dynamic concept of synchronization based on token sets. Neither TL1 nor TL2 can deal with static token sets associated with instance variables because of possible simultaneous accesses by concurrent threads. In TL3 we dispense with static types and apply one of two methods to dynamically ensure the availability of required tokens – a flexible method and one with bet- ter error messages and partial support of static type checking. All variables in TL3 have only dynamic types that can implicitly carry tokens. In the three languages we can ensure race-free programs by checking each class separately, without any need of global aliasing information. Our approach uses token sets for several related purposes – synchronization of concurrent threads and statically and dynamically checked abstract behavior specifications. It is a major achievement to integrate these concepts because of complicated interrelations. The integration is valuable because it gives software developers much freedom and at the same time clear contracts and type safety. Much work on this topic remains to be done. For example, currently our algorithm can issue warnings about potential races even in purely sequential program parts. Many other approaches to ensure race- free programs put much effort into detecting sequential program parts. By integrating such approaches into our algorithm we expect to considerably improve the accuracy. Most approaches to remove unnecessary locking from concurrent programs also work on sequential program parts (<xref id="XR82" ref-type="bibr" rid="R8">Choi et al., 1999</xref>; von Praun and Gross, 2003; Vivien and <xref id="XR83" ref-type="bibr" rid="R5">Rinard, 2001</xref>). We expect a combination of the techniques to improve run time efficiency.</p>
      </sec>
      <sec>
         <title>REFERENCES</title>
      </sec>
   </body>
   <back>
      <ref-list>
         <ref id="R1">
            <mixed-citation>Agha, G., Mason, I. A., Smith, S., and Talcott, C. (1992). Towards a theory of actor computation. In Proceedings CONCUR’92 , number 630 in Lecture Notes in Computer Science, pages 565–579. Springer-Verlag.</mixed-citation>
         </ref>
         <ref id="R2">
            <mixed-citation>Arbab, F. (2005). Abstract behavior types: A foundation model for components and their composition. Science of Computer Programming , 55(1–3):3–52.</mixed-citation>
         </ref>
         <ref id="R3">
            <mixed-citation>Bacon, D. F., Strom, R. E., and Tarafdar, A. (2000). Guava:</mixed-citation>
         </ref>
         <ref id="R4">
            <mixed-citation>A dialect of Java without data races. In OOPSLA 2000 .</mixed-citation>
         </ref>
         <ref id="R5">
            <mixed-citation>Boyapati, C. and Rinard, M. (2001). A parameterized type system for race-free Java programs. In OOPSLA 2001 . ACM.</mixed-citation>
         </ref>
         <ref id="R6">
            <mixed-citation>Brinch-Hansen, P. (1975). The programming language Concurrent Pascal. IEEE Transactions on Software Engineering , 1(2):199–207.</mixed-citation>
         </ref>
         <ref id="R7">
            <mixed-citation>Caromel, D. (1993). Toward a method of object-oriented concurrent programming. Communications of the ACM , 36(9):90–101.</mixed-citation>
         </ref>
         <ref id="R8">
            <mixed-citation>Choi, J.-D., Gupta, M., Serrano, M., Sreedhar, V. C., and Midkiff, S. (1999). Escape analysis for Java. In OOP- SLA’99 , Denver, Colorado.</mixed-citation>
         </ref>
         <ref id="R9">
            <mixed-citation>Colaco, J.-L., Pantel, M., and Salle, P. (1997). A set- constraint-based analysis of actors. In Proceedings FMOODS’97 , Canterbury, United Kingdom. Chapman &amp; Hall.</mixed-citation>
         </ref>
         <ref id="R10">
            <mixed-citation>de Alfaro, L. and Henzinger, T. A. (2001). Interface au- tomata. In Proceedings of the Ninth Annual Sympo- sium on Foundations of Software Engineering (FSE) , pages 109–120. ACM Press.</mixed-citation>
         </ref>
         <ref id="R11">
            <mixed-citation>Flanagan, F. and Abadi, M. (1999). Types for safe locking. In Proceedings ESOP’99 , Amsterdam, The Nether- lands.</mixed-citation>
         </ref>
         <ref id="R12">
            <mixed-citation>Heuzeroth, D. and Reussner, R. (1999). Meta-protocol [1] and Agha type system for the dynamic coupling of binary [2] com- Arbab ponents. In OORASE’99: OOSPLA’99 Workshop [3] Bacon on Reflection and Software Engineering , Bicocca, [4] Italy. Boyapati</mixed-citation>
         </ref>
         <ref id="R13">
            <mixed-citation>Jacobsen, H.-A. and Krämer, B. J. (1998). [5] A design Meyer pattern tion adaptors based from approach annotated to generating IDL. In IEEE synchroniza- [6] Interna- Brinch-Hansen tional Conference on Automated Software [7] Engineer- Mezini ing (ASE’98) , pages 63–72, Honolulu, Hawaii, [8] USA.</mixed-citation>
         </ref>
         <ref id="R14">
            <mixed-citation>Kobayashi, N., Pierce, B., and Turner, D. (1999). [9] Linearity Milner and the pi-calculus. ACM Transactions on [10] Program- Choi ming Languages and Systems , 21(5):914–947. [11] Najm</mixed-citation>
         </ref>
         <ref id="R15">
            <mixed-citation>Kobayashi, N. and Yonezawa, A. (1994). Type-theoretic [12] foundations for concurrent object-oriented [13] program- ceedings ming. ACM OOPSLA’94. SIGPLAN Notices , 29(10):31–45. [14] [15] Pro- De</mixed-citation>
         </ref>
         <ref id="R16">
            <mixed-citation>Lee, E. and A. its and application Xiong, Y. in (2004). Ptolemy A behavioral II. Formal type Aspects [16] system of Computing , 16(3):210–237. [17]</mixed-citation>
         </ref>
         <ref id="R17">
            <mixed-citation>Liskov, B. and Wing, J. M. (1993). Specifications [18] and their use in defining subtypes. ACM SIGPLAN [19] Notices , 28(10):16–28. Proceedings OOPSLA’93. [20]</mixed-citation>
         </ref>
         <ref id="R18">
            <mixed-citation>Matsuoka, S. and Yonezawa, A. (1993). Analysis [21] of inheritance anomaly in object-oriented concurrent [22] programming languages. In Agha, G., editor, [23] Research Directions in Concurrent Object-Oriented [24] Programming . The MIT Press. [25]</mixed-citation>
         </ref>
         <ref id="R19">
            <mixed-citation>Meyer, 36(9):56–80. oriented B. (1993). programming. Systematic Communications concurrent of [27] [26] the object- ACM Lee ,</mixed-citation>
         </ref>
         <ref id="R20">
            <mixed-citation>Meyer, B. (1997). Object-Oriented Software Construction [28] . Prentice Hall, second edition edition. [29] Südholt</mixed-citation>
         </ref>
         <ref id="R21">
            <mixed-citation>Puntigam, F. (1995). Flexible types for a concurrent model. Caromel Ravara Puntigam Kobayashi Flanagan Heuzeroth Jacobsen Puntigam Plasil Kobayashi Liskov Nielson Nierstrasz Puntigam Puntigam Colaco Alfaro 1992 2004 Yellin, von Vivien, Ravara, Südholt, Puntigam, Puntigam, Puntigam, 1997 2000 1999 2003 2005 1992 2002 1997 2002 1993 1993 1997 Praun, 2005 1993 2001 on 333. cations ysis PLDI and 2005) ings Computer regular many. types Osnabrück, Jyväskylä gramming interfaces. Component-Oriented Lecture Programming in S., In 1999 2000 1995 1997 2003 1998 D. F. types 2001 1999 1999 1994 Proceedings Programming A. editors, M. escape 1993 for and Euro-Par’97 F. F. M. , for C. F. ’03 and Edinburgh, (2003). (2005). (1997). and 1975 for Notes multi-threaded protocols. and (2000). and a Rinard, , , Science, pages calculus Finland. with Vasconcelos, analysis. Proceedings active Germany. component Gross, In Strom, and in State Coordination of Process 115–128. Eighth A Languages M. , Computer objects. Scotland. Models Concurrent the number pages of Springer-Verlag. model T. In information (2001). R. In Programming concurrent R. Puntigam Puntigam Puntigam Plasil Nierstrasz Milner Meyer Bacon Mezini Nielson Meyer Arbab Brinch-Hansen Boyapati Agha Najm Kobayashi Heuzeroth Caromel Flanagan Jacobsen Kobayashi Lee Colaco Choi De Matsuoka Meyer Liskov Workshop PLDI object-oriented adaptors. ECOOP’97 E. Types International Software V. (2003). 554–561. In of ACM of 1300 (1997). Alfaro Science, T. and Aksit, Concurrency 2004 Incrementalized ’01 requirements components . 1997 1992 1999 Object-Oriented (1997). 2000 1997 2005 1993 2003 Press. . Systems in Der objects. in on Static ACM. 2002 1992 2002 1997 1993 ACM Composition M. , Springer-Verlag. statically , 1993 1993 Lecture Protocol Darmstadt, Object-Oriented number pages 2000 1997 1995 2001 1998 1999 [26] 1993 Andere and [1] [11] 2001 1999 [10] 1999 1994 Workshop programs. conflict Transactions , 1993 [2] [3] [33] [5] [35] Behavioural In , 19(2):292– [17] [9] [7] [12] [28] Matsuoka, Torino. with expressed 367–388, Proceed- [13] [8] Notes checked 1241 specifi- [23] [21] [19] 1975 [4] [20] [30] [16] Verlag, pointer [14] [24] [18] [22] anal- non- Ger- Pro- [15] (SC on In in in</mixed-citation>
         </ref>
         <ref id="R22">
            <mixed-citation>Meyer, B. (2003). The grand challenge of trusted components. In ICSE-25 (International Conference on Software Engineering) , Portland, Oregon. IEEE Computer Press.</mixed-citation>
         </ref>
         <ref id="R23">
            <mixed-citation>Mezini, M. and Ostermann, K. (2002). Integrating indepen- dent components with on-demand remodularization. In OOPSLA 2002 Conference Proceedings , pages 52– 67, Seattle, Washington. ACM.</mixed-citation>
         </ref>
         <ref id="R24">
            <mixed-citation>Milner, R., Parrow, J., and Walker, D. (1992). A calculus of mobile processes (parts I and II). Information and Computation , 100:1–77.</mixed-citation>
         </ref>
         <ref id="R25">
            <mixed-citation>Najm, E. and Nimour, A. (1997). A calculus of object bindings. In Proceedings FMOODS’97 , Canterbury, United Kingdom. Chapman &amp; Hall.</mixed-citation>
         </ref>
         <ref id="R26">
            <mixed-citation>Nielson, F. and Nielson, H. R. (1993). From CML to process algebras. In Proceedings CONCUR’93 , number 715 in Lecture Notes in Computer Science, pages 493–508. Springer-Verlag.</mixed-citation>
         </ref>
         <ref id="R27">
            <mixed-citation>Nierstrasz, O. (1993). Regular types for active objects. ACM SIGPLAN Notices , 28(10):1–15. Proceedings OOPSLA’93.</mixed-citation>
         </ref>
         <ref id="R28">
            <mixed-citation>Plasil, F. and Visnovsky, S. (2002). Behavioral protocols for software components. IEEE Transactions on Software Engineering , 28(11):1056–1076.</mixed-citation>
         </ref>
      </ref-list>
   </back>
</article>