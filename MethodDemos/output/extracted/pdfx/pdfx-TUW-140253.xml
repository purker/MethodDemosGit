<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>b457f695dbeb521b9e20bf77deaf16c4e25fb3d79090b3f562b980bed01bf978</job>
    <base_name>l2j</base_name>
    <doi>http://dx.doi.org/10.5220/0001312900210028</doi>
    <warning>Name identification was not possible. </warning>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <title-group>
        <article-title class="DoCO:Title" id="1">FROM STATIC TO DYNAMIC PROCESS TYPES</article-title>
      </title-group>
      <region class="unknown" id="3">Franz Puntigam Technische Universität Wien Argentinierstr. 8, 1040 Vienna, Austria Email: <email id="2">franz@complang.tuwien.ac.at</email> Keywords: Process types, synchronization, type systems, race-free programs.</region>
      <abstract class="DoCO:Abstract" id="5">Abstract: <marker type="block"/> Process types – a kind of behavioral types – specify constraints on message acceptance for the purpose of synchronization and to determine object usage and component behavior in object-oriented languages. So far process types have been regarded as a purely static concept for Actor languages incompatible with inherently dynamic programming techniques. We propose solutions of related problems causing the approach to become useable in more conventional dynamic and concurrent languagues. The proposed approach can ensure message acceptability and support local and static checking of race-free programs.</abstract>
    </front>
    <body class="DoCO:BodyMatter">
      <section class="deo:Introduction">
        <h1 class="DoCO:SectionTitle" id="6" page="1" column="1">1 INTRODUCTION</h1>
      </section>
      <region class="DoCO:TextChunk" id="9" page="1" column="1">Process types (Puntigam, 1997) represent a behavioral counterpart to conventional object types: They support subtyping, genericity, and separate compilation as conventional types. Additionally they specify abstractions of object behavior. Abstract behavior specifications are especially desirable for software components, and they can be used for synchronization. Both concurrent and component-based programming are quickly becoming mainstream programming practices, and we expect concepts like process types to be important in the near future. However, so far process types are not usable in mainstream languages: 1. Their basis are active objects communicating by message passing ( <xref ref-type="bibr" rid="R1" id="7" class="deo:Reference">Agha et al., 1992</xref>). Variables are accessible only within single threads. In mainstream languages like Java, threads communicate through shared (instance) variables; one thread reads values written by another. To support such languages we must extend process types with support of shared variables. 2. Process types are static. Object state changes must be anticipated at compilation time. We must adapt process types to support dynamic languages like Smalltalk (using dynamic process type checking). Support of dynamic languages turns out to be a good basis for supporting communication through shared variables. Hence, we address mainly the second issue<marker type="column" number="2"/><marker type="block"/> and show how dynamic type checking can deal with the first issue. We introduce the basic static concept of process types for a conventional (Java-like) object model in Section 2. Then, we add support of dynamic synchronization in Section 3 and of shared variables with late type checking in Section 4. Local and static checking of race-free programs is rather easy in our setting as discussed in Section 5.</region>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="10" page="1" column="2">2 STATIC PROCESS TYPES</h1>
      </section>
      <region class="DoCO:TextChunk" id="19" page="1" column="2"> <xref ref-type="fig" rid="F1" id="11" class="deo:Reference">Figure 1</xref> shows the grammar of TL1 (Token Lan- guage 1) – a simple Java-like language we use as showcase. We differentiate between classes and types without implementations. To create a new object we invoke a creator new in a class. Type annotations follow after “:”. Token declarations (names following the keyword token ), tokens occurring within square brackets in types, and with -clauses together determine the statically specified object behavior. The first example shows how tokens allow us to specify constraints on the acceptability of messages: type Buffer is token empty filled put(e:E with empty-&gt;filled) get(with filled-&gt;empty): E According to the with -clause in put we can invoke put only if we have an empty ; this token is removed<marker type="page" number="2"/><marker type="column" number="1"/><marker type="block"/> on invocation, and filled is added on return. For x of type Buffer[empty] – a buffer with a single token empty – we invoke x.put(..) . This invocation changes the type of x to Buffer[filled] . Next we invoke x.get() , then x.put(..) , and so on. Static type checking enforces put and get to be invoked in instances of Buffer[empty] in al- ternation. Type checking is simple because we need only compare available tokens with tokens required by with -clauses and change tokens as specified by with -clauses (Puntigam, 1997). The type Buffer[empty.8 filled.7] de- notes a buffer with at least 8 filled and 7 empty slots. An instance accepts put and get in all sequences such that the buffer never contains more that 15 or less than zero elements as far as the client knows. In the next example we show how to handle tokens in parameter types similarly as in with -clauses: class Test is play(b:Buffer[filled-&gt;filled]) do e:E = b.get() -- b:Buffer[empty] e = e.subst() -- another e b.put(e) -- b:Buffer[filled] copy(b:Buffer[empty filled-&gt;filled.2]) do e:E = b.get() -- b:Buffer[empty.2] b.put(e) -- b:Buffer[empty filled] b.put(e) -- b:Buffer[filled.2] Let y be of type Buffer[empty.2 filled.2] and x of type Test . We can invoke x.play(y) since y has the required token filled . This routine gets an element from the buffer, assigns it to the local variable e (declared in the first statement), assigns a different element to e , and puts this element into the buffer. Within play the buffer is known to have a single filled slot on invocation and on return. For the type of b specified in the formal parameter list it does not matter that the buffer has been empty meanwhile and the buffer contents changed.<marker type="column" number="2"/><marker type="block"/> After return from play variable y is still of type Buffer[empty.2 filled.2] . Invocations of copy change argument types: On return from x.copy(y) variable y will be of type Buffer[empty filled.3] . Removing tokens to the left of -&gt; on invocation causes the type to become Buffer[empty filled] , and adding the tokens to the right on return causes it to become Buffer[empty filled.3] . Parameter passing does not produce or consume tokens. Tokens just move from the argument type to the parameter type on invocation and vice versa on return. Only with -clauses can actually add tokens to and remove them from an object system. This is a basic principle behind the idea of tokens: Each object can produce and consume only its own tokens. A statement ‘ fork x.copy(y) ’ spawns a new thread executing x.copy(y) . Since the execution continues without waiting for the new threads, invoked routines cannot return tokens. The type of y changes from Buffer[empty.2 filled.2] to Buffer[empty filled] . The type of y is split into two types – the new type of y and the type of b . Both threads invoke routines in the same buffer without affecting each other concerning type information. Assignment resembles parameter passing in the case of spawning threads: We split the type of an assigned value into two types such that one of the split types equals the current static type of the variable, and the remaining type becomes the new type of the assigned value. Thereby, tokens move from the value’s to the variable’s type. If the statically evalu- ated type of v is Buffer[empty.2] and y is of type Buffer[empty.2 filled.2] , then v=y causes y ’s type to become Buffer[filled.2] . Local variables are visible in just a single thread of control. This property is important because it allows us to perform efficient type checking by a single walk through the code although variable types can change with each invocation. Because of explicit formal parameter types we can check each class separately. If variables with tokens in their types were accessible in several threads, then we must consider myriads of possible interleavings causing static type checking to become practically impossible. Instance variables can be shared by several threads. To support instance variables and still keep the efficiency of type checking we require their types to carry no token information. We address this restriction in Section 4. Explicit result types of creators play a quite important role for introducing tokens into the system: class Buffer1 &lt; Buffer is s:E -- single buffer slot put(e:E with empty-&gt;filled) do s=e get(with filled-&gt;empty):E do return s new(): Buffer1[empty] do null Class Buffer1 inherits empty and filled from<marker type="page" number="3"/><marker type="column" number="1"/><marker type="block"/> Buffer . An invocation of Buffer1.new() returns a new instance with a single token empty . No other token is initially available. Since invocations of put and get consume a token before they issue another one, there is always at most one token for this object. No empty buffer slot can be read and no filled one overwritten, and we need no further synchronization even if several threads access the buffer. The use of tokens greatly simplifies the implementation. However, this solution is inherently static and does not work in more dynamic environments.</region>
      <region class="unknown" id="13" page="2" column="1">P ::= unit * unit ::= class c [ &lt; c + ] opt is [ token x + ] opt def + | type c [ &lt; c + ] opt is [ token x + ] opt decl + decl ::= m ( par * [ with ctok ] opt ) [ : t ] opt def ::= v : c | decl do s + | new( par * ): t do s + par ::= v : c [ [ ctok ] ] opt ctok ::= tok + -&gt; tok * | -&gt; tok + tok ::= x [ . n ] opt t ::= c [ [ tok + ] ] opt s ::= v : t = e | v = e | e | return [ e ] opt | fork e e ::= this | v | c | n | e . m ( e * ) | null c ∈ class and type names x ∈ token names m ∈ message selectors v ∈ variable names n ∈ natural number literals</region>
      <region class="DoCO:FigureBox" id="F1">
        <caption class="deo:Caption" id="14" page="2" column="1">Figure 1: Syntax of TL1</caption>
      </region>
      <region class="unknown" id="17" page="3" column="1">def ::= v : c | decl [ when ctok ] opt do s + | new( par * ): t [ -&gt; tok + ] opt do s +</region>
      <region class="DoCO:FigureBox" id="F2">
        <caption class="deo:Caption" id="18" page="3" column="1">Figure 2: Syntax of TL2 (Differences to TL1)</caption>
      </region>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="20" page="3" column="1">3 DYNAMIC TOKENS</h1>
        <region class="DoCO:TextChunk" id="25" page="3" column="1">The language TL2 (see <xref ref-type="fig" rid="F2" id="21" class="deo:Reference">Figure 2</xref>) slightly extends TL1 with dynamic tokens for synchronization. This concept resembles more conventional synchronization like that in Java. There is no need to anticipate such synchronization at compilation time. We associate each object with a multi-set of tokens (token set for short) to be manipulated dynamically. TL2 differs from TL1 by optional when -clauses in routines and optional initial dynamic tokens (following -&gt; ) in creators. Tokens to the left of -&gt; in when clauses must be available and are removed before executing the body, and tokens to the right are added on return. Different from with -clauses, when -clauses require dynamic tokens to be in the object’s token set and change this token set. If required dynamic tokens are not available, then the execution is blocked until they become available. Checks for token availability occur only at run time. The following variant of the buffer example uses static tokens to avoid buffer overflow and underflow, and dynamic tokens to ensure mutual exclusion: class Buffer50 &lt; Buffer is token sync lst: List new(): Buffer50[empty.50] -&gt;sync do lst = List.new() put(e:E with empty-&gt;filled) when sync-&gt;sync do lst.addLast(e) get(with filled-&gt;empty): E when sync-&gt;sync do return lst.getAndDeleteFirst() The creator introduces just a single token sync . Both put and get remove this token at the begin and issue a new one on return. Clients need not know about the mutual exclusion of all buffer operations. Of course<marker type="column" number="2"/><marker type="block"/> we could use only dynamic tokens which is more common and provides easier handling of buffers. Static and dynamic tokens live in mostly indepen- dent worlds. Nonetheless we have possibilities to move tokens from the static to the dynamic world and vice versa as shown in the following example: class StaticAndDynamic is token t beDynamic(with t-&gt;) when -&gt;t do null beStatic(with -&gt;t) when t-&gt; do null new(): StaticAndDynamic[t] do null There always exists only a single token t for each instance, no matter how often and from how many threads we invoke beDynamic and beStatic . The major advantage of our approach compared to concepts like semaphores and monitors is the higher level of abstraction. It is not so easy to “forget” to release a lock as often occurs with semaphores, and it is not necessary to handle wait queues using wait and notify commands as with monitors. For static tokens we need not execute any specific synchronization code at all. This synchronization is implicit in the control flow.</region>
        <region class="unknown" id="23" page="3" column="2">decl ::= m ( v * [ with ctok ] opt ) def ::= v : | decl [ when ctok ] opt do s + | new( v * ): t [ -&gt; tok + ] opt do s + s ::= v := e | v = e | e | return [ e ] opt | fork e</region>
        <region class="DoCO:FigureBox" id="F3">
          <caption class="deo:Caption" id="24" page="3" column="2">Figure 3: Syntax of TL3 (Differences to TL1–TL2)</caption>
        </region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="26" page="3" column="2">4 DYNAMIC TYPING</h1>
        <region class="DoCO:TextChunk" id="37" page="3" column="2">In TL1 and TL2 we constrained the flexibility of the language to get efficient static type checking: Types of instance variables cannot carry tokens. In this sec- tion we take the position that static type checking is no precondition for the token concept to be useful. We want to increase the language’s flexibility (by supporting tokens on instance variables) and nonetheless ensure that synchronization conditions expressed in with -clauses are always satisfied. An error shall be reported before invocations if required tokens are not available. <xref ref-type="fig" rid="F3" id="27" class="deo:Reference">Figure 3</xref> shows the grammar of TL3 that differs form TL2 just by missing type annotations on formal parameters and declarations. However, without type annotations there is no explicit information about available tokens. We handle this information dynamically. One kind of type annotation is left in TL3: Types of new instances returned by creators must be specified explicitly because tokens in this type together with with -clauses determine which routines can be invoked. Such types are part of behavior specifications. Except of type annotations the following example in TL3 equals Buffer50 :<marker type="page" number="4"/><marker type="column" number="1"/><marker type="block"/> class Buffer50Dyn &lt; BufferDyn is token sync lst: new():Buffer50Dyn[empty.50]-&gt;sync do lst = List.new() put(e with empty-&gt;filled) when sync-&gt;sync do lst.addLast(e) get(with filled-&gt;empty) when sync-&gt;sync do return lst.getAndDeleteFirst() The following example gives an intuition about the use of static tokens in a dynamic language. An open window is displayed on a screen or shown as icon: type Window is token displ icon closed setup(with closed-&gt;displ) iconify(with displ-&gt;icon) display(with icon-&gt;displ) close(with displ-&gt;closed)<marker type="block"/> class WManager is win: new(w):WManager do win=w win.setup() onButton1() do win.iconify() onButton2() do win.close() onButton3() do win.display() Some state changes (directly from an icon to closed, etc.) are not supported. Class WManager specifies actions to be performed when users press buttons. Under the assumption that a displayed window has only Button 1 and 2 and an icon only Button 3 the constraints on state changes are obviously satisfied. Since the assumption corresponds to the existence of at most one token for each window we need nothing else to ensure a race-free program. We express the assumption by with -clauses and dynamically ensure them to be satisfied. The variable win must be associated with a (static) token specifying the window’s state. In TL1 and TL2 we cannot express such type information that is implicit in TL3. TL3 deals with dynamic tokens in the same way as TL2. To dynamically handle information about available static tokens we consider two approaches – TL3flex as a simple and flexible approach, and TL3strict as a more restrictive and safer approach.<marker type="block"/> TL3flex. In TL3flex we tread static tokens in a similar way as dynamic tokens: Each objects contains a pool of static tokens. On invocations tokens to the left of -&gt; in with -clauses are taken from the pool,<marker type="column" number="2"/><marker type="block"/> and on return those to the right are added to the pool. An error is reported if the pool does not contain all required tokens. This approach is very flexible. Each thread can use all previously issued static tokens no matter which thread caused the tokens to be issued. A disadvantage is a low quality of error messages because there is no information about the control flow causing tokens not to be available. Furthermore, there is a high probabil- ity for program runs not to uncover synchronization problems. Thus, program testing is an issue.<marker type="block"/> TL3strict. To improve error messages and the prob- ability of detecting problems we dynamically sim- ulate static type checking: Instead of storing static tokens centralized in the object we distribute them among all references to the object. On invocation we check and update only tokens associated with the corresponding reference. We must find an appropriate distribution of tokens among references. In TL1 and TL2 the programmer had to determine the distribution by giving type annotations. In TL3strict we distribute tokens lazily as needed in the computation. Instead of splitting a token set on parameter passing or assignment we associate the two references with pointers to the (unsplit) token set as well as with a new empty token set for each of the two references. Whenever required tokens are not available in the (after assignment or parameter passing empty) token set of a reference we follow the pointers and take the tokens where we find them. New tokens are stored in the references’ own token sets. This way all references get the tokens they need (if available) and we need not foresee how to split token sets. Repeated application leads to a tree of token sets with pointers from the leaves (= active references) toward the root (= token set returned by creator). We report an error only if tokens required at a leaf cannot be collected from all token sets on the path to the root. On return of invocations we let actual parameters point to token sets of corresponding formal parameters. <xref ref-type="fig" rid="F4" id="35" class="deo:Reference">Figure 4</xref> shows an example: Immediately after cre- ating a window there is only one reference n to it (a). The box contains the single token in the corresponding token set. When invoking new in WManager using n as actual parameter we construct new token sets for n and for the formal parameter w (b). When the creator assigns w to win we add new token sets for w and win (c). An invocation of setup on win removes the token closed and adds displ . On return from the creator we let the token set of n point to that of w (d). Now only win carries the single token. We cannot change the window’s state through n . Therefore, TL3strict is safer and less flexible than TL3flex. We can build large parts of the structures shown in <xref ref-type="fig" rid="F4" id="36" class="deo:Reference">Figure 4</xref> already at compilation time by means of ab-</region>
        <region class="unknown" id="29" page="4" column="1">type BufferDyn is token empty filled put(e with empty-&gt;filled) get(with filled-&gt;empty)</region>
        <region class="unknown" id="31" page="4" column="1">class WindowImpl &lt; Window is new(): WindowImpl[closed] do ... ...</region>
        <region class="unknown" id="38" page="5" column="1">n := WindowImpl.new() WManager.new(n) closed s n n   d w closed</region>
        <disp-formula class="DoCO:FormulaBox" id="Fa">
          <label class="DoCO:Label" id="39">a</label>
          <content class="DoCO:Formula" id="40" page="5" column="1">(b)</content>
        </disp-formula>
        <region class="unknown" id="41" page="5" column="1">closed s s n   d n d</region>
        <region class="unknown" id="42" page="5" column="1">s w   d win</region>
        <disp-formula class="DoCO:FormulaBox" id="Fc">
          <label class="DoCO:Label" id="43">c</label>
          <content class="DoCO:Formula" id="44" page="5" column="1">d s w   d win displ (d)</content>
        </disp-formula>
        <region class="DoCO:FigureBox" id="F4">
          <caption class="deo:Caption" id="45" page="5" column="1">Figure 4: Token Sets per Reference</caption>
        </region>
        <region class="DoCO:TextChunk" id="46" page="5" column="1">stract interpretation. Most checks for the availability of tokens can be performed statically. In fact we need dynamic checks of token availability only for tokens associated with instance variables.</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="47" page="5" column="1">5 RACE-FREE PROGRAMS</h1>
        <region class="DoCO:TextChunk" id="50" page="5" column="1">It is possible to ensure race-free programs just by ana- lyzing the tokens in classes. We use only a single sufficient (but not always necessary) criterion: No two preconditions in with -clauses and when -clauses of routines accessing the same variable (where an access is a write) can be satisfied at the same time. To check this criterion we compute upper bounds on the token sets that can be constructed from the tokens of new instances. We analyze each class separately. In the following description of the algorithm to determine upper bounds of token sets we first consider only static tokens as in TL1. We start with the set of token sets declared in the result types of the ana- lyzed class’ creators (one token set per creator). For each with -clause in the class we repeatedly construct new token sets by removing tokens to the left of -&gt; and adding those to the right from/to each token set constructed so far containing all required tokens. If a token set contains all tokens occurring in another token set, then we remove the smaller token set. And if a token set differs from the token set from which it was constructed just by containing more tokens, then we increment the token numbers that differ to the spe- cial value ∞ indicating infinite grow. Because of this treatment the algorithm always reaches a fixed point. The algorithm is accurate in the sense that • the token set produced for an instance of the class is always a subset of a token set returned by the algorithm, <marker type="column" number="2"/><marker type="block"/> • if a token set returned by the algorithm does not contain ∞ , then there exists a sequence of invocations producing exactly this token set, • and if a token set returned by the algorithm contains ∞ , then there exist invocation sequences producing corresponding tokens without upper bounds. In TL2 and TL3 we must consider static and dynamic tokens together to get most accurate results. Since the static and the dynamic world are clearly separated, static and dynamic tokens must not be in- termixed. We have to clearly mark each token as ei- ther static or dynamic (for example, by an index) and regard differently marked tokens as different. The algorithm starts with one token set for each creator containing both static and dynamic tokens. A new token set is constructed by simultaneously removing and adding tokens as specified in the with - and when clause of a routine. The result shows which dynamic tokens can exist together with static tokens. For example, applied to StaticAndDynamic (see Section 3) the algorithm returns two token sets, one containing only a static token t and the other only a dynamic token t ; in this case no dynamic token can exist at the same time as a static one. Once we know the upper bounds it is easy to perform our check of race-free programs as shown in the following pseudo-code: let U be the upper-bound set of token sets of class c ; for each instance variable v of c for each routine r write-accessing v for each routine s (read or write) accessing v let p be the union of the token sets to the left of -&gt; in r and s ; if there is a u ∈ U containing all tokens in p then issue a warning about a potential race; otherwise c is race-free As an example we apply this check to Buffer1 (see Section 2). As upper-bound set of token sets S we have {{ empty } , { filled }} ; there is always at most one token empty or filled . The only instance variable s is written in put and read in get . Hence, r ranges just over put , s over put and get , and p over { empty . 2 } and { empty , filled } . The class is race-free because no token set in S contains two empty or an empty and a filled . The set S can become quite large because of com- binatorial explosion. For example, S constructed for Buffer50Dyn contains 51 different token sets – all possibilities of summing up tokens of two names to 50 tokens. Fortunately, a simple change in the algorithm to compute upper bounds can reduce the size of S considerably: When computing the fixed point we replace all token numbers larger than 2 · n 2 · i by ∞ , where n is the largest total number of tokens to the left of -&gt; in the with - and when -clause of the same routine, and i is the number of different token names<marker type="page" number="6"/><marker type="column" number="1"/><marker type="block"/> in the class. For Buffer50Dyn we have n = 2 , i = 3 , 2 · n 2 · i = 24 , and S contains just a single token set { sync , empty . ∞ , filled . ∞} . This optimization does not change the output of the race- freeness check: Soundness is not affected because the multi-set of supposedly reachable tokens in a system can just get larger. No token set p (as in the algorithm) can contain more than 2 · n tokens, and a single token of some name can be generated from no more than n · i tokens of another name. Therefore, more than 2 · n 2 · i tokens of one name can be ignored for our purpose. Probably there are more accurate estimations, but we expect this simple one to be sufficient because token numbers to the left of -&gt; are usually small. All information needed to check race-free classes is explicit in TL1, TL2, and TL3. We need no information about formal parameter types and no aliasing information. No global program analysis is necessary.</region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="51" page="6" column="1">6 DISCUSSION, RELATED WORK</h1>
        <region class="DoCO:TextChunk" id="79" page="6" column="1">The idea of integrating process types into dynamic languages is new and at a first glance unexpected because such types were developed to move dynamic aspects like synchronization to the static language level whenever possible ( <xref ref-type="bibr" rid="R21" id="52" class="deo:Reference">Puntigam, 1995</xref>; Puntigam, 1997; Puntigam, 2000). In some sense the integration of more advanced static concepts into dynamic languages is a consistent further development allowing us to use the appropriate (static or dynamic) concept for each task. Such integration helps us to deepen our understanding of related concepts. We usually regard synchronization of concurrent threads as a purely dynamic concept: If there is a dependence between two control flows, then one of the corresponding threads must wait until the other thread has caught up to meet the synchronization point. Since threads usually run asynchronously and at statically unpredictable speed, it is only possible to decide at run time whether a thread must wait at a synchronization point. However, these considerations are valid only at a very low level (close to the hardware) point of view. From the programmers’ higher level point of view it is quite often not clear whether there exist dependences between threads or not. Using explicit synchronization as with monitors, semaphores, rendezvous communication, etc. programmers must add much more synchronization points than are actually necessary. There are optimization techniques that can statically eliminate up to about 90% (about 60% in average) of all locks from Java programs and thereby considerably improve program performance (von Praun and Gross, 2003). Probably even more synchronization points are actually not necessary. Current programming languages allow program-<marker type="column" number="2"/><marker type="block"/> mers to write programs with races although there are many proposals to ensure race-free programs (Bacon et al., 2000; <xref ref-type="bibr" rid="R5" id="54" class="deo:Reference">Boyapati and Rinard, 2001</xref>; Brinch- <xref ref-type="bibr" rid="R6" id="55" class="deo:Reference">Hansen, 1975</xref>; <xref ref-type="bibr" rid="R11" id="56" class="deo:Reference">Flanagan and Abadi, 1999</xref>). Applica- tions of such techniques may lead to further increase of unnecessary synchronization because no approach can accurately decide between necessary and unnecessary locks. Nonetheless, these techniques are very useful because races are an important practical prob- lem in concurrent programming. Process types were developed as abstractions over expressions in process calculi (<xref ref-type="bibr" rid="R21" id="57" class="deo:Reference">Puntigam, 1995</xref>). These abstractions specify acceptable messages of active objects and allow the acceptability to change over time (thereby specifying synchronization constraints). Static type checking ensures that only acceptable messages can be sent and enforces all synchronization constraints to be satisfied. In this sense type checking in process types has a similar purpose as ensuring race-free programs. However, process types allow us to specify arbitrary constraints on message acceptability, not just synchronization necessary to avoid races. In fact, the underlying calculi do not support shared data that could suffer from races. There is a clear tendency toward more and more complex interface specifications going far beyond simple signatures of available routines (<xref ref-type="bibr" rid="R2" id="58" class="deo:Reference">Arbab, 2005</xref>; de <xref ref-type="bibr" rid="R10" id="59" class="deo:Reference">Alfaro and Henzinger, 2001</xref>; Heuzeroth and Reussner, 1999; <xref ref-type="bibr" rid="R13" id="60" class="deo:Reference">Jacobsen and Krämer, 1998</xref>; <xref ref-type="bibr" rid="R16" id="61" class="deo:Reference">Lee and Xiong, 2004</xref>; <xref ref-type="bibr" rid="R23" id="62" class="deo:Reference">Mezini and Ostermann, 2002</xref>; Nierstrasz, 1993; <xref ref-type="bibr" rid="R28" id="63" class="deo:Reference">Plasil and Visnovsky, 2002</xref>; Yellin and Strom, 1997). We consider such interfaces to be partial specifications of object behavior (<xref ref-type="bibr" rid="R17" id="64" class="deo:Reference">Liskov and Wing, 1993</xref>). They are especially valuable to specify the behavior of software components as far as needed for component composition. Process types are useful as partial behavior specifications (Puntigam, 2003; Südholt, 2005). We regard behavior specifications as the major reason for using process types. Pre- and postconditions in with -clauses allow us to specify a kind of contracts between components (<xref ref-type="bibr" rid="R20" id="65" class="deo:Reference">Meyer, 1997</xref>; <xref ref-type="bibr" rid="R22" id="66" class="deo:Reference">Meyer, 2003</xref>). Such contracts clearly specify responsibilities of software and help us to move responsibilities from one component to another. For example, we move the responsibility of proper synchronization from the server to the client if we use with -clauses instead of when -clauses. Behavioral types and synchronization of concurrent threads are related topics: Specifications of object behavior cannot ignore necessary synchronization if we expect components composed according to their behavioral types to work together in concurrent environments, and constraints on message acceptability specify a kind of synchronization. The present work allows programmers to decide between synchronization globally visible through the interface ( with clauses) and local synchronization regarded as an im-<marker type="page" number="7"/><marker type="column" number="1"/><marker type="block"/> plementation detail ( when -clauses). While with clauses just ensure that clients coordinate themselves (for example, through the control flow allowing m2() to be invoked only after m1() ) when -clauses ensure proper synchronization using more conventional techniques. Locking does not get visible in interfaces, just synchronization requirements are visible. There are good reasons for using locking only for local synchronization: Uncoordinated locking easily leads to deadlocks and other undesirable behavior, and it is much easier to coordinate locking within a single unit. The monitor concept supports just local locking for similar reasons. Furthermore, it is very difficult to deal with globally visible locking at the presence of subtyping and inheritance (Matsuoka and <xref ref-type="bibr" rid="R18" id="68" class="deo:Reference">Yonezawa, 1993</xref>). Process types express just synchronization conditions in interfaces, they do not provide for locking. Another approach directly expresses locking conditions in interfaces (<xref ref-type="bibr" rid="R7" id="69" class="deo:Reference">Caromel, 1993</xref>; <xref ref-type="bibr" rid="R19" id="70" class="deo:Reference">Meyer, 1993</xref>). As experience shows, that approach easily leads to undesirable locking where it would be more appropriate to raise exceptions. There are several approaches similar to process types. Nierstrasz (<xref ref-type="bibr" rid="R27" id="71" class="deo:Reference">Nierstrasz, 1993</xref>) and Nielson and Nielson (<xref ref-type="bibr" rid="R26" id="72" class="deo:Reference">Nielson and Nielson, 1993</xref>) define behavioral types where subtypes show the same deadlock behavior as supertypes, but message acceptability is not ensured. Many further approaches consider dynamic changes of message acceptability, but do not guarantee message acceptability in all cases (Caromel, 1993; <xref ref-type="bibr" rid="R9" id="73" class="deo:Reference">Colaco et al., 1997</xref>; <xref ref-type="bibr" rid="R15" id="74" class="deo:Reference">Kobayashi and Yonezawa, 1994</xref>; <xref ref-type="bibr" rid="R19" id="75" class="deo:Reference">Meyer, 1993</xref>; Ravara and Vasconcelos, 1997). Well known in the area of typed π -calculi (<xref ref-type="bibr" rid="R24" id="76" class="deo:Reference">Milner et al., 1992</xref>) is the work of Kobayashi, Pierce and Turner on linearity (<xref ref-type="bibr" rid="R14" id="77" class="deo:Reference">Kobayashi et al., 1999</xref>) which ensures all sent messages to be acceptable. Work of Najm and Nimour (<xref ref-type="bibr" rid="R25" id="78" class="deo:Reference">Najm and Nimour, 1997</xref>) is very similar to process types except that in their approach at each time only one user can interact with an object through an interface (no type splitting). These approaches specify constraints on the acceptability of messages in a rather direct way and do not make use of a token concept. The use of tokens in behavior specifications gives us high expressiveness and flexibility, allows us to express synchronization in a way similar to well-known concepts like monitors and semaphores, and is easily understandable.</region>
      </section>
      <section class="deo:Conclusion">
        <h1 class="DoCO:SectionTitle" id="80" page="7" column="1">7 CONCLUSION</h1>
        <region class="DoCO:TextChunk" id="84" page="7" column="1">Behavioral types like process types gain more and more importance especially together with component composition. By partially specifying object behavior these types express synchronization in the form of software contracts clearly determining who is respon- <marker type="column" number="2"/><marker type="block"/> sible for proper synchronization. Process types use simple token sets as abstractions over object states. In this paper we explored how to add process types to rather conventional object-oriented programming languages. As a showcase we developed the languages TL1 to TL3. Static type checking in TL1 ensures that all conditions in with -clauses are satisfied, this is, all required tokens are available. We can syn- chronize concurrent threads just by waiting for messages. To overcome the restriction, TL2 adds a new dynamic concept of synchronization based on token sets. Neither TL1 nor TL2 can deal with static token sets associated with instance variables because of possible simultaneous accesses by concurrent threads. In TL3 we dispense with static types and apply one of two methods to dynamically ensure the availability of required tokens – a flexible method and one with bet- ter error messages and partial support of static type checking. All variables in TL3 have only dynamic types that can implicitly carry tokens. In the three languages we can ensure race-free programs by checking each class separately, without any need of global aliasing information. Our approach uses token sets for several related purposes – synchronization of concurrent threads and statically and dynamically checked abstract behavior specifications. It is a major achievement to integrate these concepts because of complicated interrelations. The integration is valuable because it gives software developers much freedom and at the same time clear contracts and type safety. Much work on this topic remains to be done. For example, currently our algorithm can issue warnings about potential races even in purely sequential program parts. Many other approaches to ensure race- free programs put much effort into detecting sequential program parts. By integrating such approaches into our algorithm we expect to considerably improve the accuracy. Most approaches to remove unnecessary locking from concurrent programs also work on sequential program parts (<xref ref-type="bibr" rid="R8" id="82" class="deo:Reference">Choi et al., 1999</xref>; von Praun and Gross, 2003; Vivien and <xref ref-type="bibr" rid="R5" id="83" class="deo:Reference">Rinard, 2001</xref>). We expect a combination of the techniques to improve run time efficiency.</region>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="85" page="7" column="2">REFERENCES</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="86" page="7" column="2">Agha, G., Mason, I. A., Smith, S., and Talcott, C. (1992). Towards a theory of actor computation. In Proceedings CONCUR’92 , number 630 in Lecture Notes in Computer Science, pages 565–579. Springer-Verlag.</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="87" confidence="possible" page="7" column="2">Arbab, F. (2005). Abstract behavior types: A foundation model for components and their composition. Science of Computer Programming , 55(1–3):3–52.</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="88" confidence="possible" page="7" column="2">Bacon, D. F., Strom, R. E., and Tarafdar, A. (2000). Guava:</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="89" page="8" column="1">A dialect of Java without data races. In OOPSLA 2000 .</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="90" confidence="possible" page="8" column="1">Boyapati, C. and Rinard, M. (2001). A parameterized type system for race-free Java programs. In OOPSLA 2001 . ACM.</ref>
          <ref rid="R6" class="deo:BibliographicReference" id="91" confidence="possible" page="8" column="1">Brinch-Hansen, P. (1975). The programming language Concurrent Pascal. IEEE Transactions on Software Engineering , 1(2):199–207.</ref>
          <ref rid="R7" class="deo:BibliographicReference" id="92" confidence="possible" page="8" column="1">Caromel, D. (1993). Toward a method of object-oriented concurrent programming. Communications of the ACM , 36(9):90–101.</ref>
          <ref rid="R8" class="deo:BibliographicReference" id="93" confidence="possible" page="8" column="1">Choi, J.-D., Gupta, M., Serrano, M., Sreedhar, V. C., and Midkiff, S. (1999). Escape analysis for Java. In OOP- SLA’99 , Denver, Colorado.</ref>
          <ref rid="R9" class="deo:BibliographicReference" id="94" confidence="possible" page="8" column="1">Colaco, J.-L., Pantel, M., and Salle, P. (1997). A set- constraint-based analysis of actors. In Proceedings FMOODS’97 , Canterbury, United Kingdom. Chapman &amp; Hall.</ref>
          <ref rid="R10" class="deo:BibliographicReference" id="95" confidence="possible" page="8" column="1">de Alfaro, L. and Henzinger, T. A. (2001). Interface au- tomata. In Proceedings of the Ninth Annual Sympo- sium on Foundations of Software Engineering (FSE) , pages 109–120. ACM Press.</ref>
          <ref rid="R11" class="deo:BibliographicReference" id="96" confidence="possible" page="8" column="1">Flanagan, F. and Abadi, M. (1999). Types for safe locking. In Proceedings ESOP’99 , Amsterdam, The Nether- lands.</ref>
          <ref rid="R12" class="deo:BibliographicReference" id="97" confidence="possible" page="8" column="1">Heuzeroth, D. and Reussner, R. (1999). Meta-protocol [1] and Agha type system for the dynamic coupling of binary [2] com- Arbab ponents. In OORASE’99: OOSPLA’99 Workshop [3] Bacon on Reflection and Software Engineering , Bicocca, [4] Italy. Boyapati</ref>
          <ref rid="R13" class="deo:BibliographicReference" id="98" confidence="possible" page="8" column="1">Jacobsen, H.-A. and Krämer, B. J. (1998). [5] A design Meyer pattern tion adaptors based from approach annotated to generating IDL. In IEEE synchroniza- [6] Interna- Brinch-Hansen tional Conference on Automated Software [7] Engineer- Mezini ing (ASE’98) , pages 63–72, Honolulu, Hawaii, [8] USA.</ref>
          <ref rid="R14" class="deo:BibliographicReference" id="99" confidence="possible" page="8" column="1">Kobayashi, N., Pierce, B., and Turner, D. (1999). [9] Linearity Milner and the pi-calculus. ACM Transactions on [10] Program- Choi ming Languages and Systems , 21(5):914–947. [11] Najm</ref>
          <ref rid="R15" class="deo:BibliographicReference" id="100" confidence="possible" page="8" column="1">Kobayashi, N. and Yonezawa, A. (1994). Type-theoretic [12] foundations for concurrent object-oriented [13] program- ceedings ming. ACM OOPSLA’94. SIGPLAN Notices , 29(10):31–45. [14] [15] Pro- De</ref>
          <ref rid="R16" class="deo:BibliographicReference" id="101" confidence="possible" page="8" column="1">Lee, E. and A. its and application Xiong, Y. in (2004). Ptolemy A behavioral II. Formal type Aspects [16] system of Computing , 16(3):210–237. [17]</ref>
          <ref rid="R17" class="deo:BibliographicReference" id="102" confidence="possible" page="8" column="1">Liskov, B. and Wing, J. M. (1993). Specifications [18] and their use in defining subtypes. ACM SIGPLAN [19] Notices , 28(10):16–28. Proceedings OOPSLA’93. [20]</ref>
          <ref rid="R18" class="deo:BibliographicReference" id="103" confidence="possible" page="8" column="1">Matsuoka, S. and Yonezawa, A. (1993). Analysis [21] of inheritance anomaly in object-oriented concurrent [22] programming languages. In Agha, G., editor, [23] Research Directions in Concurrent Object-Oriented [24] Programming . The MIT Press. [25]</ref>
          <ref rid="R19" class="deo:BibliographicReference" id="104" confidence="possible" page="8" column="1">Meyer, 36(9):56–80. oriented B. (1993). programming. Systematic Communications concurrent of [27] [26] the object- ACM Lee ,</ref>
          <ref rid="R20" class="deo:BibliographicReference" id="105" confidence="possible" page="8" column="1">Meyer, B. (1997). Object-Oriented Software Construction [28] . Prentice Hall, second edition edition. [29] Südholt</ref>
          <ref rid="R21" class="deo:BibliographicReference" id="106" confidence="possible" page="8" column="1">Puntigam, F. (1995). Flexible types for a concurrent model. Caromel Ravara Puntigam Kobayashi Flanagan Heuzeroth Jacobsen Puntigam Plasil Kobayashi Liskov Nielson Nierstrasz Puntigam Puntigam Colaco Alfaro 1992 2004 Yellin, von Vivien, Ravara, Südholt, Puntigam, Puntigam, Puntigam, 1997 2000 1999 2003 2005 1992 2002 1997 2002 1993 1993 1997 Praun, 2005 1993 2001 on 333. cations ysis PLDI and 2005) ings Computer regular many. types Osnabrück, Jyväskylä gramming interfaces. Component-Oriented Lecture Programming in S., In 1999 2000 1995 1997 2003 1998 D. F. types 2001 1999 1999 1994 Proceedings Programming A. editors, M. escape 1993 for and Euro-Par’97 F. F. M. , for C. F. ’03 and Edinburgh, (2003). (2005). (1997). and 1975 for Notes multi-threaded protocols. and (2000). and a Rinard, , , Science, pages calculus Finland. with Vasconcelos, analysis. Proceedings active Germany. component Gross, In Strom, and in State Coordination of Process 115–128. Eighth A Languages M. , Computer objects. Scotland. Models Concurrent the number pages of Springer-Verlag. model T. In information (2001). R. In Programming concurrent R. Puntigam Puntigam Puntigam Plasil Nierstrasz Milner Meyer Bacon Mezini Nielson Meyer Arbab Brinch-Hansen Boyapati Agha Najm Kobayashi Heuzeroth Caromel Flanagan Jacobsen Kobayashi Lee Colaco Choi De Matsuoka Meyer Liskov Workshop PLDI object-oriented adaptors. ECOOP’97 E. Types International Software V. (2003). 554–561. In of ACM of 1300 (1997). Alfaro Science, T. and Aksit, Concurrency 2004 Incrementalized ’01 requirements components . 1997 1992 1999 Object-Oriented (1997). 2000 1997 2005 1993 2003 Press. . Systems in Der objects. in on Static ACM. 2002 1992 2002 1997 1993 ACM Composition M. , Springer-Verlag. statically , 1993 1993 Lecture Protocol Darmstadt, Object-Oriented number pages 2000 1997 1995 2001 1998 1999 [26] 1993 Andere and [1] [11] 2001 1999 [10] 1999 1994 Workshop programs. conflict Transactions , 1993 [2] [3] [33] [5] [35] Behavioural In , 19(2):292– [17] [9] [7] [12] [28] Matsuoka, Torino. with expressed 367–388, Proceed- [13] [8] Notes checked 1241 specifi- [23] [21] [19] 1975 [4] [20] [30] [16] Verlag, pointer [14] [24] [18] [22] anal- non- Ger- Pro- [15] (SC on In in in</ref>
          <ref rid="R22" class="deo:BibliographicReference" id="107" page="8" column="2">Meyer, B. (2003). The grand challenge of trusted components. In ICSE-25 (International Conference on Software Engineering) , Portland, Oregon. IEEE Computer Press.</ref>
          <ref rid="R23" class="deo:BibliographicReference" id="108" confidence="possible" page="8" column="2">Mezini, M. and Ostermann, K. (2002). Integrating indepen- dent components with on-demand remodularization. In OOPSLA 2002 Conference Proceedings , pages 52– 67, Seattle, Washington. ACM.</ref>
          <ref rid="R24" class="deo:BibliographicReference" id="109" confidence="possible" page="8" column="2">Milner, R., Parrow, J., and Walker, D. (1992). A calculus of mobile processes (parts I and II). Information and Computation , 100:1–77.</ref>
          <ref rid="R25" class="deo:BibliographicReference" id="110" confidence="possible" page="8" column="2">Najm, E. and Nimour, A. (1997). A calculus of object bindings. In Proceedings FMOODS’97 , Canterbury, United Kingdom. Chapman &amp; Hall.</ref>
          <ref rid="R26" class="deo:BibliographicReference" id="111" confidence="possible" page="8" column="2">Nielson, F. and Nielson, H. R. (1993). From CML to process algebras. In Proceedings CONCUR’93 , number 715 in Lecture Notes in Computer Science, pages 493–508. Springer-Verlag.</ref>
          <ref rid="R27" class="deo:BibliographicReference" id="112" confidence="possible" page="8" column="2">Nierstrasz, O. (1993). Regular types for active objects. ACM SIGPLAN Notices , 28(10):1–15. Proceedings OOPSLA’93.</ref>
          <ref rid="R28" class="deo:BibliographicReference" id="113" confidence="possible" page="8" column="2">Plasil, F. and Visnovsky, S. (2002). Behavioral protocols for software components. IEEE Transactions on Software Engineering , 28(11):1056–1076.</ref>
        </ref-list>
        <outsider class="DoCO:TextBox" type="sidenote" id="114" page="8" column="2">[6]</outsider>
        <outsider class="DoCO:TextBox" type="footer" id="118" page="8" column="2">[30] <xref ref-type="bibr" rid="R18" id="115" class="deo:Reference">Matsuoka 1993</xref> [31] Vivien 2001 [32] Von Praun 2003 [33] <xref ref-type="bibr" rid="R19" id="116" class="deo:Reference">Meyer 1993</xref> [34] Yellin 1997 [35] <xref ref-type="bibr" rid="R20" id="117" class="deo:Reference">Meyer 1997</xref></outsider>
        <outsider class="DoCO:TextBox" type="footer" id="119" page="8" column="2">Puntigam 2003 [25] Ravara 1997 [27] Südholt 2005 [29] Vivien 2001 [31] Von Praun 2003 [32] Yellin 1997 [34]</outsider>
      </section>
    </body>
  </article>
</pdfx>
