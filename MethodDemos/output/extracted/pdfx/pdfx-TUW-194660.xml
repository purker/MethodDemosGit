<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>b8594cc8ef943588d1b1efe8f2a73a436023540429c3a59b6817fa8fc520a275</job>
    <base_name>l3i</base_name>
    <doi>http://dx.doi.org/10.1142/9789812812421_0004</doi>
    <warning>Name identification was not possible. </warning>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <title-group>
        <article-title class="DoCO:Title" id="1">Extensions for Interaction Nets</article-title>
      </title-group>
      <region class="unknown" id="2">Eugen Jiresch and Bernhard Gramlich (Faculty Mentor) Institute of Computer Languages Vienna University of Technology Vienna, Austria Email: { jiresch,gramlich } @logic.at</region>
      <abstract class="DoCO:Abstract" id="3">— Interaction Nets are a novel model of computation based on graph rewriting. Their main properties are parallel evaluation and sharing of computation, which leads to ef- ficient programs. However, Interaction Nets lack several features that allow for their convenient use as a programming language. In this paper, we describe the implementation of an extension for pattern matching of interaction rules. Furthermore, we show the correctness of the implementation and discuss its complexity.</abstract>
      <region class="DoCO:TextChunk" id="4" confidence="possible">I. I NTRODUCTION A. O VERVIEW</region>
    </front>
    <body class="DoCO:BodyMatter">
      <region class="DoCO:TextChunk" id="5" page="1" column="1">Models of computation are the basis for many programming languages. They allow for reasoning on formal properties of programs such as their correctness and ter- mination (i.e., whether a program eventually halts). An example is the λ -calculus, which is the basis for func- tional programming languages such as Haskell . Interaction Nets are a relatively new model of computation based on graph rewriting. They enjoy several useful properties that give them great potential for a fu- ture programming language. In this paper, we introduce a method for extended pattern matching which allows for the formulation of more powerful interaction rules. We describe our recent contribution, an implementation of the extended pattern matching, and discuss its properties. This paper is organised as follows: The next subsec- tion gives a short introduction to Interaction Nets . In Section II., we introduce extended pattern matching and outline its implementation. Finally, we present a conclu- sion and give an outlook on further research.</region>
      <region class="DoCO:TextChunk" id="6" confidence="possible" page="1" column="1">B. I NTERACTION N ETS</region>
      <region class="DoCO:TextChunk" id="19" page="1" column="1">Interaction Nets were first introduced in [ <xref ref-type="bibr" rid="R1" id="7" class="deo:Reference">1</xref>]. A net is a graph consisting of agents (nodes) and ports (edges). x 1 x n d ···   α c<marker type="block"/> Computation is modeled by rewriting the graph, which is based on interaction rules . These rules apply to two nodes which are connected by their principal ports (de- noted by the arrow). For example, the following two<marker type="column" number="2"/><marker type="block"/> rules model the addition of natural numbers (encoded by 0 and a successor function S ):<marker type="block"/> This simple system allows for parallel evaluation of programs: If more than one interaction rule is applicable at the same time, they can be applied in parallel with- out interfering with each other. In addition, nets share computation: If an expression appears multiple times in a program, it is evaluated only once. II. N ESTED P ATTERN M ATCHING AND ITS I MPLEMENTATION The simplicity of interaction rules brings a disadvantage: Only the two nodes that are connected via their principal ports are relevant to the rule. This makes it hard to express functions that depend on more than two non- variable symbols, or in other words, have a more complicated pattern. Consider a function that finds and returns the last element of a list: l a s t Cons ( x , N i l ) = x l a s t Cons ( x , x s ) = l a s t x s The first rule pattern includes three function symbols: last , Cons and N il . Since interaction rules are restricted to two function symbols per rule pattern (the names of the agents), one has to introduce an auxiliary rule to model this function: l a s t Cons ( x , x s ) = aux x x s aux x N i l = x aux x Cons ( y , y s ) = l a s t Cons ( y , y s ) To counter this problem, Interaction Nets with nested patterns were introduced [<xref ref-type="bibr" rid="R2" id="14" class="deo:Reference">2</xref>]. Nested rules allow for pattern matching of more complicated functions. The bene- ficial properties of Interaction Nets are preserved if the nested rules are of a specific form (i.e., well-formed ). Moreover, it is possible to transform nested rules into ordinary ones by introducing auxiliary rules, much like in the example above.<marker type="page" number="2"/><marker type="column" number="1"/><marker type="block"/> The first author contributed to this research by implementing nested pattern matching in the Interaction Nets based prototype programming language inets [<xref ref-type="bibr" rid="R3" id="17" class="deo:Reference">3</xref>]. The corresponding theoretical description of this work was presented at the workshop RULE’09 [<xref ref-type="bibr" rid="R4" id="18" class="deo:Reference">4</xref>]. In the remain- der of this section, we outline the main ingredients of the implementation. The implementation consists of two parts:</region>
      <region class="unknown" id="11" page="1" column="2">+     © d = ⇒ 0</region>
      <region class="unknown" id="12" page="1" column="2">T + S     © d = ⇒ S + ©</region>
      <outsider class="DoCO:TextBox" type="sidenote" id="13" page="1" column="2">d</outsider>
      <outsider class="DoCO:TextBox" type="page_nr" id="16" page="1" column="2">295</outsider>
      <region class="DoCO:TextChunk" id="20" confidence="possible" page="2" column="1">1. Verification of the well-formedness of interaction rules 2. Translation of nested rules into ordinary rules</region>
      <region class="DoCO:TextChunk" id="25" page="2" column="1">Verification of well-formedness The well-formedness property of a set of interaction rules ensures that there is no overlap between rules: A given pair of agents (with nested arguments) must not match more than one rule. Otherwise, the rules cannot be applied in a determinis- tic fashion which leads to inconsistent results. The algorithm in inets tries to falsify this condition of the rule set: It searches (exhaustively) for two nested patterns that can match the same net. The condition is falsified if and only if the set of rules is not well-formed. A formal proof can be found in [ <xref ref-type="bibr" rid="R4" id="21" class="deo:Reference">4</xref>, <xref ref-type="bibr" rid="R5" id="22" class="deo:Reference">5</xref>].<marker type="block"/> Rule translation We now give an overview of the ac- tual translation of nested rules. This is done as follows: The inets compiler reads source code and builds an ab- stract syntax tree (AST) which is further compiled into byte code and later C source code. Our translation function rewrites ASTs that represent nested rules into ASTs that represent ordinary interaction rules. The back end of the compiler remains unaffected by the translation. Over- all, our translation function is similar to the compilation schemes defined in the original paper [<xref ref-type="bibr" rid="R2" id="24" class="deo:Reference">2</xref>]. We summarise the translation algorithm in the following steps:</region>
      <region class="DoCO:TextChunk" id="26" confidence="possible" page="2" column="1">1. A rule is found in the AST. If the rule has a nested pattern, its well-formedness is verified. 2. If the rule is well-formed, it is translated: The first nested argument is removed from the rule and an auxiliary rule is generated. This rule is appended to the AST. 3. The remaining nested agents are not (yet) translated. They are resolved by translating the auxiliary rule. 4. The AST is traversed until the next (unprocessed) rule is found.</region>
      <region class="DoCO:TextChunk" id="29" page="2" column="1">This algorithm allows for an arbitrary number of nested patterns (i.e., the number of nested agents in a nested rule) and an arbitrary pattern depth. <marker type="column" number="2"/><marker type="block"/> Properties of the translation We show that the algorithm is terminating: The translation function either fails (due to a non well-formed rule) or yields a set of ordinary interaction rules. The idea behind the formal proof is to show that the number of rules and nested patterns decreases with each call of the translation function. The time and space complexity of the algorithm can be described as follows: The time complexity of the translation is O ( n 2 ) where n is the sum of the number of rules and nested patterns in the input rule set. This is due to (one part of) the well-formedness check that compares each rule with every other rule ( n ( n − 1) checks are per- 2 formed). Space complexity is linear with the number of input rules. For a more detailed complexity discussion, the reader is referred to [<xref ref-type="bibr" rid="R5" id="28" class="deo:Reference">5</xref>]. III. C ONCLUSION AND O UTLOOK In this paper, we have given a short introduction to Interaction Nets and their extension through nested patterns. We have contributed to this field of research by implementing a translation algorithm for nested patterns in the Interaction Nets based programming language inets . This algorithm includes verification of the well-formedness of rules. Moreover, the translation han- dles programming language features that are not part of the original definition of the translation. Some impor- tant examples are data values of agents (integers, floats, strings,. . . ), side effects (declaration and manipulation of variables, I/O) and conditions. Nested pattern matching can serve as a basis for further language extensions for Interaction Nets . These extensions are pursued in the context of the PhD project of the first author which is funded by the Austrian Academy of Sciences ( OAW)  ̈ and the Vienna PhD School of Infor- matics.</region>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="30" confidence="possible" page="2" column="2">R EFERENCES</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="31" confidence="possible" page="2" column="2">[1] Y. Lafont. Interaction nets. In Proceedings of the 17th ACM symposium on Principles of programming languages (POPL) , pages 95–108, 1990.</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="32" confidence="possible" page="2" column="2">[2] A. Hassan and S. Sato. Interaction nets with nested pattern matching. Electr. Notes Theor. Comput. Sci. , 203(1):79–92, 2008.</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="34" confidence="possible" page="2" column="2">[3] The inets project. <ext-link ext-link-type="uri" href="http://www.interaction-nets.org/." id="33">http://www.interaction-nets.org/.</ext-link></ref>
          <ref rid="R4" class="deo:BibliographicReference" id="35" confidence="possible" page="2" column="2">[4] A. Hassan, E. Jiresch, and S. Sato. Interaction nets with nested patterns: An implementation. Prelim. Proceedings: 10th Int. Workshop on Rule-Based Pro- gramming (RULE’09), pp. 14-25, Brasılia, Brazil, June 2009 .</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="36" confidence="possible" page="2" column="2">[5] A. Hassan, E. Jiresch, and S. Sato. Interaction nets with nested patterns: An implementation. Full ver- sion of [4]. In Proceedings of RULE’09: Electr. Pro- ceed. in Theor. Comp. Sci. (EPTCS) , 2010, to appear.</ref>
        </ref-list>
        <outsider class="DoCO:TextBox" type="page_nr" id="37" page="2" column="2">296</outsider>
      </section>
    </body>
  </article>
</pdfx>
