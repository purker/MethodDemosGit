<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>5d6e0bec05e8ebad0ea6f5386a1a59429486a98aa0bea1e5021013bc0f54f3e0</job>
    <base_name>l4m</base_name>
    <doi>http://dx.doi.org/10.24963/ijcai.2017/128</doi>
    <warning>Name identification was not possible. </warning>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <title-group>
        <article-title class="DoCO:Title" id="1">Chase Termination for Guarded Existential Rules</article-title>
      </title-group>
      <region class="DoCO:TextChunk" id="5" confidence="possible">Marco Calautti 1 , Georg Gottlob 2 , and Andreas Pieris 3 1 DIMES, University of Calabria, Italy <email id="2">calautti@dimes.unical.it</email> 2 Department of Computer Science, University of Oxford, UK <email id="3">georg.gottlob@cs.ox.ac.uk</email> 3 Institute of Information Systems, Vienna University of Technology, Austria <email id="4">pieris@dbai.tuwien.ac.at</email></region>
      <abstract class="DoCO:Abstract" id="6">The chase procedure is considered as one of the most fundamental algorithmic tools in database theory. It has been successfully applied to different database problems such as data exchange, and query answering and containment under constraints, to name a few. One of the central problems regarding the chase procedure is all-instance termination, that is, given a set of tuple-generating dependencies (TGDs) (a.k.a. existential rules), decide whether the chase under that set terminates, for every input database. It is well-known that this problem is undecidable, no matter which version of the chase we consider. The crucial question that comes up is whether existing restricted classes of TGDs, proposed in different contexts such as ontological reasoning, make the above problem decidable. In this work, we focus our attention on the oblivious and the semi-oblivious versions of the chase procedure, and we give a positive answer for classes of TGDs that are based on the notion of guardedness.</abstract>
    </front>
    <body class="DoCO:BodyMatter">
      <section class="deo:Introduction">
        <h1 class="DoCO:SectionTitle" id="7" page="1" column="1">1 Introduction</h1>
      </section>
      <region class="DoCO:TextChunk" id="11" page="1" column="1">The chase procedure (or simply chase) is considered as one of the most fundamental algorithmic tools in databases — it accepts as input a database D and a set Σ of constraints and, if it terminates (which is not guaranteed), its result is a finite instance D Σ that enjoys two crucial properties: 1. D Σ is a model of D and Σ , i.e., it contains D and satisfies the constraints of Σ ; and 2. D Σ is universal , i.e., it can be homomorphically embedded into every other model of D and Σ . In other words, the chase is an algorithmic tool for computing universal models of D and Σ , which can be conceived as representatives of all the other models of D and Σ . This is precisely the reason for the ubiquity of the chase in database theory. Indeed, many key database problems can be solved by simply exhibiting a universal model. A central class of constraints, which can be treated by the chase procedure and is of special interest for this work, are the well-known tuple-generating dependencies (TGDs) (a.k.a. existential rules ) of the form ∀ X ∀ Y ( φ ( X , Y ) → ∃ Z ( ψ ( Y , Z ))) , where φ and ψ are conjunctions of atoms. Given a database D and a set Σ of TGDs, the chase adds new atoms to D (possibly involving nulls) until the final result satisfies Σ . <marker type="page" number="2"/><marker type="block"/> which asserts that each person has a father who is also a person. The database atom triggers the TGD, and the chase will add in D the atoms hasFather ( Bob , z 1 ) and person ( z 1 ) in order to satisfy it, where z 1 is a (labeled) null representing some un- known value. However, the new atom person ( z 1 ) triggers again the TGD, and the chase is forced to add the atoms hasFather ( z 1 , z 2 ) , person ( z 2 ) , where z 2 is a new null. The result of the chase is the instance ∪ { person ( Bob ) , hasFather ( Bob , z 1 ) } ∪ { person ( z i ) , hasFather ( z i , z i +1 ) } , i&gt; 0</region>
      <outsider class="DoCO:TextBox" type="header" id="9" page="2" column="1">Example 1. Consider the database D = { person ( Bob ) } , and the TGD</outsider>
      <region class="unknown" id="10" page="2" column="1">∀ X ( person ( X ) → ∃ Y hasFather ( X, Y ) ∧ person ( Y )) ,</region>
      <region class="DoCO:TextChunk" id="12" confidence="possible" page="2" column="1">where z 1 , z 2 , . . . are nulls.</region>
      <region class="DoCO:TextChunk" id="34" page="2" column="1">As shown by the above example, the chase procedure may run forever, even for ex- tremely simple databases and constraints. In the light of this fact, there has been a long line of research on identifying syntactic properties on TGDs such that, for every input database, the termination of the chase is guaranteed; see, e.g., [ <xref ref-type="bibr" rid="R4" id="13" class="deo:Reference">4</xref>, <xref ref-type="bibr" rid="R8" id="14" class="deo:Reference">8</xref>, <xref ref-type="bibr" rid="R10" id="15" class="deo:Reference">10</xref>, <xref ref-type="bibr" rid="R12" id="16" class="deo:Reference">12</xref>, <xref ref-type="bibr" rid="R13" id="17" class="deo:Reference">13</xref>] — this list is by no means exhaustive, and we refer to [<xref ref-type="bibr" rid="R9" id="18" class="deo:Reference">9</xref>] for a comprehensive survey. With so much effort spent on identifying sufficient conditions for the termination of the chase procedure, the question that comes up is whether a sufficient condition that is also nec- essary exists. In other words, given a set Σ of TGDs, is it possible to determine whether, for every database D , the chase on D and Σ terminates? This interesting question has been recently addressed in [<xref ref-type="bibr" rid="R6" id="19" class="deo:Reference">6</xref>], and unfortunately the answer is negative for all the versions of the chase that are usually used in database applications, namely the oblivious, semi-oblivious and restricted chase. In fact, the problem remains undecidable even if the database is known. This has been established in [<xref ref-type="bibr" rid="R4" id="20" class="deo:Reference">4</xref>] for the restricted chase, and it was observed in [<xref ref-type="bibr" rid="R12" id="21" class="deo:Reference">12</xref>] that the same proof shows undecidability also for the oblivious and the semi-oblivious chase. Although the chase termination problem is undecidable in general, the proof given in [<xref ref-type="bibr" rid="R6" id="22" class="deo:Reference">6</xref>] does not show the undecidability of the problem for TGDs that enjoy some struc- tural conditions, which in turn guarantee favorable model-theoretic properties. Such a key condition is guardedness , a well-accepted paradigm that gives rise to robust rule- based languages that capture important databases constraints and lightweight description logics. A TGD is guarded if it has an atom in the left-hand side that contains (or guards) all the universally quantified variables [<xref ref-type="bibr" rid="R2" id="23" class="deo:Reference">2</xref>]. Guardedness guarantees the tree- likeness of the underlying models, and thus the decidability of central database problems. The question that comes up is whether guardedness has the same positive impact on chase termination. We focus on the (semi-)oblivious versions of the chase, and we show that the problem of deciding the termination of the chase for guarded TGDs is decidable, and we establish precise complexity results. Surprisingly, the present work is to our knowledge the first one that establishes positive results for the (semi-)oblivious chase termination problem. For more details, we refer the reader to [<xref ref-type="bibr" rid="R1" id="24" class="deo:Reference">1</xref>].<marker type="page" number="3"/><marker type="block"/> The TGD chase procedure (or simply chase ) takes as input an instance I and a set Σ of TGDs, and constructs a universal model of I and Σ . The chase works on I by applying the so-called trigger for a set of TGDs on I . The trigger for a set Σ of TGDs on an instance I is a pair ( σ, h ) , where σ = φ → ψ ∈ Σ and h is a homomorphism that maps φ to I . An application of ( σ, h ) to I returns J = I ∪ h ′ ( ψ ) , where h ′ ⊇ h maps each existentially quantified variable in ψ to a new null value. Such a trigger application is written I ⟨ σ, h ⟩ J . The choice of the type of the next trigger to be applied is crucial since it gives rise to different versions of the chase procedure. In this work, we focus our attention on the oblivious [<xref ref-type="bibr" rid="R2" id="27" class="deo:Reference">2</xref>] and semi-oblivious [<xref ref-type="bibr" rid="R7" id="28" class="deo:Reference">7</xref>, <xref ref-type="bibr" rid="R12" id="29" class="deo:Reference">12</xref>] chase. A finite sequence I 0 , I 1 , . . . , I n , where n 0 , is said to be a terminating oblivious chase sequence of I 0 w.r.t. a set Σ of TGDs if: (i) for each 0 i &lt; n , there exists a trigger ( σ, h ) for Σ on I i such that I i ⟨ σ, h ⟩ I i +1 ; (ii) for each 0 i &lt; j &lt; n , assuming that I i ⟨ σ i , h i ⟩ I i +1 and I j ⟨ σ j , h j ⟩ I j +1 , σ i = σ j = σ implies h i = h j , i.e., h i and h j are different homomorphisms; and (iii) there is no trigger ( σ, h ) for Σ on I n such that ( σ, h ) ∈ { ( σ i , h i ) } 0 i n − 1 . In this case, the result of the chase is the (finite) instance I n . An infinite sequence I 0 , I 1 , . . . of instances is said to be a non-terminating oblivious chase sequence of I 0 w.r.t. Σ if: (i) for each i 0 , there exists a trigger ( σ, h ) for Σ on I i such that I i ⟨ σ, h ⟩ I i +1 ; (ii) for each i, j &gt; 0 such that i = j , assuming that I i ⟨ σ i , h i ⟩ I i +1 and I j ⟨ σ j , h j ⟩ I j +1 , σ i = σ j = σ implies h i = h j ; and (iii) for each i 0 , and for every trigger ( σ, h ) for Σ on I i , there exists j i such that I j ⟨ σ, h ⟩ I j +1 ; this is known as the fairness condition, and guarantees that all the triggers eventually will be applied. The result of the chase is defined as the infinite instance ∪ i 0 I i . The semi-oblivious chase is a refined version of the oblivious chase, which avoids the application of some superfluous triggers. Roughly speaking, given a TGD σ of the form φ → ψ , for the semi-oblivious chase, two homomorphisms h and g that agree on the universally quantified variables of σ occurring in ψ are indistinguishable. Henceforth, we write o -chase and so -chase for oblivious and semi-oblivious chase, respectively. A ⋆ -chase sequence, where ⋆ ∈ { o , so } , may be infinite. Example 2. Let D = { p ( a, b ) } , and Σ = {∀ X ∀ Y ( p ( X, Y ) → ∃ Z ( p ( Y, Z ))) } . There exists only one ⋆ -chase sequence of D w.r.t. Σ , where ⋆ ∈ { o , so } , which is non-terminating, i.e., I 0 , I 1 , . . . with I 0 = { p ( a, b ) } I 1 = { p ( a, b ) , p ( b, z 1 ) } I i = I i − 1 ∪ { p ( z i − 1 , z i ) } , for i 2 , where z 1 , z 2 , . . . are nulls of N . For a set of TGDs, a key question is whether all or some ⋆ -chase sequences are terminating on all databases. Before formalizing the above decision problems, let us recall the following key classes of TGDs: CT ⋆ ∀ = { Σ | ∀ D, all ⋆ -chase sequences of D w.r.t. Σ are terminating } CT ∃ ⋆ = { Σ | ∀ D, there exists a terminating ⋆ -chase sequence of D w.r.t. Σ } . The decision problems tackled in this work are as follows: for q ∈ {∀ , ∃} :<marker type="page" number="4"/><marker type="block"/> We recall that CT o ∀ = CT o ∃ ⊂ CT so ∀ = CT ∃ so [<xref ref-type="bibr" rid="R7" id="33" class="deo:Reference">7</xref>]. This implies that the preceding decision problems coincide for the (semi-)oblivious chase. Henceforth, we refer to the ⋆ -chase termination problem, and we write CT ⋆ for CT ⋆ ∀ and CT ∃ ⋆ , where ⋆ ∈ { o , so } .</region>
      <outsider class="DoCO:TextBox" type="header" id="26" page="3" column="1">2 The Chase Termination Problem</outsider>
      <outsider class="DoCO:TextBox" type="header" id="31" page="4" column="1">q -S EQUENCE ⋆ -C HASE T ERMINATION : Instance: A set Σ of TGDs.</outsider>
      <region class="unknown" id="32" page="4" column="1">Question: Does Σ ∈ CT q ⋆ ?</region>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="35" page="4" column="1">3 The Complexity of Chase Termination</h1>
        <region class="DoCO:TextChunk" id="38" page="4" column="1">We focus on the class of guarded TGDs [<xref ref-type="bibr" rid="R2" id="36" class="deo:Reference">2</xref>], and two key subclasses of it, namely simple linear and linear TGDs [<xref ref-type="bibr" rid="R3" id="37" class="deo:Reference">3</xref>], and we investigate the complexity of the (semi-)oblivious chase termination problem. Recall that linear TGDs are TGDs with just one atom in the body, while simple linear TGDs forbid the repetition of variables in the body. Notice that, despite their simplicity, simple linear TGDs are powerful enough for capturing prominent database dependencies, and in particular inclusion dependencies, as well as key description logics such as DL-Lite. In the sequel, we denote by G the class of guarded TGDs, which is defined as the family of all possible sets of guarded TGDs. Analogously, we denote by SL and L the classes of simple linear and linear TGDs, respectively; clearly, SL ⊂ L ⊂ G . Let us first consider the less expressive classes.</region>
        <region class="DoCO:TextChunk" id="43" confidence="possible" page="4" column="1">By exploiting syntactic conditions that ensure the termination of each (semi-)oblivious chase sequence on all databases, we syntactically characterize the classes ( CT ⋆ ∩ SL ) and ( CT ⋆ ∩ L ) , where ⋆ ∈ { o , so } . We rely on weak-acyclicity [<xref ref-type="bibr" rid="R5" id="39" class="deo:Reference">5</xref>] and rich-acyclicity [<xref ref-type="bibr" rid="R11" id="40" class="deo:Reference">11</xref>]. Both weak- and rich-acyclicity are defined by posing an acyclicity condition on a graph, which encodes how terms are propagated among the positions of the underlying schema during the chase. In fact, weak-acyclicity forbids the existence of dangerous cycles (which involve the generation of new null values) in the dependency graph [<xref ref-type="bibr" rid="R5" id="41" class="deo:Reference">5</xref>], while rich-acyclicity pose the same condition on the so-called extended dependency graph [<xref ref-type="bibr" rid="R11" id="42" class="deo:Reference">11</xref>]. Let WA and RA be the classes of weakly- and richly-acyclic TGDs, respectively; notice that RA ⊂ WA . For simple linear TGDs we show that:</region>
        <region class="unknown" id="44" page="4" column="1">so ∩</region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="49" page="4" column="1">3.1 Linearity By exploiting syntactic conditions that ensure the termination of each (semi-)oblivious chase sequence on all databases, we syntactically characterize the classes ( CT ⋆ ∩ SL ) and ( CT ⋆ ∩ L ) , where ⋆ ∈ { o , so } . We rely on weak-acyclicity [<xref ref-type="bibr" rid="R5" id="45" class="deo:Reference">5</xref>] and rich-acyclicity [<xref ref-type="bibr" rid="R11" id="46" class="deo:Reference">11</xref>]. Both weak- and rich-acyclicity are defined by posing an acyclicity condition on a graph, which encodes how terms are propagated among the positions of the underlying schema during the chase. In fact, weak-acyclicity forbids the existence of dangerous cycles (which involve the generation of new null values) in the dependency graph [<xref ref-type="bibr" rid="R5" id="47" class="deo:Reference">5</xref>], while rich-acyclicity pose the same condition on the so-called extended dependency graph [<xref ref-type="bibr" rid="R11" id="48" class="deo:Reference">11</xref>]. Let WA and RA be the classes of weakly- and richly-acyclic TGDs, respectively; notice that RA ⊂ WA . For simple linear TGDs we show that: Theorem 1. ( CT o ∩ SL ) = ( RA ∩ SL ) and ( CT SL ) = ( WA ∩ SL ) . ∈ ∈</h2>
          <region class="unknown" id="50" page="4" column="1">o</region>
          <region class="DoCO:TextChunk" id="54" page="4" column="1">In simple words, the above theorem states that, given a set Σ SL : Σ CT iff Σ is richly-acyclic, and Σ ∈ CT so iff Σ is weakly-acyclic. This result is established by showing that a dangerous cycle in the extended dependency graph (resp., dependency graph) necessarily gives rise to a non-terminating o -chase (resp., so -chase) sequence. Let us now focus on (non-simple) linear TGDs. It is possible to show, by exhibiting a counterexample, that a dangerous cycle does not necessarily correspond to an infinite chase derivation. Thus, rich- and weak-acyclicity are not powerful enough for syntactically characterize the fragment of linear TGDs that guarantees the termination of the oblivious and semi-oblivious chase, respectively. Interestingly, it is possible to extend rich- and weak-acyclicity, focussing on linear TGDs, in such a way that the <marker type="page" number="5"/><marker type="block"/> The above syntactic characterizations, apart from being interesting in their own right, allow us to obtain optimal upper bounds for the ⋆ -chase termination problem for ( S ) L — we simply need to analyze the complexity of deciding whether a set of (simple) linear TGDs enjoys the above acyclicity-based conditions, which can be formulated as a reachability problem on a graph. In particular, we obtain the following results:</region>
          <outsider class="DoCO:TextBox" type="header" id="52" page="5" column="1">above key property holds. The obtained formalisms are dubbed critical-rich-acyclicity and critical-weak-acyclicity , and the corresponding classes are denoted as LCriticalRA</outsider>
          <region class="unknown" id="53" page="5" column="1">and LCriticalWA , respectively. We show that: Theorem 2. ( CT o ∩ L ) = LCriticalRA and ( CT so ∩ L ) = LCriticalWA .</region>
          <region class="DoCO:TextChunk" id="55" confidence="possible" page="5" column="1">Theorem 3. Consider a set Σ of TGDs. The problem of deciding whether Σ ∈ CT ⋆ , where ⋆ ∈ { o , so } , is 1. NL -complete, even for unary and binary predicates, if Σ ∈ SL ; and 2. PSPACE -complete, and NL -complete for predicates of bounded arity, if Σ ∈ L .</region>
          <region class="DoCO:TextChunk" id="56" page="5" column="1">For the hardness results, a generic technique, called the looping operator , is proposed, which allows us to obtain lower bounds for the chase termination problem in a uniform way. In fact, the goal of the looping operator is to provide a generic reduction from propositional atom entailment to the complement of chase termination.</region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="57" page="5" column="1">3.2 Guardedness</h2>
          <region class="DoCO:TextChunk" id="58" page="5" column="1">We proceed to investigate the (semi-)oblivious chase termination problem for guarded TGDs. Although there is no way (at least no obvious one) to syntactically characterize the classes ( CT ⋆ ∩ G ) , where ⋆ ∈ { o , so } , via rich- and weak-acyclicity, as we did for (simple) linear TGDs, it is possible to show that the problem of recognizing the above classes is decidable. For technical reasons, we focus on standard databases , that is, databases that have two constants, let say 0 and 1 , that are available via the unary predicates 0( · ) and 1( · ) , respectively. In particular, we show the following:</region>
          <region class="DoCO:TextChunk" id="59" confidence="possible" page="5" column="1">Theorem 4. Consider a set Σ ∈ G . The problem of deciding whether Σ ∈ CT ⋆ , where ⋆ ∈ { o , so } , focussing on standard databases, is 2 EXPTIME -complete, and EXPTIME complete for predicates of bounded arity.</region>
          <region class="DoCO:TextChunk" id="62" page="5" column="1">The upper bounds are obtained by exhibiting an alternating algorithm that runs in exponential space, in general, and in polynomial space in case of predicates of bounded arity. The lower bounds are obtained by reductions from the acceptance problem of alternating exponential (resp., polynomial) space clocked Turing machines, i.e., Turing machines equipped with a counter. These reductions are obtained by modifying sig- nificantly existing reductions for the problem of propositional atom entailment under guarded TGDs, and then exploiting the looping operator mentioned above. The fact that the database is standard, is crucial for establishing the above lower bounds; the upper bounds hold even for non-standard databases. <marker type="page" number="6"/><marker type="block"/> Our next step is to perform similar analysis focussing on the restricted version of the chase. We already have some preliminary positive results. In particular, if we focus on single-head linear TGDs, where each predicate appears in the head of at most one TGD, then we can syntactically characterize, via a careful extension of weak-acyclicity, the fragment that guarantees the termination of the restricted chase, and obtain a polynomial time upper bound. We are currently working towards the full settlement of the problem. Acknowledgements. M. Calautti was supported by the European Commission, European Social Fund and Region Calabria. G. Gottlob was supported by the EPSRC Programme Grant EP/M025268/ “VADA: Value Added Data Systems – Principles and Architecture”, and the Grant ERC-POC-2014 Nr. 641222 “ExtraLytics: Big Data for Real Estate”. A. Pieris was supported by the Austrian Science Fund (FWF), projects P25207-N23 and Y698, and Vienna Science and Technology Fund (WWTF), project ICT12-015.</region>
          <outsider class="DoCO:TextBox" type="header" id="61" page="6" column="1">4 Future Work</outsider>
        </section>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="63" page="6" column="1">References</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="64" page="6" column="1">1. Calautti, M., Gottlob, G., Pieris, A.: Chase termination for guarded existential rules. In: PODS (2015), to appear</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="65" page="6" column="1">2. Calı, A., Gottlob, G., Kifer, M.: Taming the infinite chase: Query answering under expressive relational constraints. J. Artif. Intell. Res. 48, 115–174 (2013)</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="66" page="6" column="1">3. Calı, A., Gottlob, G., Lukasiewicz, T.: A general Datalog-based framework for tractable query answering over ontologies. J. Web Sem. 14, 57–83 (2012)</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="67" page="6" column="1">4. Deutsch, A., Nash, A., Remmel, J.B.: The chase revisisted. In: PODS. pp. 149–158 (2008)</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="68" page="6" column="1">5. Fagin, R., Kolaitis, P.G., Miller, R.J., Popa, L.: Data exchange: Semantics and query answering. Theor. Comput. Sci. 336(1), 89–124 (2005)</ref>
          <ref rid="R6" class="deo:BibliographicReference" id="69" page="6" column="1">6. Gogacz, T., Marcinkowski, J.: All-instances termination of chase is undecidable. In: ICALP. pp. 293–304 (2014)</ref>
          <ref rid="R7" class="deo:BibliographicReference" id="71" page="6" column="1">7. Grahne, G., Onet, A.: Anatomy of the chase. CoRR abs/1303.6682 (2013), <ext-link ext-link-type="uri" href="http://arxiv.org/abs/1303.6682" id="70">http://arxiv.org/abs/1303.6682</ext-link></ref>
          <ref rid="R8" class="deo:BibliographicReference" id="72" page="6" column="1">8. Grau, B.C., Horrocks, I., Krötzsch, M., Kupke, C., Magka, D., Motik, B., Wang, Z.: Acyclic- ity conditions and their application to query answering in description logics. In: KR (2012)</ref>
          <ref rid="R9" class="deo:BibliographicReference" id="73" page="6" column="1">9. Greco, S., Molinaro, C., Spezzano, F.: Incomplete Data and Data Dependencies in Relational Databases. Morgan &amp; Claypool Publishers (2012)</ref>
          <ref rid="R10" class="deo:BibliographicReference" id="74" page="6" column="1">10. Greco, S., Spezzano, F., Trubitsyna, I.: Stratification criteria and rewriting techniques for checking chase termination. PVLDB 4(11), 1158–1168 (2011)</ref>
          <ref rid="R11" class="deo:BibliographicReference" id="75" page="6" column="1">11. Hernich, A., Schweikardt, N.: CWA-solutions for data exchange settings with target dependencies. In: PODS. pp. 113–122 (2007)</ref>
          <ref rid="R12" class="deo:BibliographicReference" id="76" page="6" column="1">12. Marnette, B.: Generalized schema-mappings: From termination to tractability. In: PODS. pp. 13–22 (2009)</ref>
          <ref rid="R13" class="deo:BibliographicReference" id="77" page="6" column="1">13. Meier, M., Schmidt, M., Lausen, G.: On chase termination beyond stratification. PVLDB 2(1), 970–981 (2009)</ref>
        </ref-list>
      </section>
    </body>
  </article>
</pdfx>
