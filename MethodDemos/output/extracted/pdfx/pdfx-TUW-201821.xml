<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>9d56743084ac02529dafdec0c9f0c72d1f9a1552dbe861c41f91de73dd5099e3</job>
    <base_name>l42</base_name>
    <doi>http://dx.doi.org/10.1007/978-3-642-41524-1_1</doi>
    <warning>Name identification was not possible. </warning>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <title-group>
        <article-title class="DoCO:Title" id="1">Advancing Multi-Context Systems by Inconsistency Management ⋆</article-title>
      </title-group>
      <region class="DoCO:TextChunk" id="3" confidence="possible">Antonius Weinzierl Institute of Information Systems Vienna University of Technology Favoritenstraße 9-11, A-1040 Vienna, Austria <email id="2">weinzierl@kr.tuwien.ac.at</email></region>
      <abstract class="DoCO:Abstract" id="4">Multi-Context Systems are an expressive formalism to model (possibly) non-monotonic information exchange between heterogeneous knowledge bases. Such information exchange, however, often comes with unforseen side-effects leading to violation of constraints, making the system inconsistent, and thus unusable. Although there are many approaches to assess and repair a single inconsistent knowledge base, the heterogeneous nature of Multi-Context Systems poses problems which have not yet been addressed in a satisfying way: How to identify and explain a inconsistency that spreads over multiple knowledge bases with different logical formalisms (e.g., logic programs and ontologies)? What are the causes of inconsistency if inference/information exchange is nonmonotonic (e.g., absent information as cause)? How to deal with inconsistency if access to knowledge bases is restricted (e.g., companies exchange information, but do not allow arbitrary modifications to their knowledge bases)? Many traditional approaches solely aim for a consistent system, but automatic removal of inconsistency is not always desireable. Therefore a human operator has to be supported in finding the erroneous parts contributing to the inconsistency. In my thesis those issues will be adressed mainly from a foundational perspective, while our research project also provides algorithms and prototype implementations.</abstract>
    </front>
    <body class="DoCO:BodyMatter">
      <section class="deo:Introduction">
        <h1 class="DoCO:SectionTitle" id="5" page="1" column="1">1 Introduction</h1>
      </section>
      <region class="DoCO:TextChunk" id="7" page="1" column="1">Multi-Context Systems (MCSs) are an expressive formalism for (possibly) nonmonotonic knowledge exchange between heterogeneous knowledge sources. These sources are called contexts and formalized as abstract ‘logics’. Information flow between contexts is specified using bridge rules which look and behave similar to rules in non-monotonic logic programming (cf. [<xref ref-type="bibr" rid="R15" id="6" class="deo:Reference">15</xref>]):</region>
      <disp-formula class="DoCO:FormulaBox" id="F1">
        <label class="DoCO:Label" id="8">1</label>
        <content class="DoCO:Formula" id="9" page="1" column="1">( k : s ) ← ( c 1 : p 1 ) , . . . , ( c j : p j ) , not ( c j +1 : p j +1 ) , . . . , not ( c m : p m ) .</content>
      </disp-formula>
      <region class="DoCO:TextChunk" id="10" confidence="possible" page="1" column="1">Such a rule states that information s is added to context k if for 1 ≤ i ≤ j knowledge p i is present in context c i and for j + 1 ≤ i ≤ m knowledge p i is ⋆ Supported by the Vienna Science and Technology Fund (WWTF), grant ICT08-020.</region>
      <region class="DoCO:TextChunk" id="11" page="2" column="1">absent in c i . Following common terminology p 1 , . . . , p m are called beliefs (each of their respective context) and s is the head formula of the bridge rule. Consider a hospital where a database with patient records, a medical ontology, and an expert system shall be working together giving decision support on patient medications. The MCS framework is a good choice to realize this. Assume for patient Sue, the database knows that a) her X-Ray result indicates pneumonia, b) a certain blood marker is present, and c) she has no known allergies. The ontology imports information on X-Ray and blood tests using bridge rules</region>
      <region class="DoCO:TextChunk" id="12" confidence="possible" page="2" column="1">( C onto : xray ( Sue )) ← ( C patients : labresult ( Sue, xray )) . ( C onto : marker ( Sue )) ← ( C patients : labresult ( Sue, marker )) .</region>
      <region class="DoCO:TextChunk" id="16" page="2" column="1">As the ontology contains the axiom xray ⊓ marker ⊑ atyp pneu it concludes that Sue has a atypical pneumonaia, severe kind of pneumonia. Finally, the expert system, a logic program containing rules give weak ∨ give strong : − pneumonia . and give strong : − atyp pneumonia . suggests one out of two kinds of antibiotics if a patient has pneumonia. But it also respects potential allergies by the constraint : − give strong , not allowed strong . As Sue has atypical pneumonia, only the strong antibiotic will help, so the logic program suggests this. Now assume that Sue is allergic to strong antibiotics, a case that actually happens in the real world. Then the expert system can give no valid suggestion as strong antibiotics have to be given, but at the same time they are forbidden to be applied. This results in the whole system having no ‘model’ satisfying deductions of all knowledge bases and bridge rules. We call such an MCS inconsistent. 1 By this example, we identify the following open problems : – the inconsistency above is present due to tuples in the database, termino- logical assertions in the ontology, logic programming rules in the expert system and, a set of bridge rules establishing the information exchange. In what terms should the inconsistency be described and is there a uniform description irrespective of the specific formalisms used in contexts? Non- monotonicity of bridge rules and contexts is an additional challenge to such a description. – Given such a description it is very likely that multiple ways exist to restore consistency. Removing some bridge rules would make the above example consistent, but also removal of tuples describing lab results. Similarly, addition of new bridge rules could resolve the inconsistency. If multiple options exist, which is the most preferred to restore consistency? Is it possible to do this in a heterogeneous way, i.e., can the designer of an MCS use a formalism of his own choice to specify his preference? Can such preference be given only for specific parts of an MCS and preference for other parts differently expressed? – In the above example, the inconsistency can be dealt with locally, e.g., the expert system could switch to use paracoherent semantics and the MCS 1 A complete formalisation of this example is available in [ <xref ref-type="bibr" rid="R12" id="13" class="deo:Reference">12</xref>].<marker type="page" number="3"/><marker type="block"/> becomes consistent. For MCSs with cyclic information flow, however, this might be impossible as cyclic information flow can be such that each context returns valid belief sets (“models”), but still for the overall system it does not fit together. How far does local inconsistency management help to resolve inconsistency, e.g., for MCSs with acyclic information flow? – Besides inconsistency, is the MCS framework so versatile as to use other kinds of rules to connect contexts, e.g., SPARQL queries for information exchange? As research on these topics has been started two years ago, the rest of this paper will briefly present results adressing above questions. Regarding research methodologies, we built analogies from existing techniques, e.g., Reiter’s diagnosis. For algorithms we resorted to reductions to computational logic and meta- reasoning transformations, e.g., preference is handled in this way. Whenever possible, our invented methods are open so that legacy systems may be integrated to achieve certain tasks, e.g., local inconsistency management. Contributions summary: – we developed a uniform representation of inconsistency in terms of bridge rules. This representation leads a) to the notion of inconsistency explanation which separates different sources of inconsistency and points out those bridge rules creating inconsistency and b) to the notion of diagnosis which induce all possible repairs of an inconsistent MCS. Notably, both notions coincide on the overall set of bridge rules which are marked ‘faulty. – on top of those notions, we developed a transformation-based technique to allow meta-reasoning on diagnoses of an inconsistent MCS. This allows system designers to express preferences over diagnoses in a formalism of their own choice. The same techinque also allows to filter out undesired diagnoses. – for local inconsistency management, a generalization of the MCS formalism was developed allowing to use existing methods of inconsistency management locally for a context. The introduced notion of a context manager allows to employ arbitrary knowledge management techniques locally at a context. It is important that the employed manager can change a knowledge base in a broad range and therefore it can also do other operations like view updates, belief revision, logic program updates, etc. – for above notions the computational complexity also was analysed. – to show the versatility of the ideas behind MCS, we also introduced a modified notion of MCS where knowledge exchange is specified using SPARQL queries. Finally, we also implemented prototypes for evaluating MCSs and computing diagnoses and explanations of inconsistent MCSs. The remainder of this paper is organized as follows: In Section 2 related work is discussed while Section 3 recapitulates the formal semantics of MCS and our basic notion for inconsistency diagnosis/explanation, it is followed by a short presentation of major achievements in the last two years in Section 4. Finally, Section 5 is an outlook on future work.</region>
      <outsider class="DoCO:TextBox" type="page_nr" id="15" page="2" column="1">18</outsider>
      <outsider class="DoCO:TextBox" type="page_nr" id="17" page="3" column="1">19</outsider>
      <section class="deo:RelatedWork">
        <h1 class="DoCO:SectionTitle" id="18" page="4" column="1">2 Related Work</h1>
        <region class="DoCO:TextChunk" id="32" page="4" column="1">With the seminal work of [<xref ref-type="bibr" rid="R19" id="19" class="deo:Reference">19</xref>] and [<xref ref-type="bibr" rid="R16" id="20" class="deo:Reference">16</xref>] the notion of context has been introduced to artificial intelligence and logic. In these works, a context is a regarded as a certain point of view in which formal reasoning takes place. The Trento school (cf. [<xref ref-type="bibr" rid="R17" id="21" class="deo:Reference">17</xref>, <xref ref-type="bibr" rid="R22" id="22" class="deo:Reference">22</xref>]) formalized and improved this understanding of context. It is notable, however, that those first frameworks consider homogeneous, monotonic logics for representing a context. With [<xref ref-type="bibr" rid="R9" id="23" class="deo:Reference">9</xref>, <xref ref-type="bibr" rid="R21" id="24" class="deo:Reference">21</xref>] non-monotonicity was introduced to Multi-Context Systems. Although default negation is added to bridge rules, contexts still are homogeneous or monotonic. Only with [<xref ref-type="bibr" rid="R7" id="25" class="deo:Reference">7</xref>] the framework has been generalized for non-monotonic bridge rules and heterogeneous contexts. This finally allows to use arbitrary knowledge sources that are connected by (possibly) non-monotonic bridge rules. Our research is based on this notion of MCSs. To deal with inconsistency, in [<xref ref-type="bibr" rid="R5" id="26" class="deo:Reference">5</xref>] defeasible rules are introduced as a way of establishing information exchange in MCS. Defeasible rules are similar to bridge rules, but their semantics differs as a defeasible rule does not fire if it would cause an inconsistency by doing so. Several algorithms based on preference orders (or argumentation frameworks [<xref ref-type="bibr" rid="R4" id="27" class="deo:Reference">4</xref>]) have been proposed. Inconsistency is resolved inherently, but no deeper inconsistency analysis is possible. For our hospital example this would mean that some information simply would not be passed along, e.g., forgetting the illness of Sue . Most of the proposed algorithms are based on provenance, which means that context internals have to be exhibited to other contexts. A company making profit by allowing third parties to use its knowledge base, however, will not risk its business by providing such information. Aside from MCS, other areas deal with knowledge integration and its issues. Peer-to-Peer (p2p) systems [24,<xref ref-type="bibr" rid="R10" id="28" class="deo:Reference">10</xref>, <xref ref-type="bibr" rid="R24" id="29" class="deo:Reference">24</xref>,10] are similar as knowledge sources interchange pieces of information. Although the notion of a peer is very similar to a context in MCS, the essential feature of p2p systems is that peers may leave and join the system arbitrarily. Therefore research seeks to cope with inconsistency by isolating faulty contexts and simply ignore their information instead of analysing the inconsistency and aiming for a consistent system. Information integration on the other hand deals extensively with issues like constraint violations that stem from the integration of several databases into a single one (cf. [<xref ref-type="bibr" rid="R6" id="30" class="deo:Reference">6</xref>] for a survey on data fusion). Its main differences to MCS are that the result of data fusion is one single database which usually uses relational algebra for knowledge representation. MCSs, however, require inconsistency management for multiple, heterogeneous knowledge bases which are not restricted to a relational setting. For many formalisms, methods of inconsistency handling have been invented, e.g., belief revision or possibilistic reasoning (e.g. [<xref ref-type="bibr" rid="R3" id="31" class="deo:Reference">3</xref>]) for classical logic, paracoherent semantics for logic programs, etc. These methods can resolve inconsistency locally at a context (cf. Section 4), but they can not guarantee a consistent system. Also, most of those methods are only applicable to a specific formalism instead of a heterogeneous non-monotonic system.</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="33" page="4" column="1">20</outsider>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="34" page="5" column="1">3 MCS Preliminaries</h1>
        <region class="DoCO:TextChunk" id="41" page="5" column="1">Each context of an MCS is seen as a knowledge base built on an underlying logic. To capture different kinds of logics, this notion is general and not defined in the bottom-up style of inductive definitions for syntax and semantics. Instead, its approach is top-down, directly working with sets of well-formed formulas (wffs) and models (called belief sets). The semantics of a logic then only maps each set of wffs to a set of belief sets, i.e., the models of the wffs. Formally, a logic L = ( KB L , BS L , ACC L ) consists, of the following compo- nents: 1) KB L is the set of well-formed knowledge bases of L where each element of KB L is a set (of formulas). 2) BS L is the set of possible belief sets where we assume that each element of BS L is a set (i.e.,a model containing all formulas that are considered true). 3) ACC L : KB L → 2 BS L is a function describing the semantics of L by assigning each knowledge base a set of acceptable belief sets. This concept of a logic captures many monotonic and non-monotonic logics, e.g., classical logic, description logics, modal, default, and autoepistemic logics, circumscription, and logic programs under the answer set semantics. A Multi-Context System M = ( C 1 , . . . , C n ) is a collection of contexts C i = ( L i , kb i , br i ), 1 ≤ i ≤ n , where L i = ( KB i , BS i , ACC i ) is a logic, kb i ∈ KB i a knowledge base, and br i is a set of bridge rules of form (1) over logics ( L 1 , . . . , L n ). Furthermore, for each bridge rule r ∈ br i its head formula s is compatible with C i , i.e., for each H ⊆ { s | r ∈ br and ( i : s ) is the head of r } holds kb ∪ H ∈ KB L i . A belief state S = ( S 1 , . . . , S n ) of an MCS M = ( C 1 , . . . , C n ) is a belief set for every context, i.e., S i ∈ BS i for all 1 ≤ i ≤ n . The semantics of MCS is defined in terms of equilibria, i.e., belief states that reproduce themselves under the application of bridge rules. Formally, let M be an MCS, C i a context of M and S = ( S 1 , . . . , S n ) a belief state of M , then an bridge rule r of form (1) is applicable wrt. S , denoted by S | = body ( r ), iff p l ∈ S c l for 1 ≤ l ≤ j and p l ∈ / S c l for j &lt; l ≤ m . Let app i ( S ) = { hd ( r ) | r ∈ br i ∧ S | = body ( r ) } denote the heads of all applicable bridge rules of context C i under S , then S = ( S 1 , . . . , S n ) is an equilibrium of M if and only if S i ∈ ACC i ( app i ( S )) for 1 ≤ i ≤ n . <marker type="block"/> Basic Notions for Inconsistency Analysis (cf. [<xref ref-type="bibr" rid="R12" id="36" class="deo:Reference">12</xref>]): We call an MCS M inconsistent iff no belief state of M is an equilibrium. To analyse and explain the inconsistency in an MCS, two notions have been developed: consistency- based diagnosis and entailment-based inconsistency explanation. Both notions use bridge rules to characterize ‘faulty’ information exchange. Intuitively, a diagnosis states how an inconsistent MCS can be changed to get a consistent system and an explanation shows what parts of the system create the inconsistency. For an MCS M , br M denotes the set of all bridge rules occuring in M , M [ R ] denotes a modified MCS where all bridge rules of M are replaced by those of R , and M | = ⊥ denotes that M is inconsistent. Given an MCS M , a diagnosis of M is a pair ( D 1 , D 2 ), D 1 , D 2 ⊆ br M , s.t. M [ br M \ D 1 ∪ heads ( D 2 )] | = ⊥ . An explanation of M is a pair ( E 1 , E 2 ) of sets E 1 , E 2 ⊆ br M of bridge rules<marker type="page" number="6"/><marker type="block"/> s.t. for all ( R 1 , R 2 ) where E 1 ⊆ R 1 ⊆ br M and R 2 ⊆ br M \ E 2 , it holds that M [ R 1 ∪ heads ( R 2 )] | = ⊥ . For a concise characterization, one usually focuses on subset-minimal diagnoses and explanations. The basic ideas behind both notions appear also in Reiter’s seminal work on diagnosis [<xref ref-type="bibr" rid="R20" id="39" class="deo:Reference">20</xref>]. Our diagnosis is similar to his notion and our explanation is similar to (minimal) inconsistent sets. For differences, we assume the source of inconsistency to be some faulty information exchange, so we only consider bridge rules, and because of the non-monotonic nature of MCSs, a bridge rule can be faulty by firing when it should not and also by not firing when it should. In classical diagnosis, only the former is relevant as monotonic logics only become inconsistent by that. The set of minimal diagnoses can also be seen as describing all minimal repairs, while the set of minimal explanations show hows inconsistency is caused in the system. The set E 2 in an explanation also shares some ideas with consistency restoring rules (cf. [<xref ref-type="bibr" rid="R2" id="40" class="deo:Reference">2</xref>]) of logic programs.</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="38" page="5" column="1">21</outsider>
      </section>
      <section class="deo:Methods">
        <h1 class="DoCO:SectionTitle" id="42" page="6" column="1">4 Contributions: Methods of Inconsistency Management</h1>
        <region class="DoCO:TextChunk" id="53" page="6" column="1">This section presents contributions and answers the motivational questions raised in the introduction. These are the major published results of my graduate research. Note that authors are listed alphabetically for the respective publications. <marker type="block"/> Inconsistency Assessment: Having jointly developed and investigated, the basic notions for inconsistency analysis, the next step was developing methods to assess inconsistency qualitatively, i.e., filter diagnoses with undesired prop- erties and select most preferred ones. In the spirit of MCS, we do not apply a specific formalism for preference or filters on diagnoses, but rather show how a transformation of the MCS and slight adaption of the notion of diagnosis is sufficient to achieve the desired effects in [<xref ref-type="bibr" rid="R13" id="44" class="deo:Reference">13</xref>]. As one of the strengths of MCS is the ability to allow arbitrary formalisms for knowledge representation inside contexts, we do not want to restrict the users to a specific kind of representation of filters (or preferences). We therefore devised a meta-reasoning transformation which allows certain contexts to observe which diagnosis is applied to the MCS. The desired filter then is realized inside such an observer context (in a formalisms which is best suited for this task). So an MCS M is transformed into an MCS M f where an additional observer context ob is added together with some additional bridge rules (details cf. [<xref ref-type="bibr" rid="R13" id="45" class="deo:Reference">13</xref>]). As M f contains all contexts and bridge rules of M , every diagnosis of M can also be applied to M f . If ob detects an undesired diagnosis D ′ , then ob simply becomes inconsistent, i.e., having no acceptable belief set. Therefore D ′ is no diagnosis of M f , but all other diagnoses of M are diagnoses of M f . This allows to compute all filtered diagnoses with the same algorithm as for computing subset-minimal diagnoses and it also allows to specify the filter in any desired formalism. The meta-reasoning transformation also can be applied for multiple observa- tion contexts where each observer only sees some bridge rules instead of all, thus preserving information hiding. As a similar meta-reasoning transformation can<marker type="page" number="7"/><marker type="block"/> be used for comparison of diagnoses, it is possible to realize any given preference order on diagnoses and select the most preferred one. In general, however, this requires exponentially many more bridge rules in the transformed system, but for restricted classes of preference orders it is feasible.<marker type="block"/> Inconsistency management at the level of contexts: For many specific logics and knowledge formalisms, solutions to deal with inconsistency have been developed in the past, e.g., belief revision and paraconsistency for logics, paracoherent logic programming for logic programs, etc. For contexts using the underlying formalism it is desireable that MCSs also offer the same methods of inconsistency handling. Those methods, however, require to modify a knowledge base in more ways, than just the addition of formulas as bridge rules can do. We therefore propose managed Multi-Context Systems (mMCS) in [<xref ref-type="bibr" rid="R8" id="49" class="deo:Reference">8</xref>] where each context is equiped with a manager that can apply arbitrary changes to the context’s knowledge base. Bridge rules in an mMCS are like those of MCS, but their head contains a unary command op , e.g., revise ( s ), delete ( s ), add ( s ), to apply the resp. operation on the formula s and the knowledge base of the context. Managed MCS are a significant generalization of MCS as management functions can be used to realize a multitude of tasks: belief revision, view updates, updates of logic programs. To us, the most interesting is to ensure that contexts have a ‘model’ for any input. Such contexts are called totally coherent . Most notably even mMCS with totally coherent contexts cannot guarantee that the overall system has an equilibrium, but they ensure that inconsistency is only caused by odd-cyclic information flow. It directly follows that any acyclic mMCS with totally coherent contexts is consistent, thus proving local inconsistency management sufficient for acyclic MCS.<marker type="block"/> Beyond bridge rules: In [<xref ref-type="bibr" rid="R23" id="51" class="deo:Reference">23</xref>] we introduce MCS where knowledge exchange is realised using SPARQL construct-queries. This is surprisingly simple and again shows the versatility of MCS. The resulting SPARQL-MCS framework is related to the MWeb approach [<xref ref-type="bibr" rid="R1" id="52" class="deo:Reference">1</xref>], but our treatment of variables is different.</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="47" page="6" column="1">22</outsider>
      </section>
      <section class="deo:FutureWork">
        <h1 class="DoCO:SectionTitle" id="54" page="7" column="1">5 Future Work</h1>
        <region class="DoCO:TextChunk" id="60" page="7" column="1">As shown above, we were able to answer several foundational questions, give a uniform representation of inconsistency in heterogeneous MCSs, an open integration of preference-based inconsistency assessment, investigating the impact of local inconsistency handling, and making the MCS formalism capable of dealing with arbitrary changes to the knowledge bases of an MCS. To evaluate the feasibility of the developed methods, we also aim for a refer- ence application which is currently in the making: querying of a DNA database posing questions in (almost) natural language using an ontology and answer- set programs. Intital steps towards exchanging large amounts of information (cf. [ <xref ref-type="bibr" rid="R14" id="55" class="deo:Reference">14</xref>]) also showed that more specialised algorithms are needed.<marker type="page" number="8"/><marker type="block"/> Investigations whether approximation operators of [<xref ref-type="bibr" rid="R11" id="58" class="deo:Reference">11</xref>] for logic programs can be translated to MCSs and transferring optimisations for abductive diagnosis (e.g.,[<xref ref-type="bibr" rid="R18" id="59" class="deo:Reference">18</xref>]) to MCSs are also open tasks.</region>
        <outsider class="DoCO:TextBox" type="page_nr" id="57" page="7" column="1">23</outsider>
      </section>
      <section class="deo:Acknowledgements">
        <h1 class="DoCO:SectionTitle" id="61" page="8" column="1">6 Acknowledgements</h1>
        <region class="DoCO:TextChunk" id="62" page="8" column="1">I am very grateful to my advisor Thomas Eiter, the principal investigator of our research project Michael Fink, and my colleague Peter Schüller who provided guidance, and helped with many fruitful discussions. Thank you.</region>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="63" page="8" column="1">References</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" class="deo:BibliographicReference" id="64" page="8" column="1">1. Analyti, A., Antoniou, G., Damasio, C.V.: MWeb: A principled framework for modular web rule bases and its semantics. ACM Trans. Comput. Logic 12(2) (2011)</ref>
          <ref rid="R2" class="deo:BibliographicReference" id="65" page="8" column="1">2. Balduccini, M., Gelfond, M.: Logic programs with consistency-restoring rules. In: International Symposium on Logical Formalization of Commonsense Reasoning, AAAI 2003 Spring Symposium Series. pp. 9–18 (2003)</ref>
          <ref rid="R3" class="deo:BibliographicReference" id="66" page="8" column="1">3. Benferhat, S., Lagrue, S., Yahi, S.: Bridging possibilistic conditional knowledge bases and partially ordered bases. In: JELIA. pp. 38–50 (2010)</ref>
          <ref rid="R4" class="deo:BibliographicReference" id="67" page="8" column="1">4. Bikakis, A., Antoniou, G.: Contextual argumentation in ambient intelligence. In: LPNMR. pp. 30–43 (2009)</ref>
          <ref rid="R5" class="deo:BibliographicReference" id="68" page="8" column="1">5. Bikakis, A., Antoniou, G., Hassapis, P.: Alternative strategies for conflict resolution in multi-context systems. In: AIAI. pp. 31–40 (2009)</ref>
          <ref rid="R6" class="deo:BibliographicReference" id="69" page="8" column="1">6. Bleiholder, J., Naumann, F.: Data fusion. ACM Comput. Surv. 41(1), 1–41 (2008)</ref>
          <ref rid="R7" class="deo:BibliographicReference" id="70" page="8" column="1">7. Brewka, G., Eiter, T.: Equilibria in heterogeneous nonmonotonic multi-context systems. In: AAAI. pp. 385–390 (2007)</ref>
          <ref rid="R8" class="deo:BibliographicReference" id="71" page="8" column="1">8. Brewka, G., Eiter, T., Fink, M., Weinzierl, A.: Managed multi-context systems. In: IJCAI (2011), to appear.</ref>
          <ref rid="R9" class="deo:BibliographicReference" id="72" page="8" column="1">9. Brewka, G., Roelofsen, F., Serafini, L.: Contextual default reasoning. In: IJCAI. pp. 268–273 (2007)</ref>
          <ref rid="R10" class="deo:BibliographicReference" id="73" page="8" column="1">10. Calvanese, D., Giacomo, G.D., Lembo, D., Lenzerini, M., Rosati, R.: Inconsistency tolerance in p2p data integration: An epistemic logic approach. Inf. Syst. 33(4-5), 360–384 (2008)</ref>
          <ref rid="R11" class="deo:BibliographicReference" id="74" page="8" column="1">11. Denecker, M., Marek, V.W., Truszczynski, M.: Ultimate approximation and its application in nonmonotonic knowledge representation systems. Inf. Comput. 192(1), 84–121 (2004)</ref>
          <ref rid="R12" class="deo:BibliographicReference" id="75" page="8" column="1">12. Eiter, T., Fink, M., Schüller, P., Weinzierl, A.: Finding explanations of inconsistency in multi-context systems. In: KR (2010)</ref>
          <ref rid="R13" class="deo:BibliographicReference" id="76" page="8" column="1">13. Eiter, T., Fink, M., Weinzierl, A.: Preference-based inconsistency assessment in multi-context systems. In: JELIA. pp. 143–155 (2010)</ref>
          <ref rid="R14" class="deo:BibliographicReference" id="77" page="8" column="1">14. Fink, M., Ghionna, L., Weinzierl, A.: Relational information exchange and aggre- gation in multi-context systems. In: LPNMR. pp. 120–133 (2011)</ref>
          <ref rid="R15" class="deo:BibliographicReference" id="78" page="8" column="1">15. Gelfond, M., Lifschitz, V.: Classical negation in logic programs and disjunctive databases. New Generation Comput. 9(3/4), 365–386 (1991)</ref>
          <ref rid="R16" class="deo:BibliographicReference" id="79" page="8" column="1">16. Giunchiglia, F.: Abstract contextual reasoning (1993)</ref>
          <ref rid="R17" class="deo:BibliographicReference" id="80" page="8" column="1">17. Giunchiglia, F., Serafini, L.: Multilanguage hierarchical logics or: How we can do without modal logics. Artif. Intell. 65(1), 29–70 (1994)</ref>
          <ref rid="R18" class="deo:BibliographicReference" id="81" page="8" column="1">18. de Kleer, J.: Focusing on probable diagnoses. In: AAAI. pp. 842–848 (1991)</ref>
          <ref rid="R19" class="deo:BibliographicReference" id="83" page="9" column="1">19. McCarthy, J.: Notes on formalizing context. In: IJCAI. pp. 555–562 (1993)</ref>
          <ref rid="R20" class="deo:BibliographicReference" id="84" page="9" column="1">20. Reiter, R.: A theory of diagnosis from first principles. Artif. Intell. 32(1), 57–95 (1987)</ref>
          <ref rid="R21" class="deo:BibliographicReference" id="85" page="9" column="1">21. Roelofsen, F., Serafini, L.: Minimal and absent information in contexts. In: IJCAI. pp. 558–563 (2005)</ref>
          <ref rid="R22" class="deo:BibliographicReference" id="86" page="9" column="1">22. Roelofsen, F., Serafini, L.: Minimality and non-determinism in multi-context systems. In: CONTEXT. pp. 424–435 (2005)</ref>
          <ref rid="R23" class="deo:BibliographicReference" id="87" page="9" column="1">23. Schüller, P., Weinzierl, A.: Semantic reasoning with sparql in heterogeneous multi- context systems. In: Semantic Search over the Web (2011), to appear</ref>
          <ref rid="R24" class="deo:BibliographicReference" id="88" page="9" column="1">24. Serafini, L., Giunchiglia, F., Mylopoulos, J., Bernstein, P.: Local relational model: A logical formalization of database coordination. In: CONTEXT. pp. 286–299 (2003)</ref>
        </ref-list>
        <outsider class="DoCO:TextBox" type="page_nr" id="82" page="8" column="1">24</outsider>
        <outsider class="DoCO:TextBox" type="page_nr" id="89" page="9" column="1">25</outsider>
      </section>
    </body>
  </article>
</pdfx>
