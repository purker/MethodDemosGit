<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
  <front>
    <journal-meta />
    <article-meta>
      <title-group>
        <article-title>Unanticipated Context Awareness for Software Configuration Access using the getenv API</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <string-name>Markus Raab</string-name>
          <email>markus.raab@complang.tuwien.ac.at</email>
          <xref ref-type="aff" rid="aff0">0</xref>
        </contrib>
        <aff id="aff0">
          <label>0</label>
          <institution>Markus Raab Institute of Computer Languages, Vienna University of Technology</institution>
        </aff>
      </contrib-group>
      <abstract>
        <p>Configuration files, command-line arguments and environment variables are the dominant tools for local configuration management today. When accessing such program execution environments, however, most applications do not take context, e.g. the system they run on, into account. The aim of this paper is to integrate unmodified applications into a coherent and context-aware system by instrumenting the getenv API. We propose a global database stored in configuration files that includes specifications for contextual interpretations and a novel matching algorithm. In a case study we analyze a complete Debian operating system where every getenv API call is intercepted. We evaluate usage patterns of 16 real-world applications and systems and report on limitations of unforeseen context changes. The results show that getenv is used extensively for variability. The tool has acceptable overhead and improves context-awareness of many applications.</p>
      </abstract>
    </article-meta>
  </front>
  <body>
    <sec id="sec-1">
      <title>1 Introduction</title>
      <p>
        The goal of context-oriented programming (COP) is to avoid the tedious,
timeconsuming and error-prone task of implementing context awareness manually, and
instead adapt the application’s behavior using the concept of layers [
        <xref ref-type="bibr" rid="ref1 ref12">1, 12</xref>
        ]. Each
layer represents one dimension of the context relevant to the application. Contextual
values [
        <xref ref-type="bibr" rid="ref27">27</xref>
        ] act as variables whose values depend on layers. A program execution
environment consists of the environment variables and key/value pairs retrieved from
configuration files. A program execution environment can be tightly integrated with
contextual values [
        <xref ref-type="bibr" rid="ref21">21</xref>
        ]. Context awareness [
        <xref ref-type="bibr" rid="ref5">5</xref>
        ] is a property of software and refers to
its ability to correctly adapt to the current context. Our aim is to make applications
context-aware that previously were not.
      </p>
      <p>For example, an important context for a browser is the network it uses. In a
different network, different proxy settings are required to successfully retrieve a
web page. We want the browser to automatically adapt itself to the network actually
present, i.e., make it context-aware in respect to the network.</p>
      <p>Although COP eases the writing of new software, there remains a huge corpus
of legacy software that cannot profit from context awareness. Our paper aims at
intercepting the standard API getenv in a way that COP-techniques are applied
to unmodified applications. We focus on getenv because we found that it is used
extensively. Our interception technique, however, does not make any assumption
on the API. We recommend to specify the values and the context of the program
execution environments separately. This configuration specification contains
placeholders, each representing a dimension of the context:
In this example, vibration is a contextual value of type boolean and %inpocket%
a placeholder to be substituted in contextual interpretations. Thus, the value of
vibration changes whenever inpocket changes. E.g., when a context sensor
measures body temperature only on one side of the gadget, it will change the value of
%inpocket%. Thus, when the mobile phone is in the pocket, it will turn on vibration.
When the mobile phone is lying on a table, it will turn off vibration to prevent falling
down when someone calls. If needed, users can even specify further context. For
example, some users dislike the context-dependent feature as described. Our approach
inherently allows users to reconfigure every parameter in every context. To turn on
vibration if the phone is not in the pocket, we configure our device differently:
/phone/call/inpocket/vibration = off
/phone/call/notinpocket/vibration = on</p>
      <p>
        In this paper we analyze the popular getenv() API. The function getenv()
is standardized by SVr4, POSIX.1-2001, 4.3BSD, C89, and C99. Because of this
standardization and ease of use it is adopted virtually everywhere, even in core
libraries such as libc. It allows developers to query the environment. Using standard
getenv implementations developers have to act carefully: settings valid in the
current context can differ from those received through getenv. To reduce the danger of
assuming wrong context information we propose to use a context-aware
implementation. We implement it in the whole system by intercepting every getenv API call.
Our contributions are:
• We allow unmodified applications to use contextual values. In these standard
applications the developers did not initially think of context awareness.
• We conduct an extensive case study and analyze 16 applications and systems.
These contributions are of practical relevance. While other approaches require code
rewriting [
        <xref ref-type="bibr" rid="ref3 ref4">3, 4</xref>
        ], our approach is suitable for legacy applications, flexible and open
for extensions. We tackle the research question: “How can we integrate unmodified
applications into a coherent, context-aware system?”
      </p>
      <p>The paper is structured as follows: In Section 2 we elaborate on the background.
In Section 3 we explain our approach and in Section 4 we evaluate it. The validity of
the evaluation is discussed in Section 5. After considering related work in Section 6
we conclude the paper in Section 7.</p>
    </sec>
    <sec id="sec-2">
      <title>2 Background</title>
      <p>
        Context-oriented programming (COP) enables us to naturally separate
multi-dimensional concerns [
        <xref ref-type="bibr" rid="ref24 ref26 ref5">5, 24, 26</xref>
        ]. In some sense it extends object-oriented programming.
Activation and deactivation of layers belong to its main concepts. Every layer
represents a dimension of context that cuts across the system. All active layers together
form the context the program currently is in.
      </p>
      <p>
        The (de)activation of layers occur at any time during program execution. A
currently active stack of layers determines the context the program or thread is in.
COP allows us to specify programs with adaptable, dynamic behavior. Later
approaches [
        <xref ref-type="bibr" rid="ref14">14</xref>
        ] go beyond object-oriented programming: they support program
construction with layers only. Furthermore, later work considers software engineering
perspectives [
        <xref ref-type="bibr" rid="ref24">24</xref>
        ] and modularity visions [
        <xref ref-type="bibr" rid="ref13">13</xref>
        ].
      </p>
      <p>
        Tanter suggested a lightweight subset of COP: Contextual values. They are
easier to understand because they “boil down to a trivial generalization of the idea of
thread-local values” [
        <xref ref-type="bibr" rid="ref27">27</xref>
        ]. They are variables whose values depend on the current
context. Contextual values originate from COP and naturally work along with the
concepts of dynamic scoping and layers.
      </p>
      <p>For newly written context-aware software, COP is a viable choice. For legacy
software, however, rewriting seems unrealistic. So in this paper we introduce a new
approach that does not require modifications of the application.</p>
    </sec>
    <sec id="sec-3">
      <title>3 EnvElektra</title>
      <p>In our approach, we want to intercept every call to the getenv API. Whenever an
application calls the API, we want to invoke a context-aware implementation instead.
EnvElektra, which is our research tool, contains such a getenv() implementation.
The implementation contains a novel matching algorithm for context awareness.
When EnvElektra is installed and activated on a system, the matching algorithm
will be used for every call of getenv() done by any application.</p>
      <p>The basic idea of EnvElektra’s getenv() implementation is as follows: First, it
ensures that the data structure is up-to-date. Second, the matching algorithm
calculates a new key for the parameter of getenv() using the context specification.
Third, this key is searched in the data structure. With the found key, we recursively
descend until every relevant context is considered.</p>
      <p>
        The library LibElektra [
        <xref ref-type="bibr" rid="ref21">21</xref>
        ] (shown in Fig. 1) maps the program execution
environments (e.g., command-line arguments and configuration files) to the in-memory
key/value pairs. LibElektra includes start-up code that initializes all key/value pairs
from a key database. The key database is modular via plugins [
        <xref ref-type="bibr" rid="ref18">18</xref>
        ]. The plugins
allow us to use different syntax for configuration files.
      </p>
      <p>Fig. 1 also depicts the EnvElektra architecture. The system with EnvElektra has
to provide three artifacts (bold, blue boxes): (1) unmodified applications that
become context-aware, (2) context specifications, and (3) context sensors for
out-ofinfluences</p>
      <p>access
context sensors
is part of
load, store
and check
config. files
key/valueadcacetassbase delegatework
access
key/values
access
plugins
unmodified
applications</p>
      <p>uses
context-aware
implementation
of getenv</p>
      <p>API
context
specification
process layer (de)activation. In the remainder of this chapter we will explain the
user-provided artifacts and the matching algorithm. Finally, we will give a full
example demonstrating how the system works interconnected.</p>
      <sec id="sec-3-1">
        <title>3.1 Context Sensors</title>
        <p>An essential issue to enjoy global, context-aware configuration access without
modifying the application is an out-of-process layer (de)activation. We will show why
such context sensors require us to use a database.</p>
        <p>The original function getenv() retrieves values from the environment.
Internally, it uses the data structure char** environ. By design, environ is copied into
every process and will not receive any external changes afterwards. Thus, environ
cannot consider out-of-process changes and cannot be used in EnvElektra.</p>
        <p>
          We prefer to use configuration files that are read by the application itself. Then
security is correctly handled by the operating system. In EnvElektra the
administrator decides which configuration files are used, possibly with different syntax for
each file [
          <xref ref-type="bibr" rid="ref20">20</xref>
          ]. EnvElektra makes sure that all applications have the same global
view of the system’s configuration files leading to a consistently configured system.
This way values returned by getenv() will not be different from values retrieved
from configuration files. The configuration files are viewed as a key/value database
suitable for getenv lookups.
        </p>
        <p>Context sensors observe the system and change the database when they detect
context changes. They are responsible to modify the layers accordingly. Context
sensors write their layer information into /env/layer. The key /env/layer is part
of the database and resides within one of the configuration files. The use of files
enables out-of-process communication between context sensor and applications. Thus,
context changes can have an immediate effect on applications.</p>
        <p>We identified two different kinds of context sensors to be used with our approach:</p>
        <p>
          Information within the Database: Quite often, the necessary value is already
present in the database. For example, in Linux many syscalls and the /sys-file
system already provide much information. Using plugins, these sources are easily
embedded within the database. Then we only need a symbolic link from /env/layer to
the correct key. For example, if /env/layer/nodename points to /syscall/uname/
nodename, then %nodename% will resolve to the nodename as returned by the uname
system call. In EnvElektra we mount plugins into any part of the hierarchy [
          <xref ref-type="bibr" rid="ref18">18</xref>
          ].
        </p>
        <p>Context Sensor Daemons: In other cases, we implement a daemon, i.e. an
active process, that updates /env/layer. Doing so, we can implement hysteresis,
value transformations, and even complex feedback control systems. For
example, to update %inpocket% a daemon measures the temperatures and modifies
/env/layer/inpocket whenever we cross a threshold value. Changes in the
database influence all processes across the whole system.</p>
      </sec>
      <sec id="sec-3-2">
        <title>3.2 Context Specification</title>
        <p>Up to now, we have established a database that contains key/value pairs to be used
in a getenv() implementation. We have to make the database context-aware with
the layer-information present in /env/layer, e.g.:
/env/layer/inpocket = notinpocket</p>
        <p>Furthermore, we specify which key is used in which contextual interpretation:</p>
        <p>Now, when an API accesses /phone/call/vibration, the lookup layer will
search for /phone/call/%inpocket%/vibration. Layer interpretations are stored
in the database below the key /env/layer. In this case the correct contextual
interpretation of %inpocket% is notinpocket. Using more than one placeholder
creates several dimensions of variability. Late-binding is necessary so that unmodified
software benefit from contextual features. EnvElektra needs to resolve its context
awareness as late as possible, i.e., on getenv() calls.</p>
        <p>For example, if a phone-call application executes getenv("vibration") it will
look up /phone/call/vibration. Because of the context specification, we know
we want the key /phone/call/%inpocket%/vibration instead. For the correct
interpretation of %inpocket% we will lookup /env/layer/inpocket first. We get
the value notinpocket for the layer %inpocket%. Thus, getenv("vibration")
will return the value of /phone/call/notinpocket/vibration.</p>
      </sec>
      <sec id="sec-3-3">
        <title>3.3 Matching algorithm</title>
        <p>The core of our approach is the contextual lookup within our alternative
implementation of the getenv API. In EnvElektra getenv() provides the context-aware
variability. The essence of EnvElektra’s getenv() implementation is:
char* getenv(char* key) {
if(needsReload(conf)) {
reloadConfiguration(conf);
reloadLayers(conf);
}
return contextLookup(conf, key);
}
}</p>
        <p>Context is not static but dynamically changes over time. Our approach
supports dynamic changes of context using reloadLayers() even though the original
getenv implementation did not. The interception approach limits us to
contextchanges within getenv(): We cannot (de)activate layers at other places. Instead,
we make sure that for every contextLookup() the correct context is used. The
matching algorithm contextLookup() is recursively defined:
char* contextLookup (KeySet* cfg, char* key) {
m = lookupBySpecification (cfg, key, "context");
if (m) return contextLookup (cfg, fix(m));
else return lookup (cfg, key);</p>
        <p>
          The idea of the algorithm is: First, we look whether a context is specified for the
key. If it is, contextLookup descends recursively after replacing all placeholders in
the key. If it is not, a ordinary lookup will be used. The full implementation features
namespaces, symbolic links and defaults [
          <xref ref-type="bibr" rid="ref20">20</xref>
          ].
        </p>
      </sec>
      <sec id="sec-3-4">
        <title>3.4 Example</title>
        <p>We present a full example that demonstrates recursion with several layers. Suppose
a mobile phone is lying on the table in a building during a meeting. To simplify the
example, we assign constant values to the layers:
/env/layer/inpocket = notinpocket
/env/layer/inbuilding = inbuilding
/env/layer/inmeeting = inmeeting</p>
        <p>
          In a real system, a sensor will continuously update the values. So far, we already
discussed the layer inpocket. The layer inbuilding represents a value from a
location context. Layers such as inmeeting are called virtual sensors [
          <xref ref-type="bibr" rid="ref1">1</xref>
          ]. In this
case the value of the layer is calculated by a sensor querying the person’s schedule.
The application running on the phone uses the following non-context-aware code:
char* use_vibration = getenv("vibration");
if (!strcmp(use_vibration, "on")) {/* activate vibration */}
We add context awareness with the following specification:
[/phone/call/vibration]
type=boolean
context=/phone/call/%inbuilding%/vibration
[/phone/call/inbuilding/vibration]
type=boolean
context=/phone/call/%inpocket%/%inmeeting%/vibration
[/phone/call/notinbuilding/vibration]
type=boolean
context=/phone/call/%handsfree%/vibration
Due to lack of space, we here specify only two of the six possible configurations:
/phone/call/inpocket/inmeeting/vibration = on
/phone/call/notinpocket/inmeeting/vibration = off
        </p>
        <p>Suppose the mobile phone gets a call. By above getenv we request to lookup
/phone/call/vibration to know whether vibration is turned on. In the first step,
it will find the context and resolve inbuilding. In the next step, it will recursively
search in the specification again, and find another context with /phone/call/
%inpocket%/%inmeeting%/vibration. Then the placeholders are again replaced
with the respective values. Resolving this key, the algorithm will not find
another matching specification. Thus, it returns the configuration value of not in
pocket and in meeting, i.e., /phone/call/notinpocket/inmeeting/vibration.
Because this configuration value is off, the phone will not vibrate.</p>
      </sec>
    </sec>
    <sec id="sec-4">
      <title>4 Evaluation</title>
      <p>
        Our methodological foundation is built on “theory of cases” [
        <xref ref-type="bibr" rid="ref6 ref7">6, 7</xref>
        ]. Other research
should supplement our work with further case and user studies.
      </p>
      <p>We chose 16 popular systems for evaluation (as discussed in threats to validity in
Section 5). We will solely focus on existing applications and their integration into a
coherent system.</p>
      <p>The evaluation was conducted on different machines using Debian GNU/Linux
Jessie 8.1 amd64. For the evaluation we globally intercept getenv() using /etc/ld
.so.preload. By listing EnvElektra in /etc/ld.so.preload it will be loaded
before any other library. Thus its symbols will be preferred. Because of this preference
EnvElektra will be used for every getenv()-call.
In each of the following subsections, we will answer one of the questions:
RQ1: What are the usage patterns of getenv() in popular applications?
RQ2: For which applications can we actually exploit getenv() to be used for
unanticipated context awareness? What are the fundamental limitations?
RQ3: What is the overhead that occurs in a system using EnvElektra?</p>
      <sec id="sec-4-1">
        <title>4.1 RQ1: Usage Patterns</title>
        <p>Only APIs that are actually called during runtime can be exploited for context
awareness. To learn more about usage patterns, we count how often getenv(key)
is executed.</p>
        <p>lines of
application code
akonadi 37,214
chromium 18,032,183
curl 249,380
eclipse 3,311,712
evolution 672,789
firefox 12,394,938
gimp 901,703
inkscape 479,849
libreoffice 5,482,215
lynx 192,012
man 142,183
smplayer 76,170
wget 142,603
Mean 3,217,074
Median 479,849
Total 41,821,956
KDE * * 9606 265 * 2634
GNOME * * 144 47 * 4
Debian * * 5317 430 * 286
* Any of the above applications can be started within the same session.
lines of code: Count lines of code with the tool cloc.
getenv all: Count all calls to getenv while using the application.
getenv init: Count all calls to getenv while starting the application.
all unique: From all getenv calls, how many different keys were used?
later unique: From getenv calls after initialization, how many different keys were
used? For wget and curl the first download counts as initialization.
same: From the getenv calls during startup (during runtime an arbitrary high
number could be acquired), what is the maximum number of queries with the same
value for the parameter key?</p>
        <p>To interpret the numbers correctly we have to know that the usage patterns
vary widely even for the same application. For example, firefox started within
GNOME requests 11 GNOME specific and 8 GTK specific environment variables
(like G_DEBUG). If executed on a system with OpenGL enabled, 43 additional
environment variables (like __GL_EVENT_LOGLEVEL) are used to determine OpenGL
configurations. Additionally, the tested system requested three vendor (NV) specific
variables. For KDE, KDE_FULL_SESSION was used as detection. Then 8 more
KDEspecific and 15 more QT-specific environment variables were requested if started
within KDE. Thus, the numbers depend on the desktop environment and hardware.</p>
        <p>For better reproducibility, we freshly installed Debian Jessie KDE and
GNOME variants, respectively. The only modification was the installation of EnvElektra.
For example, on a daily used KDE with many installed applications, we measured
210.276 getenv() during startup, which is 21 more than with a freshly installed
KDE. We see that the numbers also depend on the installed software.</p>
        <p>The above 13 applications request an average of 2969 environment values (2790
median). Akonadi, configured to use IMAP, had the highest number of calls to
getenv. The reason seems to be a potential misuse of a libc function which
requested LANGUAGE 5126 times. During the KDE startup 27% of all getenv calls
were LANGUAGE. We conclude that excessive use can be unintentional.</p>
        <p>From the numbers in the table we conclude that getenv() is used extensively in
all examined applications. Applications often reread environment parameters during
user interactions. This statement is true for both large applications and small helper
tools. As expected, large feature-rich applications request much more environment
variables. The ratios of requested and unique environment variables varies greatly:
it is 14% median, and in akonadi it is ∼ 1%. We see that applications tend to request
the same variables often.</p>
        <p>Our findings regarding RQ1 are:</p>
        <p>(1) We quantitatively show that getenv() is pervasive. We think that the
usage patterns stem from a rather random use of getenv(): variability seems
to be added ad-hoc whenever single developers needed it. Because getenv()
has no noticeable performance implication and typically is not unit-tested, it is
likely that quality assurance will not find unnecessary occurrences.
(2) Based on our observation, getenv() is used frequently after startup.</p>
        <p>Implications: Developers seem to not optimize calls to getenv(). The
resulting high number of getenv()-calls open up possibilities to influence the
behavior of applications on context changes.</p>
      </sec>
      <sec id="sec-4-2">
        <title>RQ2: Unanticipated Context Awareness</title>
        <p>We already showed that the use of getenv() is pervasive, even after startup. Now,
we want to find out whether changes in the context — and thus in the variables
returned by getenv() — actually have an influence on the behavior.</p>
        <p>We found that in help-, save- and open-dialogs different values returned by
getenv() often influence the behavior of the application in a way easily visible
to the user. These environment variables often have immediate and visible
impact when changed dynamically. For example, gimp uses for every open dialog
G_FILENAME_ENCODING and for every help dialog GIMP2_HELP_URI. On context
changes, e.g. when we enter another network or mount a new file system, the
software can automatically be adapted with EnvElektra.</p>
        <p>Now, we investigate context awareness of proxy settings. A user changing the
network with a different proxy should be able to continue browsing. lynx requests
and correctly uses http_proxy for every single page. curl has the same behavior
and reloads 7 additional environment variables every time. wget gives less control
per download but still requests http_proxy for every page in recursive
downloading mode. Firefox uses the proxy for most pages but pages in cache are displayed
even when the proxy is unreachable. Chromium is the only browser not rereading
http_proxy. Instead, it requests many internals such as GOOGLE_API_KEY during
run-time. EnvElektra supports http_proxy well.</p>
        <p>Our approach is very successful whenever an application executes other
programs because during the startup of the programs the whole environment is always
requested and used. Many programs use a pager or editor as external program. For
example, man executes a pager for every displayed manpage.</p>
        <p>For some applications it is possible to specify a configuration file using an
environment variable. In EnvElektra configuration files can be mounted. Then they are a
part of the database, which permits full configurability. For example, less executed
within man uses the environment variable LESSKEY. In such cases our approach
provides seamless context-aware configuration.</p>
        <p>Some getenv() calls, however, do not have any user-visible impact. Instead,
they seem to be left-overs. In LibreOffice, WorkDirMustContainRemovableMedia
is obviously a workaround for a very specific problem. It is not documented
and searching the web for it only reveals the use in the source code. Instead,
OOO_ENABLE_LOCALE_DATA_CHECKS is an announced workaround. In GTK GTK_
TEST_TOUCHSCREEN is requested extensively. According to the commit log it was
explicitly introduced as a test feature.</p>
        <p>Sometimes recurring getenv cannot be exploited to improve context awareness.
For example, LANGUAGE is requested very often but does not influence the
userinterface after startup. Here changes at runtime seem to have no impact. Such
environment variables will only be context-aware during the start of an application.</p>
        <p>A limitation of our approach is the impossibility to detect unwanted changes of
environment variables. For example, the environment variable CC can change during
compilation. Obviously, this easily leads to inconsistent compilation and linking.
In EnvElektra the runtime-context-change feature can easily be (de)activated for
process hierarchies, though.</p>
        <p>Not a single crash occurred in our experiments regardless of which values we
modified. This behavior is not entirely surprising: First, software should validate
values returned from getenv(). Thus, wrong values from getenv() are rejected.
Second, we did no systematic stress testing but only searched for useful changes.</p>
        <sec id="sec-4-2-1">
          <title>Our findings regarding RQ2 are:</title>
          <p>(1) We show that many practical use cases exist where context changes are
applied successfully at runtime.</p>
          <p>(2) Limitations include that some getenv() calls do not have visible impact
and that context switches in rare cases lead to incorrect behavior.</p>
          <p>Implications: EnvElektra increases the context awareness for the evaluated
applications. Specific functionality is even flawlessly context-aware.</p>
        </sec>
      </sec>
      <sec id="sec-4-3">
        <title>RQ3: Overhead</title>
        <p>Finally, we want to evaluate whether the overhead of EnvElektra is acceptable. The
benchmarks were conducted on a hp R EliteBook 8570w using the central processor
unit Intel R CoreTM i7-3740QM @ 2.70GHz. Overhead is measured with valgrind
by running the executable without and with EnvElektra.</p>
        <p>The glibc getenv() implementation linearly searches through the whole
environment. On the one hand, our implementation does not have this constraint. Its
complexity is O(log(n)) compared to O(n) for environ iteration. We do not use
unordered hash maps because we need lexically ordered iteration, e.g. to iterate
over all layers and during reloadConfiguration(). On the other hand, the
contextual lookup involves recursion. Depending on the specification EnvElektra needs
additional nested lookups.</p>
        <p>In a benchmark we compared 1,000,000 getenv() calls with the same number
of EnvElektra’s lookups. We did 11 measurements and report the median value. For
a small number (30) of environment variables, standard getenv() implementations
(0.03 sec) clearly outperform EnvElektra’s lookup (0.06 sec). For 100 environment
variables (which is a typical value) they perform equally well: 0.076 sec for standard
getenv() and 0.073 sec for EnvElektra’s lookup. For more than 100 environment
variables, EnvElektra’s lookup outperforms getenv().</p>
        <p>Regarding the overall overhead, we first report about the diversity of the
applications. For the startup of gimp the overhead of 2.6% is negligible. For the startup of
firefox, however, the overhead is 6.5%. The reason is that Firefox performs exec()
5 times during startup. Then EnvElektra needs to be initialized and needs to parse its
configuration files again. For very small applications, e.g. curl and wget, the
parsing strongly affects the runtime overhead. If they download empty files, the overhead
even dominates. The overhead between different applications varies greatly.</p>
        <p>Next, we were interested in the impact on a system which executes many
processes each with trivial tasks. An extreme example happens to be the compilation of
C software projects with gcc. Because gcc spawns 5 subprocesses for the
compilation of every .c file, the overhead seems to get immense. Actually, the overhead of a
trivial program’s compilation, only containing int main(){}, is 90%. The parsing
of configuration files gets dominant. It is astonishing that the overhead of a
compilation for a full project is only 14%. For this benchmark we compiled EnvElektra from
scratch. The absolute times are 2:23 min total when compiling with EnvElektra and
2:05 min total without EnvElektra as measured with the time utility. The
compilation executed 6847 processes, did 30862 getenv calls, 6199 of which contained CC.
Even though trivial process executions have large overhead, the overall performance
only suffers little, even in extreme cases.</p>
        <p>We further were very interested in any other occurrence with a similar number of
many process executions. The booting of Debian executes 732 processes. The most
often requested environment variable was SANE_DEBUG_SANEI_SCSI with 286
occurrences. In the script startkde, 227 binaries are executed. The executed number
of processes in the case of compilation actually seems to represent an exception. We
conclude that occurrences where processes are spawned excessively are rare.</p>
        <p>
          Finally, we want to discuss the overhead of the reload feature. We chose the
following setup: We installed the webserver lighttpd locally. EnvElektra was
active throughout the whole experiment. To download 10 files with 1MB to 10MB
size each we executed curl -o "#1 http://localhost/test/[
          <xref ref-type="bibr" rid="ref1 ref10 ref2 ref3 ref4 ref5 ref6 ref7 ref8 ref9">1-10</xref>
          ]".
Without reloading this execution resulted in 83,786,947 instructions. With reloading
EnvElektra every millisecond, valgrind counted 91,569,790 instructions. The reloading
caused the configuration to be fetched 91 times instead of 4 times. Because of an
optimization within EnvElektra only stat is used on the configuration files without
parsing them again. Thus, the overhead is only 9.3%.
        </p>
        <p>Different to the benchmark setup above we will now change the database once
during program execution. Then EnvElektra will reread the respective configuration
file. We have to take care that the changed value does not influence the control
flow. For example, if we add the no_proxy variable, proxy setup is skipped and
the performance even increases. Thus, we changed COLUMNS, which is requested for
every download but does not influence the overhead more than unrelated parameters.
When changing it during one of the ten requests the execution needed 95,248,722
instructions. We see that actual context changes have acceptable overhead of ∼ 4%.</p>
        <sec id="sec-4-3-1">
          <title>Our findings regarding RQ3 are:</title>
          <p>(1) In applications that terminate very soon, e.g. only showing help text, the
run-time overhead dominates. In practical use, however, EnvElektra only adds
run-overhead from 2.6% to 14% (in extreme but realistic cases).</p>
          <p>(2) Dynamic reload has about 10% overhead. On context changes the
overhead increases again by about 4% in a realistic http-proxy-transition.</p>
          <p>Implications: EnvElektra’s run-time overhead typically is low and thus
acceptable. For frequent context changes, optimizations would be preferable.</p>
        </sec>
      </sec>
    </sec>
    <sec id="sec-5">
      <title>5 Threats to Validity</title>
      <p>As in all quantitative studies our concern is if the evaluated software is
representative. In RQ1 we address it by using a significant number of diverse open-source
software in terms of functionality, development teams and programming languages.
We did not consider context awareness already present in applications. Although
interception also works for closed-source software, we did not study it because of
the impossibility to cross-check with source code. Anyhow some of the software,
including libreoffice, chromium and eclipse, has at least origins in closed-source
development. Thus, the results can be valid for closed-source software, too. While we
think that the software we inspected represents some characteristics of variability
APIs, more general conclusions need further work.</p>
      <p>In the methodology of RQ2, we need to interpret whether contextual
awareness can be exploited. We avoid subjective judgements about context awareness
during program start. One could also modify the environment with a wrapper script
to achieve similar results. We prefer to examine dynamic context changes which are
impossible with former approaches. To improve reproducibility and objectivity we
only consider visible changes in the user interface.</p>
      <p>We exclusively measure calls of getenv but do not consider the use of the
environ pointer, the third parameter of main, and /proc. We cannot guarantee
full coverage. Therefore our evaluation actually underestimates the full potential.</p>
      <p>We added optional logging to count the number of getenv. Logging, however,
influences a system deeply. On one system two start-processes failed when logging
was activated. We did not find other occurrences that caused differences in behavior.
Thus, we always rerun our tests without logging.</p>
      <p>The benchmarks are conducted comparatively and consider only a single
implementation of getenv. Therefore run-time measurements may not apply for other
versions or OSs. Additionally, the benchmarks yield very different results
depending on the size of the used configuration files and the respective parser. To level out
this problem, we took care that our setup is realistic. We used 8 different
configuration files and especially chose parsers which are known to be slow. We think that
it is straight-forward to reproduce our benchmarks in a way that they perform even
better than the numbers we reported.</p>
      <p>Overall, while we cannot draw general conclusions for context-aware
configuration access in the getenv API, we think that our study unveils some important
insights, particularly for open source software.</p>
    </sec>
    <sec id="sec-6">
      <title>6 Related Work</title>
      <p>
        Riva et al. [
        <xref ref-type="bibr" rid="ref23">23</xref>
        ] acquired software-engineering-related knowledge from studying
context-aware software. Different from our approach, they reverse-architected
existing context-aware support systems. We preferred to study the behaviour of
wellknown software when introducing context awareness.
      </p>
      <p>
        Context-aware middleware [
        <xref ref-type="bibr" rid="ref8 ref9">8, 9</xref>
        ] is a well-established research direction.
EnvElektra could be seen as local context-aware middleware for configuration.
EnvElektra scores in situations where legacy software needs to be deployed.
      </p>
      <p>
        Using the correct context is a subtopic of avoiding configuration errors. Yin et
al. [
        <xref ref-type="bibr" rid="ref28">28</xref>
        ] researched different types of configuration-parameter-related mistakes. They
investigated value-environment mistakes which can be caused by wrong contextual
interpretation. Which errors actually are induced by incorrect contextual
interpretation, however, is still an open question.
      </p>
      <p>
        A lot of work exists about how to extract program configuration constraints from
source code [
        <xref ref-type="bibr" rid="ref16 ref22">16, 22</xref>
        ]. The authors argue that even though many constraints are
extracted, sometimes additional external knowledge is needed. We think that context
awareness is such a constraint.
      </p>
      <p>
        Context-oriented programming (COP) already has an important role within
software-engineering [
        <xref ref-type="bibr" rid="ref1 ref12 ref24">1, 12, 24</xref>
        ]. COP mainly aims at more comprehensible
programs expressing more context awareness. Our approach tackles the problem in a
different direction: We add context awareness without changing the program.
      </p>
      <p>
        Previous work [
        <xref ref-type="bibr" rid="ref19">19</xref>
        ] describes context-awareness by using explicit layer
activations. Other than our approach, these methods cannot be used for already existing
applications.
      </p>
      <p>
        Niu et al. [
        <xref ref-type="bibr" rid="ref17">17</xref>
        ] report on a web-based framework which uses indoor location,
which is an important context sensor. Software product line engineering [
        <xref ref-type="bibr" rid="ref2 ref25">2, 25</xref>
        ]
deals with the question how to construct products by combining features.
Configuration specification languages [
        <xref ref-type="bibr" rid="ref10 ref11">10, 11</xref>
        ] rarely have support for context. An exception
is the context oriented component model PCOM [
        <xref ref-type="bibr" rid="ref15">15</xref>
        ]. Unlike our approach, these
approaches cannot be used for already existing applications.
      </p>
      <p>
        Yuan et al. [
        <xref ref-type="bibr" rid="ref29">29</xref>
        ] provided a quantitative characteristic study for software logging.
Similar to our study they revealed that their object of study is used in four large
open-source applications pervasively. Different to our approach, they researched
how logging statements were introduced and changed, while we show how APIs for
variability are intercepted for more context awareness.
      </p>
    </sec>
    <sec id="sec-7">
      <title>7 Conclusion</title>
      <p>In this paper, we described a context-aware database using configuration files. A
getenv implementation uses it for context-aware configuration access. Applications
facilitating this API profit from context awareness. Our approach is unique because
it allows applications to be context-aware without any modifications.</p>
      <p>We saw that getenv() in most software provides excessive variability which is
currently underutilized. This variability benefits from context awareness. The paper
gives ideas for programmers how getenv() can be used with more efficacy.
Sometimes software is even capable to dynamically adapt to context changes even though
the authors did not anticipate this use. In a benchmark we found out that while in
small synthetic benchmarks the overhead might be devastating, in practice it stays
well with reasonable bounds.</p>
      <p>Our results are:
• Presentation of an approach in which applications are more aware of their context
• A novel context-aware getenv() implementation downloadable from
http://www.libelektra.org.
• Providing experimental validation by a case study of significant complexity.
Acknowledgements I would like to thank Franz Puntigam, Helmut Toplitzer, Christian Amsu¨ss,
Nedko Tantilov and the anonymous reviewers for a detailed review of this paper. Many thanks
especially to Natalie Kukuczka and Elisabeth Raab.</p>
    </sec>
  </body>
  <back>
    <ref-list>
      <ref id="ref1">
        <mixed-citation>
          1.
          <string-name>
            <surname>Baldauf</surname>
            ,
            <given-names>M.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Dustdar</surname>
            ,
            <given-names>S.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Rosenberg</surname>
            ,
            <given-names>F.</given-names>
          </string-name>
          :
          <article-title>A survey on context-aware systems</article-title>
          .
          <source>International Journal of Ad Hoc and Ubiquitous Computing</source>
          <volume>2</volume>
          (
          <issue>4</issue>
          ),
          <fpage>263</fpage>
          -
          <lpage>277</lpage>
          (
          <year>2007</year>
          )
        </mixed-citation>
      </ref>
      <ref id="ref2">
        <mixed-citation>
          2.
          <string-name>
            <surname>Berger</surname>
            ,
            <given-names>T.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Lettner</surname>
            ,
            <given-names>D.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Rubin</surname>
            ,
            <given-names>J.</given-names>
          </string-name>
          , Gru¨nbacher,
          <string-name>
            <given-names>P.</given-names>
            ,
            <surname>Silva</surname>
          </string-name>
          ,
          <string-name>
            <given-names>A.</given-names>
            ,
            <surname>Becker</surname>
          </string-name>
          ,
          <string-name>
            <given-names>M.</given-names>
            ,
            <surname>Chechik</surname>
          </string-name>
          ,
          <string-name>
            <given-names>M.</given-names>
            ,
            <surname>Czarnecki</surname>
          </string-name>
          ,
          <string-name>
            <surname>K.</surname>
          </string-name>
          :
          <article-title>What is a feature?: a qualitative study of features in industrial software product lines</article-title>
          .
          <source>In: Proceedings of the 19th International Conference on Software Product Line</source>
          , pp.
          <fpage>16</fpage>
          -
          <lpage>25</lpage>
          . ACM (
          <year>2015</year>
          )
        </mixed-citation>
      </ref>
      <ref id="ref3">
        <mixed-citation>
          3.
          <string-name>
            <surname>Bockisch</surname>
            ,
            <given-names>C.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Kanthak</surname>
            ,
            <given-names>S.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Haupt</surname>
            ,
            <given-names>M.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Arnold</surname>
            ,
            <given-names>M.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Mezini</surname>
            ,
            <given-names>M.</given-names>
          </string-name>
          :
          <article-title>Efficient control flow quantification</article-title>
          .
          <source>In: ACM SIGPLAN Notices</source>
          , vol.
          <volume>41</volume>
          , pp.
          <fpage>125</fpage>
          -
          <lpage>138</lpage>
          . ACM (
          <year>2006</year>
          )
        </mixed-citation>
      </ref>
      <ref id="ref4">
        <mixed-citation>
          4.
          <string-name>
            <surname>Costanza</surname>
            ,
            <given-names>P.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Hirschfeld</surname>
            ,
            <given-names>R.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>De Meuter</surname>
          </string-name>
          , W.:
          <article-title>Efficient layer activation for switching contextdependent behavior</article-title>
          . In: D.
          <string-name>
            <surname>Lightfoot</surname>
            ,
            <given-names>C.</given-names>
          </string-name>
          Szyperski (eds.)
          <source>Modular Programming Languages, Lecture Notes in Computer Science</source>
          , vol.
          <volume>4228</volume>
          , pp.
          <fpage>84</fpage>
          -
          <lpage>103</lpage>
          . Springer (
          <year>2006</year>
          ). URL http: //dx.doi.org/10.1007/11860990_
          <fpage>7</fpage>
        </mixed-citation>
      </ref>
      <ref id="ref5">
        <mixed-citation>
          5.
          <string-name>
            <surname>Dey</surname>
            ,
            <given-names>A.K.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Abowd</surname>
            ,
            <given-names>G.D.:</given-names>
          </string-name>
          <article-title>The what, who, where, when, why and how of context-awareness</article-title>
          .
          <source>In: CHI '00 Extended Abstracts on Human Factors in Computing Systems, CHI EA '00</source>
          . ACM,
          <string-name>
            <surname>NY</surname>
          </string-name>
          (
          <year>2000</year>
          ). URL ftp://ftp.cc.gatech.edu/pub/gvu/tr/1999/99-
          <fpage>22</fpage>
          .pdf
        </mixed-citation>
      </ref>
      <ref id="ref6">
        <mixed-citation>
          6.
          <string-name>
            <surname>Easterbrook</surname>
            ,
            <given-names>S.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Singer</surname>
            ,
            <given-names>J.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Storey</surname>
            ,
            <given-names>M.A.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Damian</surname>
            ,
            <given-names>D.</given-names>
          </string-name>
          :
          <article-title>Selecting empirical methods for software engineering research</article-title>
          . In:
          <string-name>
            <given-names>F.</given-names>
            <surname>Shull</surname>
          </string-name>
          ,
          <string-name>
            <given-names>J.</given-names>
            <surname>Singer</surname>
          </string-name>
          , D. Sjøberg (eds.) Guide to Advanced Empirical Software Engineering, pp.
          <fpage>285</fpage>
          -
          <lpage>311</lpage>
          . Springer (
          <year>2008</year>
          ). URL http://dx.doi.org/ 10.1007/978-1-
          <fpage>84800</fpage>
          -044-5_
          <fpage>11</fpage>
        </mixed-citation>
      </ref>
      <ref id="ref7">
        <mixed-citation>
          7.
          <string-name>
            <surname>Eisenhardt</surname>
            ,
            <given-names>K.M.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Graebner</surname>
            ,
            <given-names>M.E.</given-names>
          </string-name>
          :
          <article-title>Theory building from cases: opportunities and challenges</article-title>
          .
          <source>Academy of management journal 50(1)</source>
          ,
          <fpage>25</fpage>
          -
          <lpage>32</lpage>
          (
          <year>2007</year>
          )
        </mixed-citation>
      </ref>
      <ref id="ref8">
        <mixed-citation>
          8.
          <string-name>
            <surname>Geihs</surname>
            ,
            <given-names>K.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Barone</surname>
            ,
            <given-names>P.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Eliassen</surname>
            ,
            <given-names>F.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Floch</surname>
            ,
            <given-names>J.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Fricke</surname>
            ,
            <given-names>R.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Gjorven</surname>
            ,
            <given-names>E.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Hallsteinsen</surname>
            ,
            <given-names>S.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Horn</surname>
            ,
            <given-names>G.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Khan</surname>
            ,
            <given-names>M.U.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Mamelli</surname>
            ,
            <given-names>A.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Papadopoulos</surname>
            ,
            <given-names>G.A.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Paspallis</surname>
            ,
            <given-names>N.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Reichle</surname>
            ,
            <given-names>R.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Stav</surname>
          </string-name>
          , E.:
          <article-title>A comprehensive solution for application-level adaptation</article-title>
          .
          <source>Software: Practice and Experience</source>
          <volume>39</volume>
          (
          <issue>4</issue>
          ),
          <fpage>385</fpage>
          -
          <lpage>422</lpage>
          (
          <year>2009</year>
          ). URL http://dx.doi.org/10.1002/spe.900
        </mixed-citation>
      </ref>
      <ref id="ref9">
        <mixed-citation>
          9.
          <string-name>
            <surname>Gu</surname>
            ,
            <given-names>T.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Pung</surname>
            ,
            <given-names>H.K.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Zhang</surname>
            ,
            <given-names>D.Q.:</given-names>
          </string-name>
          <article-title>A middleware for building context-aware mobile services</article-title>
          .
          <source>In: Vehicular Technology Conference</source>
          ,
          <year>2004</year>
          . VTC 2004-Spring.
          <source>2004 IEEE 59th</source>
          , vol.
          <volume>5</volume>
          , pp.
          <fpage>2656</fpage>
          -
          <lpage>2660</lpage>
          . IEEE (
          <year>2004</year>
          )
        </mixed-citation>
      </ref>
      <ref id="ref10">
        <mixed-citation>
          10. Gu¨nther,
          <string-name>
            <given-names>S.</given-names>
            ,
            <surname>Cleenewerck</surname>
          </string-name>
          ,
          <string-name>
            <given-names>T.</given-names>
            ,
            <surname>Jonckers</surname>
          </string-name>
          ,
          <string-name>
            <surname>V.</surname>
          </string-name>
          :
          <article-title>Software variability: the design space of configuration languages</article-title>
          .
          <source>In: Proceedings of the 6th Workshop on Variability Modeling of SoftwareIntensive Systems</source>
          , pp.
          <fpage>157</fpage>
          -
          <lpage>164</lpage>
          . ACM (
          <year>2012</year>
          )
        </mixed-citation>
      </ref>
      <ref id="ref11">
        <mixed-citation>
          11.
          <string-name>
            <surname>Hewson</surname>
            ,
            <given-names>J.A.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Anderson</surname>
            ,
            <given-names>P.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Gordon</surname>
            ,
            <given-names>A.D.:</given-names>
          </string-name>
          <article-title>A declarative approach to automated configuration</article-title>
          .
          <source>In: LISA</source>
          , vol.
          <volume>12</volume>
          , pp.
          <fpage>51</fpage>
          -
          <lpage>66</lpage>
          (
          <year>2012</year>
          )
        </mixed-citation>
      </ref>
      <ref id="ref12">
        <mixed-citation>
          12. Jong-yi, H., Eui-ho, S.,
          <string-name>
            <surname>Sung-Jin</surname>
            ,
            <given-names>K.</given-names>
          </string-name>
          :
          <article-title>Context-aware systems: A literature review and classification</article-title>
          .
          <source>Expert Systems with Applications</source>
          <volume>36</volume>
          (
          <issue>4</issue>
          ),
          <fpage>8509</fpage>
          -
          <lpage>8522</lpage>
          (
          <year>2009</year>
          ). URL http: //dx.doi.org/10.1016/j.eswa.
          <year>2008</year>
          .
          <volume>10</volume>
          .071
        </mixed-citation>
      </ref>
      <ref id="ref13">
        <mixed-citation>
          13.
          <string-name>
            <surname>Kamina</surname>
            ,
            <given-names>T.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Aotani</surname>
            ,
            <given-names>T.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Masuhara</surname>
            ,
            <given-names>H.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Tamai</surname>
            ,
            <given-names>T.</given-names>
          </string-name>
          :
          <article-title>Context-oriented software engineering: A modularity vision</article-title>
          .
          <source>In: Proceedings of the 13th International Conference on Modularity, MODULARITY '14</source>
          , pp.
          <fpage>85</fpage>
          -
          <lpage>98</lpage>
          . ACM, New York, NY, USA (
          <year>2014</year>
          )
        </mixed-citation>
      </ref>
      <ref id="ref14">
        <mixed-citation>
          14. von Lo¨wis,
          <string-name>
            <given-names>M.</given-names>
            ,
            <surname>Denker</surname>
          </string-name>
          ,
          <string-name>
            <given-names>M.</given-names>
            ,
            <surname>Nierstrasz</surname>
          </string-name>
          ,
          <string-name>
            <surname>O.</surname>
          </string-name>
          :
          <article-title>Context-oriented programming: Beyond layers</article-title>
          .
          <source>In: Proceedings of the 2007 International Conference on Dynamic Languages, ICDL '07</source>
          , pp.
          <fpage>143</fpage>
          -
          <lpage>156</lpage>
          . ACM, NY, USA (
          <year>2007</year>
          ). URL http://dx.doi.org/10.1145/1352678. 1352688
        </mixed-citation>
      </ref>
      <ref id="ref15">
        <mixed-citation>
          15.
          <string-name>
            <surname>Magableh</surname>
            ,
            <given-names>B.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Barrett</surname>
            ,
            <given-names>S.</given-names>
          </string-name>
          :
          <article-title>Primitive component architecture description language</article-title>
          .
          <source>In: Informatics and Systems (INFOS)</source>
          ,
          <year>2010</year>
          The 7th International Conference on, pp.
          <fpage>1</fpage>
          -
          <lpage>7</lpage>
          (
          <year>2010</year>
          )
        </mixed-citation>
      </ref>
      <ref id="ref16">
        <mixed-citation>
          16.
          <string-name>
            <surname>Nadi</surname>
            ,
            <given-names>S.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Berger</surname>
            ,
            <given-names>T.</given-names>
          </string-name>
          , Ka¨stner,
          <string-name>
            <given-names>C.</given-names>
            ,
            <surname>Czarnecki</surname>
          </string-name>
          ,
          <string-name>
            <surname>K.</surname>
          </string-name>
          :
          <article-title>Mining configuration constraints: Static analyses and empirical results</article-title>
          .
          <source>In: Proceedings of the 36th International Conference on Software Engineering, ICSE</source>
          <year>2014</year>
          , pp.
          <fpage>140</fpage>
          -
          <lpage>151</lpage>
          . ACM, New York, NY, USA (
          <year>2014</year>
          ).
          <source>DOI 10</source>
          .1145/ 2568225.2568283. URL http://dx.doi.org/10.1145/2568225.2568283
        </mixed-citation>
      </ref>
      <ref id="ref17">
        <mixed-citation>
          17.
          <string-name>
            <surname>Niu</surname>
            ,
            <given-names>L.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Saiki</surname>
            ,
            <given-names>S.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Matsumoto</surname>
            ,
            <given-names>S.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Nakamura</surname>
            ,
            <given-names>M.:</given-names>
          </string-name>
          <article-title>Wif4inl: Web-based integration framework for indoor location</article-title>
          .
          <source>International Journal of Pervasive Computing and Communications</source>
          (
          <year>2016</year>
          )
        </mixed-citation>
      </ref>
      <ref id="ref18">
        <mixed-citation>
          18.
          <string-name>
            <surname>Raab</surname>
            ,
            <given-names>M.:</given-names>
          </string-name>
          <article-title>A modular approach to configuration storage</article-title>
          .
          <source>Master's thesis</source>
          , Vienna University of Technology (
          <year>2010</year>
          )
        </mixed-citation>
      </ref>
      <ref id="ref19">
        <mixed-citation>
          19.
          <string-name>
            <surname>Raab</surname>
            ,
            <given-names>M.</given-names>
          </string-name>
          :
          <article-title>Global and thread-local activation of contextual program execution environments</article-title>
          .
          <source>In: Proceedings of the IEEE 18th International Symposium on Real-Time Distributed Computing Workshops (ISORCW/SEUS)</source>
          , pp.
          <fpage>34</fpage>
          -
          <lpage>41</lpage>
          (
          <year>2015</year>
          ).
          <source>DOI 10</source>
          .1109/ISORCW.
          <year>2015</year>
          .52
        </mixed-citation>
      </ref>
      <ref id="ref20">
        <mixed-citation>
          20.
          <string-name>
            <surname>Raab</surname>
            ,
            <given-names>M.</given-names>
          </string-name>
          :
          <article-title>Sharing software configuration via specified links and transformation rules</article-title>
          .
          <source>In: Technical Report from KPS</source>
          <year>2015</year>
          , vol.
          <volume>18</volume>
          . Vienna University of Technology, Complang Group (
          <year>2015</year>
          )
        </mixed-citation>
      </ref>
      <ref id="ref21">
        <mixed-citation>
          21.
          <string-name>
            <surname>Raab</surname>
            ,
            <given-names>M.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Puntigam</surname>
            ,
            <given-names>F.</given-names>
          </string-name>
          :
          <article-title>Program execution environments as contextual values</article-title>
          .
          <source>In: Proceedings of 6th International Workshop on Context-Oriented Programming</source>
          , pp.
          <volume>8</volume>
          :
          <fpage>1</fpage>
          -
          <issue>8</issue>
          :
          <fpage>6</fpage>
          . ACM, NY, USA (
          <year>2014</year>
          ). URL http://dx.doi.org/10.1145/2637066.2637074
        </mixed-citation>
      </ref>
      <ref id="ref22">
        <mixed-citation>
          22.
          <string-name>
            <surname>Rabkin</surname>
            ,
            <given-names>A.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Katz</surname>
          </string-name>
          , R.:
          <article-title>Static extraction of program configuration options</article-title>
          .
          <source>In: Software Engineering (ICSE)</source>
          ,
          <year>2011</year>
          33rd International Conference on, pp.
          <fpage>131</fpage>
          -
          <lpage>140</lpage>
          . IEEE (
          <year>2011</year>
          )
        </mixed-citation>
      </ref>
      <ref id="ref23">
        <mixed-citation>
          23.
          <string-name>
            <surname>Riva</surname>
            ,
            <given-names>O.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>di Flora</surname>
            ,
            <given-names>C.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Russo</surname>
            ,
            <given-names>S.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Raatikainen</surname>
            ,
            <given-names>K.</given-names>
          </string-name>
          :
          <article-title>Unearthing design patterns to support context-awareness</article-title>
          .
          <source>In: Pervasive Computing and Communications Workshops</source>
          ,
          <year>2006</year>
          .
          <article-title>PerCom Workshops 2006</article-title>
          . Fourth Annual IEEE International Conference on, pp.
          <volume>5</volume>
          pp.-
          <volume>387</volume>
          (
          <year>2006</year>
          ). URL http://dx.doi.org/10.1109/PERCOMW.
          <year>2006</year>
          .138
        </mixed-citation>
      </ref>
      <ref id="ref24">
        <mixed-citation>
          24.
          <string-name>
            <surname>Salvaneschi</surname>
            ,
            <given-names>G.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Ghezzi</surname>
            ,
            <given-names>C.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Pradella</surname>
            ,
            <given-names>M.</given-names>
          </string-name>
          :
          <article-title>Context-oriented programming: A software engineering perspective</article-title>
          .
          <source>Journal of Systems and Software</source>
          <volume>85</volume>
          (
          <issue>8</issue>
          ),
          <fpage>1801</fpage>
          -
          <lpage>1817</lpage>
          (
          <year>2012</year>
          ). URL http://dx.doi.org/10.1016/j.jss.
          <year>2012</year>
          .
          <volume>03</volume>
          .024
        </mixed-citation>
      </ref>
      <ref id="ref25">
        <mixed-citation>
          25.
          <string-name>
            <surname>Schaefer</surname>
            ,
            <given-names>I.</given-names>
          </string-name>
          , Ha¨hnle, R.:
          <article-title>Formal methods in software product line engineering</article-title>
          .
          <source>IEEE Computer 44(2)</source>
          ,
          <fpage>82</fpage>
          -
          <lpage>85</lpage>
          (
          <year>2011</year>
          )
        </mixed-citation>
      </ref>
      <ref id="ref26">
        <mixed-citation>
          26.
          <string-name>
            <surname>Schippers</surname>
            ,
            <given-names>H.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Molderez</surname>
            ,
            <given-names>T.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Janssens</surname>
            ,
            <given-names>D.:</given-names>
          </string-name>
          <article-title>A graph-based operational semantics for contextoriented programming</article-title>
          .
          <source>In: Proceedings of the 2Nd International Workshop on ContextOriented Programming</source>
          ,
          <source>COP '10</source>
          . ACM, NY, USA (
          <year>2010</year>
          ).
          <source>DOI 10</source>
          .1145/1930021.1930027. URL http://dx.doi.org/10.1145/1930021.1930027
        </mixed-citation>
      </ref>
      <ref id="ref27">
        <mixed-citation>
          27.
          <string-name>
            <surname>Tanter</surname>
          </string-name>
          , E.:
          <article-title>Contextual values</article-title>
          .
          <source>In: Proceedings of the 2008 Symposium on Dynamic Languages, DLS '08</source>
          , pp.
          <volume>3</volume>
          :
          <fpage>1</fpage>
          -
          <lpage>3</lpage>
          :
          <fpage>10</fpage>
          . ACM, NY, USA (
          <year>2008</year>
          ).
          <source>DOI 10</source>
          .1145/1408681.1408684. URL http://dx.doi.org/10.1145/1408681.1408684
        </mixed-citation>
      </ref>
      <ref id="ref28">
        <mixed-citation>
          28.
          <string-name>
            <surname>Yin</surname>
            ,
            <given-names>Z.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Ma</surname>
            ,
            <given-names>X.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Zheng</surname>
            ,
            <given-names>J.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Zhou</surname>
            ,
            <given-names>Y.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Bairavasundaram</surname>
            ,
            <given-names>L.N.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Pasupathy</surname>
            ,
            <given-names>S.:</given-names>
          </string-name>
          <article-title>An empirical study on configuration errors in commercial and open source systems</article-title>
          .
          <source>In: Proceedings of the Twenty-Third ACM Symposium on Operating Systems Principles, SOSP '11</source>
          , pp.
          <fpage>159</fpage>
          -
          <lpage>172</lpage>
          . ACM, New York, NY, USA (
          <year>2011</year>
          ).
          <source>DOI 10</source>
          .1145/2043556.2043572
        </mixed-citation>
      </ref>
      <ref id="ref29">
        <mixed-citation>
          29.
          <string-name>
            <surname>Yuan</surname>
            ,
            <given-names>D.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Park</surname>
            ,
            <given-names>S.</given-names>
          </string-name>
          ,
          <string-name>
            <surname>Zhou</surname>
            ,
            <given-names>Y.</given-names>
          </string-name>
          :
          <article-title>Characterizing logging practices in open-source software</article-title>
          .
          <source>In: Proceedings of the 34th International Conference on Software Engineering, ICSE '12</source>
          , pp.
          <fpage>102</fpage>
          -
          <lpage>112</lpage>
          . IEEE Press, Piscataway, NJ, USA (
          <year>2012</year>
          ). URL http://dl.acm.org/citation. cfm?id=
          <volume>2337223</volume>
          .
          <fpage>2337236</fpage>
        </mixed-citation>
      </ref>
    </ref-list>
  </back>
</article>