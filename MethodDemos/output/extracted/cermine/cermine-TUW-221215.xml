<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
  <front>
    <journal-meta />
    <article-meta>
      <title-group>
        <article-title>Selective Graph Coloring Problem</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <string-name>zur Erlangung des akademischen Grades</string-name>
          <xref ref-type="aff" rid="aff0">0</xref>
        </contrib>
        <aff id="aff0">
          <label>0</label>
          <institution>Technische Universität Wien A-1040 Wien ▪ Karlsplatz 13 ▪ Tel</institution>
        </aff>
      </contrib-group>
      <pub-date>
        <year>2005</year>
      </pub-date>
      <volume>19</volume>
      <fpage>337</fpage>
      <lpage>343</lpage>
      <abstract>
        <p>Claus-Dieter Volko an der Fakultät für Informatik der Technischen Universität Wien</p>
      </abstract>
    </article-meta>
  </front>
  <body>
    <sec id="sec-1">
      <title>-</title>
      <p>Diplom-Ingenieur
im Rahmen des Studiums
Computational Intelligence</p>
      <p>eingereicht von</p>
      <p>(Unterschrift Betreuer/in)</p>
      <p>Erklärung zur Verfassung der Arbeit
Hiermit erkläre ich, dass ich diese Arbeit selbständig verfasst habe, dass ich die verwendeten
Quellen und Hilfsmittel vollständig angegeben habe und dass ich die Stellen
der Arbeit - einschließlich Tabellen, Karten und Abbildungen -, die anderen Werken
oder dem Internet im Wortlaut oder dem Sinn nach entnommen sind, auf jeden Fall unter
Angabe der Quelle als Entlehnung kenntlich gemacht habe.
______________________</p>
      <p>______________________________________________
(Ort, Datum)</p>
      <p>(Unterschrift Verfasser)
Ich möchte mich vor allem bei Günther Raidl für die Möglichkeit bedanken, meine Diplomarbeit an
seiner Abteilung zu verfassen, und bei Bin Hu für die ausgezeichnete Betreuung.</p>
      <p>Weiters möchte ich mich bei meinen Eltern bedanken, die mir das Studium finanziell ermöglicht
haben. Zudem habe ich ihnen auch zu verdanken, dass sie mein Interesse an Computern frühzeitig
erkannt und gefördert haben.
The Selective Graph Coloring Problem (SGCP) is about finding a subgraph of a particular structure
whose chromatic number is as low as possible. The original graph is divided into several clusters, and
from each cluster the subgraph has to contain exactly one node. This problem is NP-hard and
therefore it is usually solved by means of heuristics.</p>
      <p>I implemented several variants of an algorithm making use of Variable Neighborhood Search (VNS) to
search the space of solution candidates and then evaluating the solution using heuristic or exact
methods. Furthermore, each variant can be used with or without a solution archive, i.e. a data
structure in which previously found solutions are stored so that duplicates need not be re-evaluated
but can be efficiently converted into new solutions instead. For exact computation of the chromatic
number integer linear programming was used. To obtain an upper bound a variant of greedy coloring
was used. Another variant of the algorithm also counts the number of conflicts that would appear if
one color less were used. Finally, two methods were implemented to obtain a lower bound:
maximum clique and linear programming using column generation.</p>
      <p>The program was tested with various instances from the literature. My algorithm often finished
computation within a very short time, but in general it led to slightly worse results.
Beim Selective Graph Coloring Problem (SGCP) geht es darum, einen Teilgraphen mit spezieller
Struktur zu finden, dessen chromatische Zahl so niedrig wie möglich ist. Der Ursprungsgraph ist in
mehrere Cluster unterteilt, und von jedem Cluster muss der Teilgraph genau einen Knoten enthalten.
Dieses Problem ist NP-schwer und wird daher meistens mit Heuristiken gelöst.</p>
      <p>Ich habe mehrere Varianten eines Algorithmus implementiert, der Variable Neighborhood Search
(VNS) benutzt, um den Lösungsraum zu durchsuchen, und dann die gefundene Lösung mit
heuristischen oder exakten Methoden evaluiert. Jede Variante kann mit oder ohne ein Lösungsarchiv
verwendet werden. Ein Lösungsarchiv ist eine Datenstruktur, in der bereits gefundene Lösungen
gespeichert werden, so dass Duplikate nicht neu evaluiert werden müssen, sondern effizient zu
neuen Lösungen konvertiert werden können. Um eine obere Schranke zu errechnen, wurde eine
Variante von Greedy Coloring verwendet. Eine weitere Variante des Algorithmus zählt auch die
Anzahl der Konflikte, die entstünden, würde eine Farbe weniger verwendet werden. Schließlich
wurden zwei Methoden umgesetzt, um eine untere Schranke zu berechnen: maximale Clique und
lineare Programmierung mit Spaltengenerierung.</p>
      <p>Das Programm wurde mit verschiedenen Instanzen aus der Literatur getestet. Mein Algorithmus
beendete die Berechnungen oft schon nach sehr kurzer Laufzeit, führte aber im Allgemeinen zu
geringfügig schlechteren Ergebnissen.</p>
    </sec>
    <sec id="sec-2">
      <title>Contents</title>
      <sec id="sec-2-1">
        <title>Contents</title>
      </sec>
      <sec id="sec-2-2">
        <title>6 Conclusions</title>
      </sec>
      <sec id="sec-2-3">
        <title>List of Algorithms List of Tables</title>
        <p>2 Literature Survey 7
2.1 Selective Graph Coloring Problem and Routing and Wavelength</p>
        <p>Assignment Problem . . . . . . . . . . . . . . . . . . . . . . . . 7
2.2 Graph Coloring . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
4 Testing Environment</p>
        <sec id="sec-2-3-1">
          <title>Chapter 1</title>
        </sec>
      </sec>
    </sec>
    <sec id="sec-3">
      <title>Introduction</title>
      <p>Graphs are a useful tool for modelling real-world problems, as they can serve as
an abstraction for various things, such as networks and maps. For this reason,
the solution of problems related to graph theory may have an impact in real
life. Computer science students usually learn about some of these problems as
well as algorithms for solving them in advanced courses on algorithmics. Topics
commonly discussed in these courses include shortest path problems, finding the
maximal flow in a network, and the Traveling Salesperson Problem. Depth First
Search, Breadth First Search, Dijkstra’s algorithm, the Bellman-Ford algorithm,
the Floyd-Warshall algorithm, Johnson’s algorithm, the Ford-Fulkerson method,
preflow-push algorithms and other methods belong to the general education of
any computer scientist specializing in algorithms.</p>
      <p>Graph coloring usually does not appear in these courses, but it is still an
important problem about which many papers have been published. Applications
of graph coloring include time tabling and various forms of allocation tasks [10].
Since it is an NP-equivalent problem, various heuristics have been proposed to
get good results in a reasonable amount of time. The selective graph coloring
problem is an extension of graph coloring and for this reason, it is NP-hard as
well. It is about finding a subgraph consisting of one node of each cluster that
has a chromatic number as low as possible. For most researchers the motivation
to study this problem has been its relevance to optical networks [39]. Although
some papers have been published that propose efficient solution algorithms for
this problem, by far not all possible solution algorithms have been explored yet.
This was my motivation for choosing this problem as the topic of my diploma
thesis.</p>
      <p>In this thesis, I will present diverse variants of a heuristic solution algorithm for
the selective graph coloring problem and the results obtained for some test
instances. The algorithm is based on variable neighborhood search for scanning
the solution space. Each solution is evaluated using exact or heuristic methods.
The exact method is exact but slow. Regarding heuristics mainly an upper bound
is computed, but there are also variants calculating a number of conflicts that
would arise with one color less and giving a lower bound. In addition a solution
archive has been implemented, which makes it possible to avoid duplicates during
the search space exploration and easily find new solutions not evaluated as local
optima yet.
The selective graph coloring problem (SGCP) is a graph theory problem. Graph
theory deals with an abstract formalism that can be used to represent various
realworld structures, such as networks (e.g. telephone networks) or traffic structures.
A graph is a structure that consists of two sets, a set of nodes and a set of edges.
A node is an abstract entity which may represent anything, e.g. a telephone. It is
worth mentioning that the spatial structure of the graph is irrelevant. The nodes
may be located anywhere in space. It is not important where they are located or
how distant they are to each other. Edges are connections between nodes. Each
edge connects two distinct nodes. In the real world, an edge may correspond to
a line connecting two telephones, for example.</p>
      <p>Graphs may be directed or undirected. If a graph is directed, this means that
each edge has a node for which it is an outgoing edge, and a node for which it
is an incoming edge. In this case, edges are also called arcs. However, the SGCP
deals only with undirected graphs. In undirected graphs the two nodes of each
1.2. APPLICATIONS
edge are of equal value.
Edges may have weights, that is values assigned to them. This plays a role
in many graph theoretical problems, but not in the SGCP. As a consequence we
do not consider edge weights in the SGCP.</p>
      <p>In the SGCP nodes may be colored. That is, each node is assigned one color.
What is important is that in a proper coloring, there must not be a pair of two
nodes sharing an edge that have the same color. This is the main obstacle for
finding a solution to the SGCP.</p>
      <p>In the graph coloring problem, an undirected graph is given, and the objective
is to determine the minimal number of colors that is needed to gain a proper
coloring of the graph. This number is also called the chromatic number of the
graph. The difference to the SGCP is that all nodes must be considered. In the
SGCP, by contrast, each node is assigned to a cluster. The objective is to find
a subgraph of the given graph which consists of one node per cluster, i.e. from
each cluster exactly one node per cluster is taken. This subgraph must have a low
chromatic number, in the optimal case the minimal chromatic number possible.
1.2</p>
      <p>Applications
According to the literature [39], an application of the selective graph coloring
problem is the routing and wavelength assignment (RWA) problem in optical
networks. In such a network two edges (also called lightpaths) may use the same
wavelength if they do not share a common link. Therefore the problem is dual
to graph coloring, as edges instead of vertices are assigned colors. The optimal
assignment of wavelengths in such a network can thus be obtained by solving a
related instance of the selective graph coloring problem.
1.3</p>
      <p>
        Formal Definition and Complexity
Given is an unweighted, undirected graph G =&lt; V, E &gt; with a set of nodes V and
a set of edges E. Each node is assigned to one subgraph, a so-called cluster Ci.
In total there are n disjoint clusters. The goal is to find a subgraph S = G(W )
with W =&lt; v1, ..., vn &gt; where vi ∈ Ci, 1 ≤ i ≤ n. The subgraph should have
a minimal chromatic number. The chromatic number is the minimal number of
different colors using which the nodes of a graph can be colored so that there is no
single pair of nodes u and v connected by an edge (u, v) that have the same color.
Thus, the SGCP is an extension of the graph coloring problem, which computer
scientists and mathematicians have studied for decades. The Graph Coloring
Problem is about computing the chromatic number of a given graph, and already
in 1972 it was discovered to be an NP-equivalent problem [
        <xref ref-type="bibr" rid="ref2">3</xref>
        ]. Since the Graph
Coloring Problem is a subproblem of the selective graph coloring problem, the
selective graph coloring problem is NP-hard as well. For this reason it makes sense
to use a heuristic approach both to estimate the chromatic number of a possible
solution and to find a better solution.
      </p>
      <sec id="sec-3-1">
        <title>Chapter 2</title>
      </sec>
    </sec>
    <sec id="sec-4">
      <title>Literature Survey</title>
      <p>This chapter provides an overview of the literature about the selective graph
coloring problem as well as graph coloring.
2.1</p>
      <p>Selective Graph Coloring Problem and</p>
      <p>Routing and Wavelength Assignment Problem
In the literature, the selective graph coloring problem is sometimes also called the
partition graph coloring problem.</p>
      <p>
        Frota et al. [39] present a branch-and-cut algorithm for the partition graph
coloring problem. It is based on an integer linear programming formulation that
generalizes the 0-1 formulation for the graph coloring problem presented in [
        <xref ref-type="bibr" rid="ref7">28</xref>
        ]
and [29]. With a branching strategy the Partition Graph Coloring Problem is
decomposed in two subproblems, and the linear relaxation bound is improved by
means of inequalities.
      </p>
      <p>In an earlier publication Li et al. [22] proved that the selective graph coloring
problem is as hard as standard vertex coloring. They also proposed extensions
of well-known vertex coloring heuristics to the partition coloring problem and
applied these heuristics to some instances of the routing and wavelength assignment
problem. This paper also cites a lot of papers that deal with theoretical aspects
of the routing and wavelength assignment problem.</p>
      <p>Noronha et al. [34] propose a heuristic for solving the Partition Graph
Coloring Problem based on tabu search.</p>
      <p>The paper by Choi et al. [23] reviews various algorithms for solving the
routing and wavelength assignment problem. We can learn from this paper that there
are actually two types of algorithms: the ones assuming static traffic either have
the objectivity to “minimize the required number of wavelengths in order to
ac</p>
      <p>CHAPTER 2. LITERATURE SURVEY
commodate a given set of connections” (this corresponds to the SGCP) or to
“maximize the number of connections accommodated if the number of
wavelengths is limited”. The other type of algorithms assumes dynamic traffic, which
means that “connection requests arrive to and depart from the network one by
one in a random manner” and the objective is to “minimize the blocking
probability”. This shows that routing and wavelength assignment actually comprises
more problems than just selective graph coloring. However, the paper focuses
on the problem variants that are related to selective graph coloring. It breaks
the problem down into two subproblems, each of them being NP-complete. The
“routing problem” is nothing but the problem to search for a subgraph that
hopefully yields a small chromatic number. The paper states that diverse variants of
shortest path algorithms are most commonly used for this problem. Regarding
the problem of selecting a solution, the paper mentions two classes of methods:
sequential selection (by means of greedy algorithms) and combinatorial selection.
2.2</p>
      <p>
        Graph Coloring
A large number of papers have been published on graph coloring. One of the oldest
that is still frequently cited is [
        <xref ref-type="bibr" rid="ref2">3</xref>
        ], in which the author proved (among many other
things) that the graph coloring problem is NP-equivalent. Another one of the early
papers is [
        <xref ref-type="bibr" rid="ref3">5</xref>
        ], in which the author proposes a greedy algorithm for graph coloring
(recursive largest first algorithm) that yields better results than the algorithms for
this problem known before (such as the randomly ordered sequential algorithm,
the largest first algorithm, the smallest last algorithm, interchange algorithms and
the approximately maximum independent set algorithm). This algorithm is still
used nowadays, as the paper [43] shows, which presents an efficient
implementation of it. The basic idea of the RLF algorithm is that in each iteration it selects
(if possible) a node that is not adjacent to any colored node and that is connected
to the largest number of uncolored nodes that are adjacent to some colored node.
If that is not possible, the process is repeated recursively on the subgraph induced
by the uncolored nodes.
      </p>
      <p>A more recent classic paper is [10], in which Mehrotra and Trick propose an
approach to graph coloring that is based on integer linear programming and makes
use of a technique called column generation. With this technique it is possible to
obtain an exact solution more efficiently since at first only a part of the problem is
added to the integer linear program and then, depending on the results of a dual
program, it is decided whether the primal program is expanded. This approach
can also be used for computing lower bounds by means of a linear relaxation.
The paper [42] is based on Mehrotra’s and Trick’s approach and presents an
implementation of it which is supposed to provide “numerically safe results,
independent of the floating-point accuracy of the linear programming software used”.
2.2. GRAPH COLORING
The technique of column generation is also used in [44].</p>
      <p>Hertz et al. [37] propose a novel heuristic algorithm for graph coloring which they
call variable space search. It is a variant of local search which considers “several
search spaces, with various neighborhoods and objective functions”. Whenever
the search does not manage to overcome a local optimum, the algorithm moves
from one search space to another. The algorithm actually does not try to compute
the chromatic number, but it tries whether a graph can be colored with a given
number of colors k. Thus several runs are needed in order to determine a tight
upper bound for the chromatic number.</p>
      <p>Lue et al. [41] introduce a memetic algorithm for graph coloring, that is a heuristic
algorithm that combines an evolutionary algorithm with more traditional types of
heuristics. A genetic algorithm is also used by [24], in combination with a column
generation technique.</p>
      <p>All the algorithms for graph coloring can be used in programs that try to solve the
selective graph coloring problem, for the subproblem of determining the chromatic
number of a solution. In order to come up with new solutions, a large number
of metaheuristics can be used. For this reason, there is an enormous number of
different approaches for the selective graph coloring problem that may lead to
success. Therefore we can expect that researchers are yet going to publish a lot
of papers dealing with the SGCP.</p>
      <sec id="sec-4-1">
        <title>Chapter 3</title>
      </sec>
    </sec>
    <sec id="sec-5">
      <title>Methods</title>
      <p>In this chapter I am going to present all the methods for solving the SGCP I have
implemented. This also includes a couple of methods which I decided to abandon
after the first test runs because they turned out to be too inefficient.
Basically, I use the variable neighborhood search (VNS) metaheuristic to search
the solution space and various exact as well as heuristic methods to evaluate the
solutions. Evaluating a solution basically means to obtain either the exact value or
an approximation of its chromatic number. For this purpose I have implemented
an exact method using integer linear programming as well as several heuristics
determining upper and lower bounds.</p>
      <p>There are various approaches to estimate the chromatic number of a graph. One
of them is to compute an upper bound by means of a graph coloring algorithm.
In order to determine whether a new solution is better than the currently best
known solution, it makes sense to additionally compute a couple of other
parameters apart from the upper bound. One option is to compute a lower bound, so
that a solution is considered the better one if it has the same upper bound, but
a smaller lower bound. Another possibility is to compute the number of conflicts
that would occur if the graph was colored using one color less than estimated by
the greedy coloring algorithm. If two solutions have the same upper bound, it
makes sense to prefer the one with the lower number of conflicts.
Since I was interested in an efficient exploration of the search space (I aimed for an
execution time not exceeding 10 minutes per instance), I chose a greedy coloring
algorithm for the upper bound. It has a polynomial run time with regard to the
number of nodes since each node is assigned a color only once, and to determine
the color of a node only each neighboring node needs to be considered once. For
computing the number of conflicts if one color less were used, each node needs to
be visited only once after the graph coloring algorithm has been executed, so the
conflict determination algorithm has linear run time with respect to the number
of nodes. What is more costly is the computation of a (reasonable) lower bound.
One (straight-forward but very inefficient) method for this is to compute the size
of the maximal clique in the graph, which has an exponential run time in terms
of the number of nodes. Known more efficient approaches utilize linear
programming with column generation, but they are not polynomial time algorithms, either.
It is also possible to compute the exact value of the chromatic number by means
of integer linear programming, but due to the NP-hardness of this variant it is
only feasible for instances with a rather low number of nodes. For other instances
it takes far too long.</p>
      <p>All variants of the algorithm can be enhanced by a solution archive, which is
an efficient way to check whether a solution has already been discovered and
evaluated once. If a duplicate is found, it does not have to be regarded again
and a new solution can be easily computed using a converting function. During
tests, however, the solution archive has not led to a significant improvement of
the quality of solutions.
3.1</p>
      <p>Metaheuristics
What are metaheuristics? In his book [38], Sean Luke defines them as a
“major subfield” of stochastic optimization, which is “the general class of algorithms
and techniques which employ some degree of randomness to find optimal (or as
optimal as possible) solutions to hard problems”. They are applied to “I know it
when I see it” problems. These are problems in which it is not easy to find the
optimal (or even a good) solution, but if you have a solution, you can test it and
see how good it is.</p>
      <p>
        Basically metaheuristics are methods of exploring some defined solution space.
They do not guarantee that you will find the optimal solution, but they are
supposed to make you find solutions that come close to the optimum. Usually the
solution space contains various local optima. For a good metaheuristic it is
important to be able to overcome local optima since an algorithm that gets stuck with
some local optimum will most likely not find the global optimum. According to the
No Free Lunch Theorem [11], the outputs of the various kinds of metaheuristics in
general are statistically identical. This is because good solutions are usually
scattered all about the search space due to the high degree of Kolmogorov randomness
almost all objective functions have [
        <xref ref-type="bibr" rid="ref4">25</xref>
        ]. Therefore, various metaheuristics can be
used for the same problem with similar chances of obtaining good results in a
reasonable time. And yet, some metaheuristics may be particularly suitable for
some special problems.
3.1. METAHEURISTICS
3.1.1
      </p>
      <p>Solution Representation
A valid solution of the SGCP is a subgraph S = G(W ), W =&lt; v1, ..., vn &gt; that
consists of n nodes which are all elements of the set of nodes V of the graph G.
Each of these n nodes must be part of a different cluster within G. Since there
are exactly n clusters, this means that the solution subgraph contains exactly one
node per cluster. Moreover, the edges that connect these nodes are part of the
solution subgraph.</p>
      <p>For this reason, it makes sense to encode the solution as an array of integer
values. Bounds and/or the exact value of the chromatic number are stored in
separate variables.
3.1.2</p>
      <p>Initialization
After loading the graph from a file or, alternatively, generating a new, random
graph, the program has to find an initial solution to start with. Of course it could
simply choose a random node from the set of nodes of each cluster. But this
approach would probably not often yield to a good solution. To come up with a
better initial solution, I devised and implemented the following greedy
construction heuristics:
For the first cluster, select a random node from its set of nodes. Then select
the nodes for the other clusters in ascending order. Always compute the degree
of each node within the solution subgraph and select one of the nodes that have
the lowest degree.</p>
      <p>This ensures that the maximal degree of the nodes in the initial solution is rather
small. My hypothesis is that the smaller the degree of the maximal nodes, the
more likely will it be possible to achieve a good value for the chromatic number.
As I will explain later, the maximal degree of a graph plus one is an upper bound
of its chromatic number, although usually not a very tight one.</p>
      <p>Algorithm 1 provides pseudocode that demonstrates how the initialization
procedure works.
Algorithm 1: Initialization
select random node of cluster C0;
for i = 1, . . . , number of clusters - 1 do
bestIdx = 0;
bestCnt = 0;
for x ∈ nodes of cluster i do
if degree of node x &lt; bestCnt then
bestIdx = x;
bestCnt = degree of node x;
select node with index bestIdx from the set of nodes of cluster i;
3.1.3</p>
      <p>Local Search
Local search is a very simple metaheuristic which the more sophisticated variable
neighborhood descent makes use of. Basically, the heuristic scans through all the
solutions that are neighbors to a given initial solution. For example, the set of
neighbors may be the set of all solutions in which for one single cluster a different
node has been chosen than in the initial solution. The aim of local search is to find
a solution that is better than the initial solution. Upon finding such a solution,
another iteration of local search may be done, with the new solution acting as the
initial solution. The algorithm stops when no further improvement is possible.
In general there are three different strategies for local search. The one I used
is called first improvement. As soon as local search finds a solution that is better
than the initial solution, it stops. The initial solution is then overwritten by the
new (better) solution and a new iteration may be performed. Another strategy is
best improvement. An algorithm that is based on this strategy scans the entire
neighbor space and stores a pointer to the best solution, i.e. a local optimum.
Then this local optimum is used as the initial solution for the next iteration. A
third strategy is simply to choose a random neighbor.</p>
      <p>In my program the neighborhoods differ by the number of nodes that are
exchanged. In neighborhood number k, new nodes for k clusters are chosen.</p>
      <p>Algorithm 2 shows in pseudocode how local search with first improvement works.</p>
      <p>Instance
n100p5t2s1
n100p5t2s2
n100p5t2s3
n100p5t2s4
n100p5t2s5</p>
      <p>Method
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
Instance
n120p5t2s1
n120p5t2s2
n120p5t2s3
n120p5t2s4
n120p5t2s5</p>
      <p>Method
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA</p>
      <p>Instance
n90p1t2s1
n90p1t2s2
n90p1t2s3
n90p1t2s4
n90p1t2s5</p>
      <p>Method
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
Instance
n90p2t2s1
n90p2t2s2
n90p2t2s3
n90p2t2s4
n90p2t2s5</p>
      <p>Method
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA</p>
      <p>Instance
n90p3t2s1
n90p3t2s2
n90p3t2s3
n90p3t2s4
n90p3t2s5</p>
      <p>Method
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA</p>
      <p>Instance
n90p4t2s1
n90p4t2s2
n90p4t2s3
n90p4t2s4
n90p4t2s5
t (s)
602.0
606.7
1.4
1.4
1.4
1.2
624.7
623.0
1.4
1.4
1.2
1.2
602.3
608.3
1.4
1.4
1.3
1.3
604.7
604.0
1.2
1.2
1.2
1.2
613.7
601.0
1.5
1.3
1.6
1.6</p>
      <p>Instance
n90p5t2s1
n90p5t2s2
n90p5t2s3
n90p5t2s4
n90p5t2s5</p>
      <p>Method
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
Instance
n90p6t2s1
n90p6t2s2
n90p6t2s3
n90p6t2s4
n90p6t2s5</p>
      <p>Method
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA</p>
      <p>Instance
n90p7t2s1
n90p7t2s2
n90p7t2s3
n90p7t2s4
n90p7t2s5</p>
      <p>Method
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
Instance
n90p8t2s1
n90p8t2s2
n90p8t2s3
n90p8t2s4
n90p8t2s5</p>
      <p>Method
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA</p>
      <p>Instance
n90p9t2s1
n90p9t2s2
n90p9t2s3
n90p9t2s4
n90p9t2s5</p>
      <p>Method
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA</p>
      <p>Instance
dsjc500.5-1
dsjc500.5-2
dsjc500.5-3
dsjc500.5-4
Method
Greedy Coloring
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
UB+C+LB
UB+C+LB+SA
UB+C
UB+C+SA
UB
UB+SA
5.2. DISCUSSION AND FINAL RESULTS</p>
      <p>Discussion and Final Results
Since the results of Frota’s and Noronha’s algorithms are better than the results
of my algorithm most of the time, I made investigations for what might be the
reason. The first guess was that perhaps the greedy coloring is not optimal. Alas,
for test instances with 20, 40 and 60 nodes the upper bound the greedy coloring
computed matched the exact chromatic number of the solution which the
algorithm considered the best one (see table 5.17). For instances with more nodes
it was not possible to make this comparison since the exact computation took
too long. But if we take a look at dsjc500.5-1, we see that Noronha’s algorithm
performed better than my variant of greedy coloring. This leads to the conclusion
that greedy coloring is probably good for instances with a low number of nodes,
but the more nodes are used, the worse it performs. This opens a possibility for
further research, trying the same VNS with a different heuristic. It is also possible
that even with instances with a rather small number of nodes, greedy coloring
leads to a suboptimal result since it may select a solution although another
solution having the same upper bound would have a lower exact chromatic number.
What was also tried was a modification of the parameters: instead of five
consecutive failing VND runs (not leading to an improvement), twenty were allowed
(table 5.18). The time limit was accordingly increased to 1800 seconds, but it
was only reached in Noronha’s instances. However, the results are not all too
different. This has brought me to the conclusion that a further increase of the
number of consecutive failing VND runs will probably not lead to any (significant)
improvement; five consecutive failing VND runs seem to suffice.</p>
      <p>Instance
n20p5t2s1
n40p5t2s1
n60p5t2s1</p>
      <p>UB+C
3
5
6
Instance(s)
n20p5t2s*
n40p5t2s*
n60p5t2s*
n80p5t2s*
n100p5t2s*
n120p5t2s*
dsjc500.5-1
dsjc500.5-2
dsjc500.5-3
dsjc500.5-4
Method
UB+C
UB+C
UB+C
UB+C
UB+C
UB+C
UB+C
UB+C
UB+C</p>
      <sec id="sec-5-1">
        <title>Chapter 6</title>
      </sec>
    </sec>
    <sec id="sec-6">
      <title>Conclusions</title>
      <p>Within this work I developed and implemented diverse variants of an algorithm
that solves the selective graph coloring problem. The thesis first defines the
problem, introduces a practical application and discusses the complexity of the chosen
approach. After a literature survey on both the SGCP and graph coloring in
general, the algorithmic approach is discussed in detail. This discussion starts with
an introduction to metaheuristics, especially the ones used in this algorithm
(variable neighborhood descent and variable neighborhood search). Then the solution
representation is described, followed by different ways of evaluating the solution.
Both heuristic approaches (upper bound, number of conflicts, lower bound) and
an exact method (integer linear programming) are presented. Moreover, the
chosen approach for a solution archive is discussed. After an outline of the complete
algorithm, the testing environment is described, and then the results of the tests
performed on the chosen instances are listed.</p>
      <p>
        The results have in general been not as good as expected: The performance of the
algorithm is not quite comparable to the solutions of other researchers. This may
be due to the greedy coloring heuristic used, so further research should focus on
trying other heuristics. At least the implementation has shown that computing a
lower bound of the chromatic number in addition to the upper bound (where the
upper bound is the primary evaluation criterion, in case of identical upper bounds
the number of conflicts is considered, and if these are still the same the solution
with the smaller lower bound is preferred) is time-consuming and does not lead
to a significant improvement, if at all. Solution archives have not proven effective
either. So the method using upper bound and number of conflicts as evaluation
criteria seems to be the best strategy.
[
        <xref ref-type="bibr" rid="ref1">1</xref>
        ]
      </p>
      <p>R. Brooks and W. Tutte. On colouring the nodes of a network. Proceedings
of the Cambridge Philosophical Society, volume 37, issue 2, pages 194-197,
1941.</p>
      <p>J. Brown: Chromatic scheduling and the chromatic number problem.
Management Science, volume 19, issue 4, pages 456-463, 1972.</p>
      <p>R. Karp: Reducibility Among Combinatorial Problems. Complexity of
Computer Computations, pages 85-103, 1972.</p>
      <p>K. Appel and W. Haken: Every Planar Map is Four Colorable. Illinois Journal
of Mathematics, volume 21, pages 429-567, 1977.</p>
      <p>F. Leighton: A Graph Coloring Algorithm for Large Scheduling Problems.
Journal of Research of the National Bureau of Standards, volume 84, issue
6, pages 489-506, 1979.</p>
      <p>J. Peem¨oller: A correction to Brelaz’s modification of Brown’s coloring
algorithm. Communications of the ACM, volume 26, issue 8, pages
593597, 1983.</p>
      <p>M. Kubale and B. Jackowski: A generalized implicit enumeration algorithm
for graph coloring. Communications of the ACM, volume 28, issue 4, pages
412-418, 1985.</p>
      <p>A. Hertz, D. de Werra: Using Tabu Search Techniques for Graph Coloring.
Computing, volume 39, pages 345-351, 1987.</p>
      <p>P. Raghavan and E. Upfal: Efficient routing in all-optical networks. Proc
26th ACM Symp. on Theory of Computing, pages 134-143, New York, 1994.
[10] A. Mehrotra and M. Trick: A Column Generation Approach For Graph</p>
      <p>Coloring. INFORMS Journal on Computing, volume 8, pages 344-354, 1995.
[11] D. Wolpert and W. Macready: No Free Lunch Theorems for Search.
Technical Report SFI-TR-95-02-010 (Santa Fe Institute), 1995.
[12] C. Morgenstern: Distributed Coloration Neighborhood Search. DIMACS
Series in Discrete Mathematics and Theoretical Computer Science, volume
26, pages 335-357, 1996.
[13] R. Ramaswami and K. Sivarajan: Routing and wavelength assignment in
alloptical networks. IEEE/ACM Trans. Networking, volume 3, issue 5, pages
489-500, 1995.
[14] C. Fleurent and J. Ferland: Genetic and hybrid algorithms for graph coloring.</p>
      <p>Annals of Operations Research, volume 63, issue 3, pages 437-461, 1996.
[15] B. Mukherjee: Some principles for designing a wide-area WDM optical
network. IEEE/ACM Trans. Networking, volume 4, issue 5, pages 684-696,
1996.
[16] N. Mladenovic and P. Hansen: Variable neighborhood search. Computers
and Operations Research, volume 24, issue 11, pages 1097-1100, 1997.
[17] E. Harder: Routing and wavelength assignment in all-optical WDM
wavelength-routed networks, PhD thesis, George Washington University,
1998.
[18] R. Ramaswami and K. Sivarajan:</p>
      <p>Morgan-Kaufmann, 1998.</p>
      <p>Optical communication networks,
[19] P. Galinier and J. Hao: Hybrid Evolutionary Algorithms for Graph Coloring.</p>
      <p>Journal of Combinatoral Optimization, volume 3, issue 4, pages 379-397,
1999.
[20] B. Narahari et al.: Routing and Scheduling I/O Transfers on
WormholeRouted Mesh Networks. J. Parallel and Distributed Computing, volume 57,
issue 1, pages 1-13, 1999.
[21] J. Brimberg et al.: Improvements and comparison of heuristics for solving
the multisource Weber problem. Operational Research, issue 48, pages
444460, 2000.
[22] G. Li and R. Simha: The Partition Coloring Problem and its Application to
Wavelength Routing and Assignment. Proceedings of the First Workshop
on Optical Networks, 2000.
[23] J. Choi et al.: A functional classification of routing and wavelength
assignment schemes in DWDM networks: Static case. Proceedings of the 7th
International Conference on Optical Communication and Networks, pages
1109-1115, Paris, 2000.
[24] G. Filho et al.: Constructive Genetic Algorithm and Column Generation: an
Application to Graph Coloring, paper published on the Internet, 2000.
[30] C. Desrosiers, P. Galinier and A. Hertz: Efficient algorithms for finding
critical subgraphs. Discrete Applied mathematics, volume 156, issue 2, pages
244-266, 2005.
[31] A. Hertz, P. Galinier and N. Zufferey: An Adaptive Memory Algorithm for
the Graph Coloring Problem. Discrete Applied Mathematics, volume 156,
issue 2, pages 267-279, 2005.
[32] E. Malaguti, M. Monaci and P. Thot: A Metaheuristic Approach for the
Vertex Coloring Problem. Technical Report OR/05/3, University of Bologna,
Italy, 2005.
[33] I. Diaz and P. Zabala: A Branch-and-Cut Algorithm for Graph Coloring.
Discrete Applied Mathematics, volume 154, number 5, pages 826-847, 2006.
[34] T. Noronha and C. Ribeiro: Routing and wavelength assignment by partition
colouring. European Journal of Operational Research, volume 171, issue 3,
pages 797-810, 2006.
[35] H. de Fraysseix, P. Ossona de Mendez and P. Rosenstiehl: Tremaux Trees
and Planarity. European Journal of Combinatorics, volume 33, issue 3, pages
2798-293, 2012.
[36] I. Bl¨ochliger and N. Zufferey: A graph coloring heuristic using partial
solutions and a reactive tabu scheme. Computers &amp; Operations Research
Volume 35, issue 3, pages 960-975, 2008.
[37] A. Hertz et al.: Variable space search for graph coloring. Discrete Applied</p>
      <p>Mathematics, volume 156, issue 13, pages 2551-1560, 2008.
[38] S. Luke: Essentials of Metaheuristics. Lulu, 2009, available at
http://cs.gmu.edu/∼sean/book/metaheuristics/
[39] Y. Frota et al.: A branch-and-cut algorithm for partition coloring. Networks,
volume 55, issue 3, pages 194-204, 2010.
[40] Y. Frota et al.: Instances for the partition Coloring Problem,
www.ic.uff.br/∼celso/grupo/pcp.htm
[41] Z. Lu¨ and J. Hao: A memetic algorithm for graph coloring. European
Journal of Operational Research, volume 203, issue 1, pages 241-250, 2010.
[42] S. Held et al.: Safe Lower Bounds For Graph Coloring, IPCO 2011, pages
261-273, 2011.
[43]</p>
      <p>M. Chiarandini, G. Galbiati and S. Gualandi: Efficieny issues in the RLF
heuristic for graph coloring. MIC 2011 (The IX Metaheuristics International
Conference), pages 461-469, 2011.
[44] S. Gualandi and F. Malucelli: Exact Solution of Graph Coloring Problems
via Constraint Programming and Column Generation. INFORMS Journal
on Computing, volume 24, number 1, pages 81-100, 2012.
[45] B. Hu and G. Raidl: An evolutionary algorithm with solution archive for the
generalized minimum spanning tree problem. Proceedings of the 13th
International Conference on Computer Aided Systems Theory: Part I, volume
6927 of LNCS, pages 287-294, Springer, 2012.
5.1 Preliminary Results: Instances with 20 nodes . . . . . . . . . . . . 31
5.2 Preliminary Results: Instances with 40 nodes . . . . . . . . . . . . 32
5.3 Preliminary Instances with 60 nodes . . . . . . . . . . . . . . . . . 33
5.4 Preliminary Results: Instances with 80 nodes . . . . . . . . . . . . 34
5.5 Preliminary Results: Instances with 100 nodes . . . . . . . . . . . 35
5.6 Preliminary Results: Instances with 120 nodes . . . . . . . . . . . 36
5.7 Preliminary Results: Instances with 90 nodes, density 0.1 . . . . . 37
5.8 Preliminary Results: Instances with 90 nodes, density 0.2 . . . . . 38
5.9 Preliminary Results: Instances with 90 nodes, density 0.3 . . . . . 39
5.10 Preliminary Results: Instances with 90 nodes, density 0.4 . . . . . 40
5.11 Preliminary Results: Instances with 90 nodes, density 0.5 . . . . . 41
5.12 Preliminary Results: Instances with 90 nodes, density 0.6 . . . . . 42
5.13 Preliminary Results: Instances with 90 nodes, density 0.7 . . . . . 43
5.14 Preliminary Results: Instances with 90 nodes, density 0.8 . . . . . 44
5.15 Preliminary Results: Instances with 90 nodes, density 0.9 . . . . . 45
5.16 Preliminary Results: Instances from Noronha’s paper . . . . . . . 46
5.17 Comparison of exact results and upper bounds . . . . . . . . . . . 47
5.18 Preliminary Results: Modified parameters (up to 20 failing VND
runs allowed, time limit 1800 seconds) . . . . . . . . . . . . . . . . 48
5.19 Final Results including data from Frota’s and Noronha’s papers;
for Frota’s instances, these are aggregated results . . . . . . . . . . 48</p>
    </sec>
  </body>
  <back>
    <ref-list>
      <ref id="ref1">
        <mixed-citation>
          <source>1 Introduction 3 1</source>
          .1
          <string-name>
            <given-names>Graph</given-names>
            <surname>Theory</surname>
          </string-name>
          <string-name>
            <surname>Basics . . . . . . . . . . . . . . . . . . . . . . . . 4</surname>
          </string-name>
          <year>1</year>
          .2
          <string-name>
            <surname>Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</surname>
          </string-name>
          <article-title>5 1.3 Formal Definition</article-title>
          and
          <string-name>
            <surname>Complexity . . . . . . . . . . . . . . . . 5</surname>
          </string-name>
        </mixed-citation>
      </ref>
      <ref id="ref2">
        <mixed-citation>
          <source>3 Methods 11 3</source>
          .1
          <string-name>
            <surname>Metaheuristics . . . . . . . . . . . . . . . . . . . . . . . . . . . 12</surname>
          </string-name>
          <year>3</year>
          .2 Solution
          <string-name>
            <surname>Evaluation . . . . . . . . . . . . . . . . . . . . . . . . 17</surname>
          </string-name>
          <year>3</year>
          .3 Solution
          <string-name>
            <surname>Archive . . . . . . . . . . . . . . . . . . . . . . . . . . 23</surname>
          </string-name>
          <year>3</year>
          .4 Complete
          <string-name>
            <surname>Algorithm . . . . . . . . . . . . . . . . . . . . . . . . 23</surname>
          </string-name>
        </mixed-citation>
      </ref>
      <ref id="ref3">
        <mixed-citation>
          <source>5 Computational Results 29 5</source>
          .1 Preliminary
          <string-name>
            <surname>Results . . . . . . . . . . . . . . . . . . . . . . . . 29</surname>
          </string-name>
          <year>5</year>
          .2 Discussion and
          <string-name>
            <surname>Final Results . . . . . . . . . . . . . . . . . . . 47</surname>
          </string-name>
        </mixed-citation>
      </ref>
      <ref id="ref4">
        <mixed-citation>
          [25]
          <string-name>
            <given-names>T.</given-names>
            <surname>English</surname>
          </string-name>
          <article-title>: Optimization Is Easy and Learning Is Hard in the Typical Function</article-title>
          .
          <source>Proceedings of the 2000 Congress on Evolutionary Computation: CEC00</source>
          , pages
          <fpage>924</fpage>
          -
          <lpage>931</lpage>
          ,
          <year>2000</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref5">
        <mixed-citation>
          [26]
          <string-name>
            <given-names>F.</given-names>
            <surname>Herrmann</surname>
          </string-name>
          and
          <string-name>
            <given-names>A.</given-names>
            <surname>Hertz</surname>
          </string-name>
          <article-title>: Finding the chromatic number by means of critical graphs</article-title>
          .
          <source>ACM Journal of Experimental Algorithmics</source>
          , volume
          <volume>7</volume>
          , issue 10, pages
          <fpage>1</fpage>
          -
          <lpage>9</lpage>
          ,
          <year>2002</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref6">
        <mixed-citation>
          [27]
          <string-name>
            <given-names>C.</given-names>
            <surname>Avanthay</surname>
          </string-name>
          ,
          <string-name>
            <given-names>A.</given-names>
            <surname>Hertz</surname>
          </string-name>
          and
          <string-name>
            <surname>N.</surname>
          </string-name>
          <article-title>Zufferey: A Variable Neighborhood Search for Graph Coloring</article-title>
          .
          <source>European Journal of Operational Research</source>
          , volume
          <volume>151</volume>
          , pages
          <fpage>379</fpage>
          -
          <lpage>388</lpage>
          ,
          <year>2003</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref7">
        <mixed-citation>
          [28]
          <string-name>
            <given-names>R.</given-names>
            <surname>Correa</surname>
          </string-name>
          ,
          <string-name>
            <given-names>M.</given-names>
            <surname>Campelo</surname>
          </string-name>
          and
          <string-name>
            <given-names>Y.</given-names>
            <surname>Frota</surname>
          </string-name>
          <article-title>: Cliques, holes and the vertex coloring polytope</article-title>
          .
          <source>Information Processing Letters</source>
          , volume
          <volume>89</volume>
          , pages
          <fpage>159</fpage>
          -
          <lpage>164</lpage>
          ,
          <year>2004</year>
          .
        </mixed-citation>
      </ref>
    </ref-list>
  </back>
</article>