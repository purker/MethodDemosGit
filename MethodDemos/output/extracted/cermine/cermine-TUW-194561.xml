<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
  <front>
    <journal-meta>
      <journal-title-group>
        <journal-title>EPTCS</journal-title>
      </journal-title-group>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="doi">10.4204/EPTCS.15.5</article-id>
      <title-group>
        <article-title>Extending Context-Sensitivity in Term Rewriting</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <string-name>Bernhard Gramlich</string-name>
          <email>gramlich@logic.at</email>
          <xref ref-type="aff" rid="aff0">0</xref>
        </contrib>
        <contrib contrib-type="author">
          <string-name>Felix Schernhammer</string-name>
          <email>felixs@logic.at</email>
          <xref ref-type="aff" rid="aff0">0</xref>
        </contrib>
        <aff id="aff0">
          <label>0</label>
          <institution>Institute of Computer Languages, Theory and Logic Group Vienna University of Technology</institution>
        </aff>
      </contrib-group>
      <pub-date>
        <year>2010</year>
      </pub-date>
      <volume>15</volume>
      <issue>2010</issue>
      <fpage>56</fpage>
      <lpage>68</lpage>
      <abstract>
        <p>We propose a generalized version of context-sensitivity in term rewriting based on the notion of “forbidden patterns”. The basic idea is that a rewrite step should be forbidden if the redex to be contracted has a certain shape and appears in a certain context. This shape and context is expressed through forbidden patterns. In particular we analyze the relationships among this novel approach and the commonly used notion of context-sensitivity in term rewriting, as well as the feasibility of rewriting with forbidden patterns from a computational point of view. The latter feasibility is characterized by demanding that restricting a rewrite relation yields an improved termination behaviour while still being powerful enough to compute meaningful results. Sufficient criteria for both kinds of properties in certain classes of rewrite systems with forbidden patterns are presented.</p>
      </abstract>
    </article-meta>
  </front>
  <body>
    <sec id="sec-1">
      <title>-</title>
      <p>
        One way to address the problem of avoiding non-normalizing reductions in Example 1 is the use
of reduction strategies. For instance for the class of (almost) orthogonal rewrite systems (the TRS of
∗This author has been supported by the Austrian Academy of Sciences under grant 22.361.
Example 1 is orthogonal), always contracting all outermost redexes in parallel yields a normalizing
strategy (i.e. whenever a term can be reduced to a normal form it is reduced to a normal form under this
strategy) [
        <xref ref-type="bibr" rid="ref18">18</xref>
        ]. Indeed, one can define a sequential reduction strategy having the same property for an
even wider class of TRSs [
        <xref ref-type="bibr" rid="ref3">3</xref>
        ]. One major drawback (or asset depending on one’s point of view) of using
reduction strategies, however, is that their use does not introduce new normal forms. This means that
the set of normal forms w.r.t. to some reduction relation is the same as the set of normal forms w.r.t. to
the reduction relation under some strategy. Hence, strategies can in general not be used to detect
nonnormalizing terms or to impose termination on not weakly normalizing TRSs (with some exceptions cf.
e,g. [3, Theorem 7.4]). Moreover, the process of selecting a suitable redex w.r.t. to a reduction strategy
is often complex and may thus be inefficient.
      </p>
      <p>These shortcomings of reduction strategies led to the advent of proper restrictions of rewriting that
usually introduce new normal forms and select respectively forbid certain reductions according to the
syntactic structure of a redex and/or its surrounding context.</p>
      <p>The most well-known approach to context restrictions is context-sensitive rewriting. There, a
replacement map μ specifies the arguments μ ( f ) ⊆ {1, . . . , ar( f )} which can be reduced for each function
f . However, regarding Example 1, context-sensitive rewriting does not improve the situation, since
allowing the reduction of the second argument of ‘:’ leads to non-termination, while disallowing its
reduction leads to incompleteness in the sense that for instance a term like 2nd(inf(x)) cannot be
normalized via the corresponding context-sensitive reduction relation, despite having a normal form in the
unrestricted system.</p>
      <p>
        Other ideas of context restrictions range from explicitly modeling lazy evaluation (cf. e.g. [
        <xref ref-type="bibr" rid="ref17 ref19 ref9">9, 17,
19</xref>
        ]), to imposing constraints on the order of argument evaluation of functions (cf. e.g. [
        <xref ref-type="bibr" rid="ref10 ref7">10, 7</xref>
        ]), and to
combinations of these concepts, also with standard context-sensitive rewriting (cf. e.g. [
        <xref ref-type="bibr" rid="ref15 ref2">15, 2</xref>
        ]). The
latter generalized versions of context-sensitive rewriting are quite expressive and powerful (indeed some
of them can be used to restrict the reduction relation of the TRS in Example 1 in a way, so that the
restricted relation is terminating and still powerful enough to compute (head-)normal forms), but on
the other hand tend to be hard to analyze and understand, due the subtlety of the strategic information
specified.
      </p>
      <p>The approach we present in this paper is simpler in that its definition only relies on matching and
simple comparison of positions rather than on laziness or prioritizing the evaluation of certain arguments
of functions over others. In order to reach the goal of restricting the reduction relation in such a way
that it is terminating while still being powerful enough to compute useful results, we provide a method
to verify termination of a reduction relation restricted by our approach (Section 5) as well as a criterion
which guarantees that normal forms computed by the restricted system are head-normal forms of the
unrestricted system (Section 4).</p>
      <p>
        Recently it turned out that, apart from using context-sensitivity as computation model for standard
term rewriting (cf. e.g. [
        <xref ref-type="bibr" rid="ref14 ref16">16, 14</xref>
        ]), context-sensitive rewrite systems naturally also appear as intermediate
representations in many areas relying on transformations, such as program transformation and
termination analysis of rewrite systems with conditions [
        <xref ref-type="bibr" rid="ref20 ref6">6, 20</xref>
        ] / under strategies [
        <xref ref-type="bibr" rid="ref8">8</xref>
        ].
      </p>
      <p>This suggests that apart from using restrictions as guidance and thus as operational model for rewrite
derivations, a general, flexible and well-understood framework of restricted term rewriting going beyond
context-sensitive rewriting may be useful as a valuable tool in many other areas, too.</p>
      <p>
        The major problem in building such a framework is that imposing context restrictions on term
rewriting in general invalidates the closure properties of term rewriting relations, i.e., stability under contexts
and substitutions. Note that in the case of context-sensitive rewriting a` la [
        <xref ref-type="bibr" rid="ref14 ref16">14, 16</xref>
        ] only stability under
contexts is lost.
      </p>
      <p>
        In this work we will sketch and discuss a generalized approach to context-sensitivity (in the sense
of [
        <xref ref-type="bibr" rid="ref14 ref16">14, 16</xref>
        ]) relying on forbidden patterns rather than on forbidden arguments of functions. From a
systematic point of view we see the following design decisions to be made.
      </p>
      <p>• What part of the context of a (sub)term is relevant to decide whether the (sub)term may be reduced
or not?
• In order to specify the restricted reduction relation, is it better/advantageous to explicitly define
the allowed or the forbidden part of the context-free reduction relation?
• What are the forbidden/allowed entities, for instance whole subterms, contexts, positions, etc.?
• Does it depend on the shape of the considered subterm itself (in addition to its outside context)
whether it should forbidden or not (if so, stability under substitutions may be lost)?
• Which restrictions on forbidden patterns seem appropriate (also w.r.t. practical feasibility) in order
to guarantee certain desired closure and preservation properties.</p>
      <p>The remainder of the paper is structured as follows. In Section 2 we briefly recall some basic notions
and notations. Rewriting with forbidden patterns is defined, discussed and exemplified in Section 3.
In the main Sections 4 and 5 we develop some theory about the expressive power of rewriting with
forbidden patterns (regarding the ability to compute original (head-)normal forms), and about how to
prove ground termination for such systems via a constructive transformational approach. Crucial aspects
are illustrated with the two running Examples 1 and 3. Finally, in Section 6 we summarize our approach
and its application in the examples, discuss its relationship to previous approaches and briefly touch
the important perspective and open problem of (at least partially) automating the generation of suitable
forbidden patterns in practice.1
2</p>
    </sec>
    <sec id="sec-2">
      <title>Preliminaries</title>
      <p>
        We assume familiarity with the basic notions and notations in term rewriting, cf. e.g. [
        <xref ref-type="bibr" rid="ref4">4</xref>
        ], [
        <xref ref-type="bibr" rid="ref5">5</xref>
        ].
      </p>
      <p>
        Since we develop our approach in a many-sorted setting, we recall a few basics on many-sorted
equational reasoning (cf. e.g. [
        <xref ref-type="bibr" rid="ref5">5</xref>
        ]). A many-sorted signature F is a pair (S, Ω) where S is a set of sorts
and Ω is a family of (mutually disjoint) sets of typed function symbols: Ω = (Ωω ,s | ω ∈ S∗, s ∈ S). We
also say, f is of type ω → s (or just s if ω = 0/) if f ∈ Ωω ,s. V = (Vs | s ∈ S) is a family of (mutually
disjoint) countably infinite sets of typed variables (with V ∩ Ω = 0/). The set T (F ,V )s of (well-formed)
terms of sort s is the least set containing Vs, and whenever f ∈ Ω(s1,...,sn),s and ti ∈ T (F ,V )si for all
1 ≤ i ≤ n, then f (t1, . . . , tn) ∈ T (F ,V )s. The sort of a term t is denoted by sort(t). Rewrite rules are
pairs of terms l → r where sort(l) = sort(r). Subsequently, we make the types of terms and rewrite rules
explicit only if they are relevant. Throughout the paper x, y, z represent (sorted) variables.
      </p>
      <p>Positions are possibly empty sequences of natural numbers (the empty sequence is denoted by ε ).
We use the standard partial order ≤ on positions given by p ≤ q if there is some position p′ , such that
p.p′ = q (i.e., p is a prefix of q). Pos(s) (PosF (s)) denotes the set of (non-variable) positions of a term
p
s. By s → t we mean rewriting at position p. Given a TRS R = (F , R) we partition F into the set D
of defined function symbols, which are those that occur as root symbols of left-hand sides of rules in R,
and the set C of constructors (given by F \ D). For TRSs R = (F , R) we sometimes confuse R and R,
e.g., by omitting the signature.</p>
      <p>1Due to lack of space the obtained results are presented without proofs. The latter can be found in the full technical report
version of the paper, cf. http://www.logic.at/staff/{gramlich,schernhammer}/.
3</p>
    </sec>
    <sec id="sec-3">
      <title>Rewriting with Forbidden Patterns</title>
      <p>In this section we define a generalized approach to rewriting with context restrictions relying on term
patterns to specify forbidden subterms/superterms/positions rather than on a replacement map as in
contextsensitive rewriting.</p>
      <p>Definition 1 (forbidden pattern). A forbidden pattern (w.r.t. to a signature F ) is a triple ht, p,λ i, where
t ∈ T (F ,V ) is a term, p a position from Pos(t) and λ ∈ {h, b, a}.</p>
      <p>The intended meaning of the last component λ is to indicate whether the pattern forbids reductions
• exactly at position p, but not outside (i.e., strictly above or parallel to p) or strictly below – (h for
here), or
• strictly below p, but not at or outside p – (b for below), or
• strictly above position p, but not at, below or parallel to p – (a for above).</p>
      <p>Abusing notation we sometimes say a forbidden pattern is linear, unifies with some term etc. when
we actually mean that the term in the first component of a forbidden pattern has this property.</p>
      <p>We denote a finite set of forbidden patterns for a signature F by ΠF or just Π if F is clear from
the context or irrelevant. For brevity, patterns of the shape h , , h/b/ai are also called h/b/a-patterns, or
here/below/above-patterns.2</p>
      <p>Note that if for a given term t we want to specify more than just one restriction by a forbidden pattern,
this can easily be achieved by having several triples of the shape ht, , i.</p>
      <p>In contrast to context-sensitive rewriting, where a replacement map defines the allowed part of the
reduction, the patterns are supposed to explicitly define its forbidden parts, thus implicitly yielding allowed
reduction steps as those that are not forbidden.</p>
      <p>Definition 2 (forbidden pattern reduction relation). Let R = (F , R) be a TRS with forbidden patterns
ΠF . The forbidden pattern reduction relation →R,ΠF , or →Π for short, induced by some set of forbidden
p
patterns Π and R, is given by s →R,ΠF t if s →R t for some p ∈ PosF (s) such that there is no pattern
hu, q,λ i ∈ ΠF , no context C and no position q′ with
• s = C[uσ ]q′ and p = q′ .q, if λ = h,
• s = C[uσ ]q′ and p &gt; q′ .q, if λ = b, and
• s = C[uσ ]q′ and p &lt; q′ .q, if λ = a.</p>
      <p>Note that for a finite rewrite system R (with finite signature F ) and a finite set of forbidden
patterns ΠF it is decidable whether s →R,ΠF t for terms s and t. We write (R, Π) for rewrite systems
with associated forbidden patterns. Such a rewrite system (R, Π) is said to be Π-terminating (or just
terminating if no confusion arises) if →R,Π is well-founded. We also speak of Π-normal forms instead
of →R,Π-normal forms.</p>
      <p>Special degenerate cases of (R, Π) include e.g. Π = 0/ where →R,Π=→R , and Π = {hl,ε , hi | l →
r ∈ R} where →R,Π= 0/.</p>
      <p>In the sequel we use the notions of allowed and forbidden (by Π) redexes. A redex s|p of a term s is
p
allowed if s →Π t for some term t, and forbidden otherwise.</p>
      <p>2 Here and subsequently we use a wildcard notation for forbidden patterns. For instance, h , , ii stands for ht, p, ii where t
is some term and p some position in t of no further relevance.
Example 2. Consider the TRS from Example 1. If Π = {(x : (y : inf(z)), 2.2, h)}, then →Π can
automatically be shown to be terminating. Moreover, →Π is powerful enough to compute original head-normal
forms if they exist (cf. Examples 6 and 11 below).</p>
      <p>Example 3. Consider the non-terminating TRS R given by</p>
      <p>take(0, y : ys) → y
take(s(x), y : ys) → take(x, ys)
take(x, nil) → 0</p>
      <p>app(nil, ys) → ys
app(x : xs, ys) → x : app(xs, ys)
inf(x) → inf(s(x))
with two sorts S = {Nat, NatList}, where the types of function symbols are as follows: nil : NatList,
0 : Nat, s : Nat → Nat, : is of type Nat, NatList → NatList, inf : Nat → NatList, app : NatList, NatList →
NatList and take : Nat, NatList → Nat. If one restricts rewriting in R via Π given by
hx : inf(y), 2, hi
hx : app(inf(y), zs), 2.1, hi
hx : app(y : app(z, zs), us), 2, hi,
then →Π is terminating and still every well-formed ground term can be normalized with the restricted
relation →Π (provided the term is normalizing). See Examples 7 and 12 below for justifications of these
claims.</p>
      <p>Several well-known approaches to restricted term rewriting as well as to rewriting guided by
reduction strategies occur as special cases of rewriting with forbidden patterns. In the following we
provide some examples. Context-sensitive rewriting, where a replacement map μ specifies the arguments
μ ( f ) ⊆ {1, . . . , ar( f )} which can be reduced for each function f , arises as special case of rewriting with
forbidden patterns by defining Π to contain for each function symbol f and each j ∈ {1, . . . , ar( f )} \μ ( f )
the forbidden patterns ( f (x1, . . . , xar( f )), j, h) and ( f (x1, . . . , xar( f )), j, b).</p>
      <p>Moreover, with forbidden patterns it is also possible to simulate position-based reduction strategies
such as innermost and outermost rewriting. The innermost reduction relation of a TRS R coincides with
the forbidden pattern reduction relation if one uses the forbidden patterns hl,ε , ai for the left-hand sides l
of each rule of R. Dually, if patterns (l,ε , b) are used, the forbidden pattern reduction relation coincides
with the outermost reduction relation w.r.t. R.</p>
      <p>However, note that more complex layered combinations of the aforementioned approaches, such as
innermost context-sensitive rewriting cannot be modeled by forbidden patterns as proposed in this paper.</p>
      <p>Still, the definition of forbidden patterns and rewriting with forbidden patterns is rather general and
leaves many parameters open. In order to make this approach feasible in practice, it is necessary to
identify interesting classes of forbidden patterns that yield a reasonable trade-off between power and
simplicity. For these interesting classes of forbidden patterns we need methods which guarantee that the
results (e.g. normal forms) computed by rewriting with forbidden patterns are meaningful, in the sense
that they have some natural correlation with the actual results obtained by unrestricted rewriting. For
instance, it is desirable that normal forms w.r.t. the restricted rewrite system are original head-normal
forms. In this case one can use the restricted reduction relation to compute original normal forms (by
an iterated process) whenever they exist (provided that the TRS in question is left-linear, confluent and
the restricted reduction relation is terminating) (cf. Section 4 below for details). We define a criterion
ensuring that normal forms w.r.t. the restricted system are original head-normal forms in the following
section.
4</p>
    </sec>
    <sec id="sec-4">
      <title>Computing Meaningful Results</title>
      <p>
        We are going to use canonical context-sensitive rewriting as defined in [
        <xref ref-type="bibr" rid="ref14 ref16">14, 16</xref>
        ] as an inspiration for
our approach. There, for a given (left-linear) rewriting system R certain restrictions on the associated
replacement map μ guarantee that →μ -normal forms are →R-head-normal-forms. Hence, results
computed by →μ and →R share the same root symbol.
      </p>
      <p>The basic idea is that reductions that are essential to create a more outer redex should not be
forbidden. In the case of context-sensitive rewriting this is guaranteed by demanding that whenever an f -rooted
term t occurs (as subterm) in the left-hand side of a rewrite rule and has a non-variable direct subterm t|i,
then i ∈ μ ( f ).</p>
      <p>
        It turns out that for rewriting with forbidden patterns severe restrictions on the shape of the patterns
are necessary in order to obtain results similar to the ones for canonical context-sensitive rewriting in
[
        <xref ref-type="bibr" rid="ref14">14</xref>
        ]. First, no forbidden patterns of the shape h ,ε , hi or h , , ai may be used as they are in general not
compatible with the desired root-normalizing behaviour of our forbidden pattern rewrite system.
      </p>
      <p>Moreover, for each pattern ht, p, i we demand that
• t is linear,
• p is a variable or maximal (w.r.t. to the prefix ordering ≤ on positions) non-variable position in t,
and
• for each position q ∈ Pos(t) with q||p we have t|q ∈ V .</p>
      <p>We call the class of patterns obtained by the above restrictions simple patterns.</p>
      <p>Definition 3 (simple patterns). A set Π of forbidden patterns is called simple if it does not contain
patterns of the shape h ,ε , hi or h , , ai and for every pattern (t, p, ) ∈ Π it holds that t is linear, t|p ∈ V
or t|p = f (x1, . . . , xar( f )) for some function symbol f , and for each position q ∈ Pos(t) with q||p we have
that t|q is a variable.</p>
      <p>Basically these syntactical properties of forbidden patterns are necessary to ensure that reductions
which are essential to enable other, more outer reductions are not forbidden. Moreover, these properties,
contrasting those defined in Definition 4 below, are independent of any concrete rewrite system.</p>
      <p>The forbidden patterns of the TRS (R, Π) in Example 4 below are not simple, since the patterns
contain terms with parallel non-variable positions. This is the reason why it is not possible to
headnormalize terms (w.r.t R) with →Π:
Example 4. Consider the TRS R given by
f (b, b) → g( f (a, a))
a → b
and forbidden patterns h f (a, a), 1, hi and h f (a, a), 2, hi. f (a, a) is linear and 1 and 2 are maximal
positions (w.r.t. ≤) within this term. However, positions 1 and 2 are both non-variable and thus e.g. for
h f (a, a), 1, hi there exists a position 2||1 such that f (a, a)|2 = a 6∈ V . Hence, Π is too restrictive to
compute all R-head-normal forms in this example. Indeed, f (a, a) →∗R f (b, b) →R g( f (a, a)) where the
latter term is a R-head-normal form.</p>
      <p>The term f (a, a) is a Π-normal form, although it is not a head-normal form (w.r.t. R). Note also that
the (first components of) forbidden patterns are not unifiable with the left-hand side of the rule that is
responsible for the (later) possible root-step when reducing f (a, a), not even if the forbidden subterms in
the patterns are replaced by fresh variables.</p>
      <p>Now we are ready to define canonical rewriting with forbidden patterns within the class of simple
forbidden patterns. To this end, we demand that patterns do not overlap with left-hand sides of rewrite
rules in a way such that reductions necessary to create a redex might be forbidden.</p>
      <p>Definition 4 (canonical forbidden patterns). Let R = (F , R) be a TRS with simple forbidden patterns
ΠF (w.l.o.g. we assume that R and ΠF have no variables in common). Then, ΠF is R-canonical (or
just canonical) if the following holds for all rules l → r ∈ R :
1. There is no pattern (t, p,λ ) such that
2. There is no pattern (t, p,λ ) such that
• t′ |q and l unify for some q ∈ PosF (t) where t′ = t[x]p and q &gt; ε , and
• there exists a position q′ ∈ PosF (l) with q.q′ = p for λ = h respectively q.q′ &gt; p for λ = b.
• t′ and l|q unify for some q ∈ PosF (l) where t′ = t[x]p, and
• there exists a position q′ with q.q′ ∈ PosF (l) and q′ = p for λ = h respectively q′ &gt; p for
λ = b.</p>
      <p>Here, x denotes a fresh variable.</p>
      <p>Example 5. Consider the TRS R given by the single rule</p>
      <p>l = f (g(h(x))) → x = r .</p>
      <p>Then, Π = {ht, p, hi} with t = g( f (a)), p = 1.1 is not canonical since t[x]p|q = g( f (y))|1 = f (y) and
l unify where q = q′ = 1 and thus q.q′ = p (hence root(l|q′ ) = g). Moreover, also Π = {ht, p, hi} with
t = g(i(x)), p = 1 is not canonical, since l|q = g(h(x)) and t[x]p = f (y) unify for q = 1 and q.p = 1.1 is
a non-variable position in l.</p>
      <p>On the other hand, Π = {hg(g(x)), 1.1, hi} is canonical. Note that all of the above patterns are
simple.</p>
      <p>In order to prove that normal forms obtained by rewriting with simple and canonical forbidden
patterns are actually head-normal forms w.r.t. unrestricted rewriting, and also to provide more intuition on
canonical rewriting with forbidden patterns, we define the notion of a partial redex (w.r.t. to a rewrite
system R) as a term that is matched by a non-variable term l′ which in turn matches the left-hand side
of some rule of R. We call l′ a witness for the partial match.</p>
      <p>Definition 5 (Partial redex). Given a rewrite system R = (F , R), a partial redex is a term s that is
matched by a non-variable term l′ which in turn matches the left-hand side of some rule in R. The
(non-unique) term l′ is called witness for a partial redex s.</p>
      <p>Thus, a partial redex can be viewed as a candidate for a future reduction step, which can only be
performed if the redex has actually been created through more inner reduction steps. Hence, the idea of
canonical rewriting with forbidden patterns could be reformulated as guaranteeing that the reduction of
subterms of partial redexes is allowed whenever these reductions are necessary to create an actual redex.
Lemma 1. Let R = (F , R) be a left-linear TRS with canonical (hence, in particular simple) forbidden
patterns ΠF . Moreover, let s be a partial redex w.r.t. to the left-hand side of some rule l with witness l′
such that l|p 6∈ V but l′ |p ∈ V . Then in the term C[s]q the position q.p is allowed by ΠF for reduction
provided that q is allowed for reduction.</p>
      <p>Theorem 1. Let R = (F , R) be a left-linear TRS with canonical (hence in particular simple) forbidden
patterns ΠF . Then →R,ΠF -normal forms are →R -head-normal forms.</p>
      <p>Given a left-linear and confluent rewrite system R and a set of canonical forbidden patterns Π such
that →Π is well-founded, one can thus normalize a term s (provided that s is normalizing) by computing
the →Π-normal form t of s which is R-root-stable according to Theorem 1, and then do the same
recursively for the immediate subterms of t. Confluence of R assures that the unique normal form of s will
indeed be computed this way.</p>
      <p>Example 6. As the forbidden pattern defined in Example 2 is (simple and) canonical, Theorem 1 yields
that →R,δ -normal forms are →R -head-normal forms. For instance we get 2nd(inf(0)) →∗Π s(0).
Example 7. Consider the TRS with R and forbidden patterns Π from Example 3. We will prove below
that R is Π-terminating (cf. Example 12).</p>
      <p>Furthermore we are able to show that every well-formed ground term that is reducible to a normal
form in R is reducible to the same normal form with →R,Π and that every →R -normal form is root-stable
w.r.t. →R .
5</p>
    </sec>
    <sec id="sec-5">
      <title>Proving Termination</title>
      <p>We provide another example of a result on a restricted class of forbidden patterns, this time concerning
termination. We exploit the fact that, given a finite signature and linear h-patterns, a set of allowed
contexts complementing each forbidden one can be constructed. Thus, we can transform a rewrite system
with this kind of forbidden patterns into a standard (i.e., context-free) one by explicitly instantiating
and embedding all rewrite rules (in a minimal way) in contexts (including a designated top-symbol
representing the empty context) such that rewrite steps in these contexts are allowed.</p>
      <p>To this end we propose a transformation that proceeds by iteratively instantiating and embedding
rules in a minimal way. This is to say that the used substitutions map variables only to terms of the form
f (x1, . . . , xar( f )) and the contexts used for the embeddings have the form g(x1, . . . , xi−1, , xi+1, xar( f )) for
some function symbols f ∈ F , g ∈ F ⊎ { top} and some argument position i of f (resp. g). It is important
to keep track of the position of the initial rule inside the embeddings. Thus we associate to each rule
introduced by the transformation a position pointing to the embedded original rule. To all initial rules of
R we thus associate ε .</p>
      <p>Note that it is essential to consider a new unary function symbol tops for every sort s ∈ S (of type
s → s) representing the empty context. This is illustrated by the following example.
Example 8. Consider the TRS given by
a → f (a)
f (x) → x
with F = {a, f } and the set of forbidden patterns Π = {h f (x), 1, h}i}. This system is not Π-terminating
as we have</p>
      <p>a →Π f (a) →Π a →Π . . .</p>
      <p>Whether a subterm s|p = a is allowed for reduction by Π depends on its context. Thus, according to the
idea of our transformation we try to identify all contexts C[a]p such that the reduction of a at position
p is allowed by Π. However, there is no such (non-empty) context, although a may be reduced if C is
the empty context. Moreover, there cannot be a rule l → r in the transformed system where l = a, since
that would allow the reduction of terms that might be forbidden by Π. Our solution to this problem is to
introduce a new function symbol top explicitly representing the empty context. Thus, in the example the
transformed system will contain a rule top(a) → top( f (a)).</p>
      <p>Abusing notation we subsequently use only one top-symbol, while we actually mean the tops-symbol
of the appropriate sort. Moreover, in the following by rewrite rules we always mean rewrite rules with
an associated (embedding) position, unless stated otherwise. All forbidden patterns used in this section
(particularly in the lemmata) are linear here-patterns. We will make this general assumption explicit only
in the more important results.</p>
      <p>Definition 6 (instantiation and embedding). Let F = (S, Ω) be a signature, let hl → r, pi be a rewrite
rule of sort s over F and let Π be a set of forbidden patterns (linear, h). The set of minimal instantiated
and embedded rewrite rules TΠ(hl → r, pi) (or just T (hl → r, pi)) is TΠi (hl → r, pi) ⊎ TΠe(hl → r, pi) where
T e(hl → r, pi) =
TΠi (hl → r, pi) =
{hC[l] → C[r], i.pi | C = f (x1, . . . , xi−1, , xi+1, . . . , xar( f )),
f ∈ Ω(s1,...,si−1,s,si+1,...,sar(f)),s′ , f ∈ F ⊎ { tops | s ∈ S}, i ∈ {1, . . . , ar( f )},
∃hu, o, hi ∈ Π.u|qθ = lθ ∧ q 6= ε ∧ o = q.p}
{hlσ → rσ , pi | xσ = f (x1, . . . , xar( f )), sort(x) = sort( f (x1, . . . xar( f ))),
f ∈ F , y 6= x ⇒ yσ = y, x ∈ RVΠ(l, p)}
and RVΠ(l, p) = {x ∈ Var(l) | ∃hu, o, hi ∈ Π.θ = mgu(u, l|q) ∧ q.o = p ∧ xθ 6∈ V }.</p>
      <p>We also call the elements of T (hl → r, pi) the one-step T -successors of hl → r, pi. The
reflexivetransitive closure of the one-step T -successor relation is the many-step T -successor relation or just T
successor relation. We denote the set of all many-step T -successors of a rule hl → r, pi by T ∗(hl → r, pi).</p>
      <p>The set RVΠ(l, p) of “relevant variables” is relevant in the sense that their instantiation might
contribute to a matching by some (part of a) forbidden pattern term.</p>
      <p>Note that in the generated rules hl′ → r′ , p′ i in TΠ(hl → r, pi), a fresh tops-symbol can only occur at
the root of both l′ and r′ or not at all, according to the construction in Definition 6.</p>
      <p>Example 9. Consider the TRS (R, Π) where R = ({a, f , g}, { f (x) → g(x)}) and the forbidden patterns
Π are given by {hg(g( f (a))), 1.1, hi}. T (h f (x) → g(x),ε i) consists of the following rewrite rules.
h f ( f (x)) → g( f (x)),ε i
h f (g(x)) → g(g(x)),ε i</p>
      <p>h f (a) → g(a),ε i
h f ( f (x)) → f (g(x)), 1i
hg( f (x)) → g(g(x)), 1i
(1)
(2)
(3)
(4)
(5)</p>
      <p>Note that RVΠ( f (x),ε ) = {x} because g(g( f (a)))1.1 = f (a) unifies with f (x) and mgu θ where
xθ = a 6∈ V . On the other hand RVΠ( f ( f (x)), 1) = 0/.</p>
      <p>Lemma 2 (finiteness of instantiation and embedding). Let hl → r, pi be a rewrite rule and let Π be
a set of forbidden patterns. The set of (many-step) instantiations and embeddings of hl → r, pi (i.e.
T ∗(hl → r, pi)) is finite.</p>
      <p>The transformation we are proposing proceeds by iteratedly instantiating and embedding rewrite
rules. The following definitions identify the rules for which no further instantiation and embedding is
needed.</p>
      <p>Definition 7 (Π-stable). Let hl → r, pi be a rewrite rule and let Π be a set of forbidden patterns. hl →
r, pi is Π-stable (stbΠ(hl → r, pi) for short) if there is no context C and no substitution σ such that
C[lσ ]q|q′ = uθ and q.p = q′ .o for any forbidden pattern hu, o, hi ∈ Π and any θ .</p>
      <p>Note that Π-stability is effectively decidable (for finite signatures and finite Π), since only contexts
and substitutions involving terms not exceeding a certain depth depending on Π need to be considered.
Definition 8 (Π-obsolete). Let hl → r, pi be a rewrite rule and let Π be a set of forbidden patterns.
hl → r, pi is Π-obsolete (obsΠ(hl → r, pi) for short) if there is a forbidden pattern Π = hu, o, hi such that
l|q = uθ and p = q.o.</p>
      <p>In Example 9, the rules (1), (2) and (4) are Π-stable, while rules (3) and (5) would be processed
further. After two more steps e.g. a rule hg(g( f (a))) → g(g(g(a))), 1.1i is produced that is Π-obsolete.</p>
      <p>The following lemmata state some properties of Π-stable rules.
Lemma 3. Let Π be a set of forbidden patterns and let hl′ = C[lσ ]p → C[rσ ]p = r′ , pi be a Π-stable
rewrite rule corresponding to l → r. If s → t with l′ → r′ , then s →Π t with l → r.</p>
      <p>Lemma 4. Let hl → r, pi be a rule and Π be a set of forbidden patterns. If T (hl → r, pi) = 0/, then
hl → r, pi is either Π-stable or Π-obsolete.</p>
      <p>Definition 9. Let R = (F , R) be a TRS with an associated set of forbidden patterns Π where F = (S, Ω).
The transformation T maps TRSs with forbidden patterns to standard TRSs T (R, Π). It proceeds in 5
steps.</p>
      <p>1. Rtmp = {hl → r,ε i | l → r ∈ R}</p>
      <p>Racc = 0/
2. Racc = {hl → r, pi ∈ Rtmp | stbΠ(hl → r, pi)}</p>
      <p>Rtmp = {hl → r, pi ∈ Rtmp | ¬stbΠ(hl → r, pi) ∧ ¬obsΠ(hl → r, pi)}
3. Rtmp = Shl→r,pi∈Rtmp T (hl → r, pi)
4. If Rtmp 6= 0/ go to 2
5. T (R, Π) = (F ⊎ { tops | s ∈ S}, {l → r | hl → r, pi ∈ Racc})</p>
      <p>In the transformation rewrite rules are iteratively created and collected in Rtmp (temporary rules).
Those rules that are Π-stable and will thus be present in the final transformed system are collected in
Racc (accepted rules).</p>
      <p>Lemma 5. Let R be a rewrite system and Π be a set of forbidden (linear h-)patterns. If s →R,Π t for
ground terms s and t, then top(s) → top(s) in T (R, Π).</p>
      <p>Theorem 2. Let R be a TRS and Π be a set of linear here-patterns. We have s →Π+ t for ground terms s
and t if and only if top(s) →T+(R,Π) top(t).</p>
      <p>Proof. The result is a direct consequence of Lemmata 3 and 5.</p>
      <p>Corollary 1. Let R be a TRS and Π be a set of linear h-patterns. R is ground terminating under Π if
and only if T (R, Π) is ground terminating.</p>
      <p>Note that the restriction to ground terms is crucial in Corollary 1. Moreover, ground termination and
general termination do not coincide in general for rewrite systems with forbidden patterns (observe that
the same is true for other important rewrite restrictions and strategies such as the outermost strategy).
Example 10. Consider the TRS R = (F , R) given by F = {a, f } (where a is a constant) and R
consisting of the rule
f (x) →
f (x).</p>
      <p>Moreover, consider the set of forbidden patterns Π = {h f (a),ε , hi, h f ( f (x)),ε , hi}. Then R is not
Πterminating because we have f (x) →Π f (x) but it is Π-terminating on all ground terms, as can be shown
by Theorem 2, since T (R, Π) = 0/.</p>
      <p>Example 11. Consider the TRS of Example 2. We use two sorts NatList and Nat, with function symbol
types 2nd : NatList → Nat, inf : Nat → NatList, top : NatList → NatList (note that another “top” symbol
of type Nat → Nat is not needed here), s : Nat → Nat, 0 : Nat, nil : NatList and : of type Nat, NatList →
NatList. According to Definition 9, the rules of T (R, Π) are:
2nd(inf(x)) → 2nd(x : inf(s(x)))
top(inf(x)) → top(x : inf(s(x)))
top(x′ : inf(x)) → top(x′ : (x : inf(s(x)))).</p>
      <p>
        2nd(x : (y : zs)) → y
2nd(x′ : inf(x)) → 2nd(x′ : (x : inf(s(x))))
This system is terminating (and termination can be verified automatically, e.g. by AProVE [
        <xref ref-type="bibr" rid="ref12">12</xref>
        ]). Hence,
by Corollary 1 also the TRS with forbidden patterns from Example 2 is ground terminating.
Example 12. The TRS R and forbidden patterns Π from Example 3 yield the following system T (R, Π).
For the sake of saving space we abbreviate app by a, take by t and inf by i.
      </p>
      <p>top(i(x)) → top(x : i(s(x)))
a(y, i(x)) → a(y, x : i(s(x)))
t(a(i(x), y), z) → t(a(x : i(s(x)), y), z)
a(a(i(x), y), z) → a(a(x : i(s(x)), y), z)
top(a(x : xs, ys)) → top(x : a(xs, ys))
a(a(x : xs, ys), z) → a(x : a(xs, ys), z)</p>
      <p>a(x : i(zs), ys) → x : a(i(zs), ys)
a(x : (y : zs), ys) → x : a(y : zs, ys)
t(s(x), y : ys) → t(x, ys)
t(x, nil) → 0</p>
      <p>t(y, i(x)) → t(y, x : i(s(x)))
top(a(i(x), y)) → top(a(x : i(s(x)), y))
t(z, a(i(x), y)) → t(z, a(x : i(s(x)), y))
a(z, a(i(x), y)) → a(z, a(x : i(s(x)), y))
t(z, a(x : xs, ys)) → t(z, x : a(xs, ys))
a(z, a(x : xs, ys)) → a(z, x : a(xs, ys))
a(x : s(zs), ys) → x : a(s(zs), ys)</p>
      <p>a(nil, x) → x
t(0, y : ys) → y</p>
      <p>
        This system is terminating (and termination can be verified automatically, e.g. by AProVE [
        <xref ref-type="bibr" rid="ref12">12</xref>
        ]).
Hence, again by Corollary 1 also the TRS with forbidden patterns from Example 3 is ground terminating.
6
      </p>
    </sec>
    <sec id="sec-6">
      <title>Conclusion and Related Work</title>
      <p>We have presented and discussed a novel approach to rewriting with context restrictions using forbidden
patterns to specify forbidden/allowed positions in a term rather than arguments of functions as it was done
previously in context-sensitivity. Thanks to their flexibility and parametrizability, forbidden patterns are
applicable to a wider class of TRSs than traditional methods. In particular, position-based strategies and
context-sensitive rewriting occur as special cases of such patterns.</p>
      <p>For the TRSs in Examples 1 and 3 nice operational behaviours can be achieved by using rewriting
with forbidden patterns. The restricted reduction relation induced by the forbidden patterns is
terminating while still being powerful enough to compute (head-) normal forms. When using simpler approaches
such as position-based strategies or context-sensitive rewriting in these examples, such operational
properties cannot be achieved. For instance, consider Example 1. There is an infinite reduction sequence
starting from inf(x) with the property that every term has exactly one redex. Thus, non-termination is
preserved under any reduction strategy (as strategies do not introduce new normal forms by definition).
On the other hand, in order to avoid this infinite sequence using context-sensitive rewriting, we must
set 2 6∈ μ (:) (regardless of any additional reduction strategy). But in this case →μ does not compute
head-normal forms.</p>
      <p>
        In [
        <xref ref-type="bibr" rid="ref15">15</xref>
        ] on-demand rewriting was introduced, which is able to properly deal with the TRS of Example
1. This means that with the on-demand rewriting the reduction relation induced by the TRS of Example
1 can be restricted in a way such that it becomes terminating while still normal forms w.r.t. the restricted
relation are head-normal forms w.r.t. the unrestricted one. Indeed, Example 1 was the main motivating
example for the introduction of on-demand rewriting in [
        <xref ref-type="bibr" rid="ref15">15</xref>
        ].
      </p>
      <p>However, for Example 3 we get that by restricting rewriting by the proposed forbidden patterns we
obtain a terminating relation that is able to compute the normal forms of all well-formed ground terms. As
the system is orthogonal, any outermost-fair reduction strategy, e.g. parallel outermost, is normalizing.
Yet, by using such a strategy the relation still remains non-terminating. In particular, our forbidden
patterns approach yields an effective procedure for deciding whether a ground term is normalizing or not
(it is not normalizing if its →Π-normal form is not an →-normal form) for this example.</p>
      <p>On the other hand, by using context-sensitive rewriting, termination can only be obtained if 2 6∈ μ (:)
which in turn implies that the term 0 : app(nil, nil) cannot be normalized despite having a normal form
0 : nil.</p>
      <p>
        For Examples 1 and 3 effective strategies like parallel outermost or Sω of [
        <xref ref-type="bibr" rid="ref3">3</xref>
        ] are normalizing (though
under either strategy there are still infinite derivations). We provide another example for which these
strategies fail to provide normalization while the use of appropriate forbidden patterns yields
normalization (and termination)
Example 13. Consider the TRS R consisting of the following rules
      </p>
      <p>b → a
f (b, x) → d
c → c
Using a parallel outermost strategy the term g(a, b) is not reduced to its (unique) normal form d. Using
Sω , f (a, c) is not reduced to its (unique) normal form d.</p>
      <p>However, it is easy to see that when using a Π = {hc,ε , hi, hb,ε , hi}, →Π is terminating and all
R-normal forms can be computed.</p>
      <p>Note however, that the forbidden patterns used in Example 13 are not canonical. Thus it is not clear
how to come up with such patterns automatically.</p>
      <p>We argued that for our forbidden pattern approach it is crucial to identify reasonable classes of
patterns that provide trade-offs between practical feasibility, simplicity and power, favoring either
component to a certain degree. We have sketched and illustrated two approaches to deal with the issues of
verifying termination and guaranteeing that it is possible to compute useful results (in our case original
head-normal forms) with the restricted rewrite relation. To this end we proposed a transformation from
rewrite systems with forbidden patterns to ordinary rewrite systems and showed that ground
termination of both induced reduction relations coincide. Moreover, we provided a criterion based on canonical
rewriting with forbidden patterns to ensure that normal forms w.r.t. the restricted reduction relation are
original head-normal forms.</p>
      <p>In particular “here”-patterns seem interesting as their use avoids context restrictions to be non-local.
That is to say that whether a position is allowed for reduction or not depends only on a restricted “area”
around the position in question regardless of the actual size of the whole object term. Note that this is
not true for ordinary context-sensitive rewriting and has led to various complications in the theoretical
analysis (cf. e.g. [11, Definition 23] [1, Definition 7] and [13, Definitions 1-3]).</p>
      <p>Regarding future work, among many interesting questions and problems one particularly important
aspect is to identify conditions and methods for the automatic (or at least automatically supported)
synthesis of appropriate forbidden pattern restrictions.</p>
      <p>Acknowledgements: We are grateful to the anonymous referees for numerous helpful and detailed
comments and criticisms.</p>
    </sec>
  </body>
  <back>
    <ref-list>
      <ref id="ref1">
        <mixed-citation>
          [1]
          <string-name>
            <given-names>B.</given-names>
            <surname>Alarco´ n</surname>
          </string-name>
          ,
          <string-name>
            <given-names>F.</given-names>
            <surname>Emmes</surname>
          </string-name>
          ,
          <string-name>
            <given-names>C.</given-names>
            <surname>Fuhs</surname>
          </string-name>
          ,
          <string-name>
            <given-names>J.</given-names>
            <surname>Giesl</surname>
          </string-name>
          , R. Gutie´rrez, S. Lucas,
          <string-name>
            <given-names>P.</given-names>
            <surname>Schneider-Kamp</surname>
          </string-name>
          and
          <string-name>
            <given-names>R.</given-names>
            <surname>Thiemann</surname>
          </string-name>
          .
          <article-title>Improving context-sensitive dependency pairs</article-title>
          . In I. Cervesato,
          <string-name>
            <given-names>H.</given-names>
            <surname>Veith</surname>
          </string-name>
          and
          <string-name>
            <surname>A</surname>
          </string-name>
          . Voronkov, eds.,
          <source>Proc. LPAR'08</source>
          ,
          <string-name>
            <surname>Doha</surname>
          </string-name>
          , Qatar,
          <source>November 22-27</source>
          ,
          <year>2008</year>
          , LNCS 5330, pp.
          <fpage>636</fpage>
          -
          <lpage>651</lpage>
          . Springer,
          <year>2008</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref2">
        <mixed-citation>
          [2]
          <string-name>
            <given-names>M.</given-names>
            <surname>Alpuente</surname>
          </string-name>
          ,
          <string-name>
            <given-names>S.</given-names>
            <surname>Escobar</surname>
          </string-name>
          ,
          <string-name>
            <given-names>B.</given-names>
            <surname>Gramlich</surname>
          </string-name>
          and
          <string-name>
            <given-names>S.</given-names>
            <surname>Lucas</surname>
          </string-name>
          .
          <article-title>On-demand strategy annotations revisited: An improved on-demand evaluation Strategy</article-title>
          .
          <source>Theoretical Computer Science</source>
          ,
          <volume>411</volume>
          (
          <issue>2</issue>
          ):
          <fpage>504</fpage>
          -
          <lpage>541</lpage>
          ,
          <year>2010</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref3">
        <mixed-citation>
          [3]
          <string-name>
            <given-names>S.</given-names>
            <surname>Antoy</surname>
          </string-name>
          and
          <string-name>
            <given-names>A.</given-names>
            <surname>Middeldorp</surname>
          </string-name>
          .
          <article-title>A sequential reduction strategy</article-title>
          .
          <source>Theoretical Computer Science</source>
          ,
          <volume>165</volume>
          (
          <issue>1</issue>
          ):
          <fpage>75</fpage>
          -
          <lpage>95</lpage>
          ,
          <year>1996</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref4">
        <mixed-citation>
          [4]
          <string-name>
            <given-names>F.</given-names>
            <surname>Baader</surname>
          </string-name>
          and
          <string-name>
            <given-names>T.</given-names>
            <surname>Nipkow</surname>
          </string-name>
          .
          <source>Term rewriting and All That</source>
          . Cambridge University Press,
          <year>1998</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref5">
        <mixed-citation>
          [5]
          <string-name>
            <given-names>M.</given-names>
            <surname>Bezem</surname>
          </string-name>
          ,
          <string-name>
            <given-names>J.</given-names>
            <surname>Klop</surname>
          </string-name>
          , and R. de Vrijer, eds.
          <source>Term Rewriting Systems</source>
          . Cambridge Tracts in Theoretical Computer Science 55. Cambridge University Press, Mar.
          <year>2003</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref6">
        <mixed-citation>
          [6]
          <string-name>
            <given-names>F.</given-names>
            <surname>Dura</surname>
          </string-name>
          <article-title>´n, S</article-title>
          . Lucas, C. Marche´,
          <string-name>
            <given-names>J.</given-names>
            <surname>Meseguer</surname>
          </string-name>
          and
          <string-name>
            <given-names>X.</given-names>
            <surname>Urbain</surname>
          </string-name>
          .
          <article-title>Proving operational termination of membership equational programs</article-title>
          .
          <source>Higher-Order and Symbolic Computation</source>
          ,
          <volume>21</volume>
          (
          <issue>1-2</issue>
          ):
          <fpage>59</fpage>
          -
          <lpage>88</lpage>
          ,
          <year>2008</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref7">
        <mixed-citation>
          [7]
          <string-name>
            <given-names>S.</given-names>
            <surname>Eker</surname>
          </string-name>
          .
          <article-title>Term rewriting with operator evaluation strategies</article-title>
          .
          <source>Electr. Notes Theor. Comput. Sci.</source>
          ,
          <volume>15</volume>
          :
          <fpage>311</fpage>
          -
          <lpage>330</lpage>
          (
          <article-title>Proc</article-title>
          . WRLA'
          <volume>98</volume>
          ,
          <article-title>Abbaye des Pre´montre´s at Pont-a`-Mousson</article-title>
          , France,
          <year>September 1998</year>
          ,
          <string-name>
            <given-names>C.</given-names>
            <surname>Kirchner</surname>
          </string-name>
          and H. Kirchner, eds.),
          <year>1998</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref8">
        <mixed-citation>
          [8]
          <string-name>
            <given-names>J.</given-names>
            <surname>Endrullis</surname>
          </string-name>
          and
          <string-name>
            <given-names>D.</given-names>
            <surname>Hendriks</surname>
          </string-name>
          .
          <article-title>From outermost to context-sensitive rewriting</article-title>
          . In R. Treinen, ed.,
          <source>Proc. RTA'09</source>
          ,
          <string-name>
            <surname>Brasilia</surname>
          </string-name>
          , Brazil, June 29 - July 1,
          <year>2009</year>
          , LNCS 5595, pp.
          <fpage>305</fpage>
          -
          <lpage>319</lpage>
          , Springer,
          <year>June 2009</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref9">
        <mixed-citation>
          [9]
          <string-name>
            <given-names>W.</given-names>
            <surname>Fokkink</surname>
          </string-name>
          ,
          <string-name>
            <given-names>J.</given-names>
            <surname>Kamperman</surname>
          </string-name>
          and
          <string-name>
            <given-names>P.</given-names>
            <surname>Walters</surname>
          </string-name>
          .
          <article-title>Lazy rewriting on eager machinery</article-title>
          .
          <source>ACM Transactions on Programming Languages and Systems (TOPLAS)</source>
          ,
          <volume>22</volume>
          (
          <issue>1</issue>
          ):
          <fpage>45</fpage>
          -
          <lpage>86</lpage>
          ,
          <year>2000</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref10">
        <mixed-citation>
          [10]
          <string-name>
            <given-names>K.</given-names>
            <surname>Futatsugi</surname>
          </string-name>
          ,
          <string-name>
            <given-names>J.</given-names>
            <surname>Goguen</surname>
          </string-name>
          ,
          <string-name>
            <given-names>J.-P.</given-names>
            <surname>Jouannaud</surname>
          </string-name>
          and
          <string-name>
            <given-names>J.</given-names>
            <surname>Meseguer</surname>
          </string-name>
          .
          <source>Principles of OBJ2. In Conference Record of the 12th Annual ACM Symposium on Principles of Programming Languages (POPL'85)</source>
          , pp.
          <fpage>52</fpage>
          -
          <lpage>66</lpage>
          . ACM Press,
          <year>1985</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref11">
        <mixed-citation>
          [11]
          <string-name>
            <given-names>J.</given-names>
            <surname>Giesl</surname>
          </string-name>
          and
          <string-name>
            <given-names>A.</given-names>
            <surname>Middeldorp</surname>
          </string-name>
          .
          <article-title>Transformation techniques for context-sensitive rewrite systems</article-title>
          .
          <source>Journal of Functional Programming</source>
          ,
          <volume>14</volume>
          (
          <issue>4</issue>
          ):
          <fpage>379</fpage>
          -
          <lpage>427</lpage>
          , Jul.
          <year>2004</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref12">
        <mixed-citation>
          [12]
          <string-name>
            <given-names>J.</given-names>
            <surname>Giesl</surname>
          </string-name>
          ,
          <string-name>
            <given-names>P.</given-names>
            <surname>Schneider-Kamp and R. Thiemann</surname>
          </string-name>
          <article-title>AProVE 1.2: Automatic termination proofs in the dependency pair framework</article-title>
          . In U. Furbach and N. Shankar , eds.,
          <source>Proc. IJCAR'06</source>
          ,
          <string-name>
            <surname>Seattle</surname>
          </string-name>
          , Wasington, USA,
          <year>August</year>
          17-
          <issue>20</issue>
          ,
          <year>2006</year>
          , LNCS 4130, pp.
          <fpage>281</fpage>
          -
          <lpage>286</lpage>
          . Springer,
          <year>2006</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref13">
        <mixed-citation>
          [13]
          <string-name>
            <given-names>B.</given-names>
            <surname>Gramlich</surname>
          </string-name>
          and
          <string-name>
            <given-names>S.</given-names>
            <surname>Lucas</surname>
          </string-name>
          .
          <article-title>Generalizing Newman's Lemma for left-linear rewrite systems</article-title>
          . In F. Pfenning, ed.,
          <source>Proc. RTA'06</source>
          , Seattle, Washington, USA,
          <year>August</year>
          12-
          <issue>14</issue>
          ,
          <year>2006</year>
          , LNCS 4098, pp.
          <fpage>66</fpage>
          -
          <lpage>80</lpage>
          . Springer,
          <year>2006</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref14">
        <mixed-citation>
          [14]
          <string-name>
            <given-names>S.</given-names>
            <surname>Lucas</surname>
          </string-name>
          .
          <article-title>Context-sensitive computations in functional and functional logic programs</article-title>
          .
          <source>Journal of Functional and Logic Programming</source>
          ,
          <year>1998</year>
          (1), Jan.
          <year>1998</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref15">
        <mixed-citation>
          [15]
          <string-name>
            <given-names>S.</given-names>
            <surname>Lucas</surname>
          </string-name>
          .
          <article-title>Termination of on-demand rewriting and termination of OBJ programs</article-title>
          .
          <source>In Proc. PPDP'01, September 5-7</source>
          ,
          <year>2001</year>
          , Florence, Italy, pp.
          <fpage>82</fpage>
          -
          <lpage>93</lpage>
          . ACM,
          <year>2001</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref16">
        <mixed-citation>
          [16]
          <string-name>
            <given-names>S.</given-names>
            <surname>Lucas</surname>
          </string-name>
          .
          <article-title>Context-sensitive rewriting strategies</article-title>
          .
          <source>Information and Computation</source>
          ,
          <volume>178</volume>
          (
          <issue>1</issue>
          ):
          <fpage>294</fpage>
          -
          <lpage>343</lpage>
          ,
          <year>2002</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref17">
        <mixed-citation>
          [17]
          <string-name>
            <given-names>S.</given-names>
            <surname>Lucas</surname>
          </string-name>
          .
          <article-title>Lazy rewriting and context-sensitive rewriting</article-title>
          .
          <source>Electr. Notes Theor. Comput. Sci</source>
          .
          <volume>64</volume>
          :
          <fpage>234</fpage>
          -
          <lpage>254</lpage>
          (
          <article-title>Proc</article-title>
          . WFLP'
          <volume>01</volume>
          ,
          <string-name>
            <surname>Kiel</surname>
          </string-name>
          , Germany,
          <source>September 13-15</source>
          ,
          <year>2001</year>
          ,
          <string-name>
            <given-names>Selected</given-names>
            <surname>Papers</surname>
          </string-name>
          , M. Hanus, ed.),
          <year>2002</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref18">
        <mixed-citation>
          [18]
          <string-name>
            <surname>M.J. O'Donnell</surname>
          </string-name>
          .
          <article-title>Computing in systems described by equations</article-title>
          .
          <source>LNCS 58</source>
          , Springer,
          <year>1977</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref19">
        <mixed-citation>
          [19]
          <string-name>
            <given-names>F.</given-names>
            <surname>Schernhammer</surname>
          </string-name>
          and
          <string-name>
            <given-names>B.</given-names>
            <surname>Gramlich</surname>
          </string-name>
          .
          <article-title>Termination of lazy rewriting revisited</article-title>
          .
          <source>Electronic Notes in Theoretical Computer Science</source>
          ,
          <volume>204</volume>
          :
          <fpage>35</fpage>
          -
          <lpage>51</lpage>
          (
          <string-name>
            <given-names>Final</given-names>
            <surname>Proc. WRS</surname>
          </string-name>
          '
          <volume>07</volume>
          , Ju¨ rgen Giesl, ed.), Apr.
          <year>2008</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref20">
        <mixed-citation>
          [20]
          <string-name>
            <given-names>F.</given-names>
            <surname>Schernhammer</surname>
          </string-name>
          and
          <string-name>
            <given-names>B.</given-names>
            <surname>Gramlich</surname>
          </string-name>
          .
          <article-title>Characterizing and proving operational termination of deterministic conditional term rewriting systems</article-title>
          .
          <source>Journal of Logic and Algebraic Programming</source>
          ,
          <source>Selected revised papers of NWPT'08</source>
          , to appear,
          <year>2009</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref21">
        <mixed-citation>
          [21]
          <string-name>
            <given-names>F.</given-names>
            <surname>Schernhammer</surname>
          </string-name>
          and
          <string-name>
            <given-names>B.</given-names>
            <surname>Gramlich. VMTL -</surname>
          </string-name>
          <article-title>a modular termination laboratory</article-title>
          . In R. Treinen, ed.,
          <source>Proc. RTA'09</source>
          ,
          <string-name>
            <surname>Brasilia</surname>
          </string-name>
          , Brazil, June 29 - July 1,
          <year>2009</year>
          , LNCS 5595, pp.
          <fpage>285</fpage>
          -
          <lpage>294</lpage>
          , Springer,
          <year>June 2009</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref22">
        <mixed-citation>
          [22]
          <string-name>
            <given-names>F.</given-names>
            <surname>Schernhammer</surname>
          </string-name>
          and
          <string-name>
            <given-names>B.</given-names>
            <surname>Gramlich</surname>
          </string-name>
          .
          <article-title>On some implementation aspects of VMTL. In A. Geser and</article-title>
          J. Waldmann, eds.,
          <source>Proc. WST'09</source>
          , Leipzig, Germany, pp.
          <fpage>72</fpage>
          -
          <lpage>75</lpage>
          ,
          <year>June 2009</year>
          .
        </mixed-citation>
      </ref>
    </ref-list>
  </back>
</article>