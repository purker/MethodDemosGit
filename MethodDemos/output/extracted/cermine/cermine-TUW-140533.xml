<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
  <front>
    <journal-meta />
    <article-meta>
      <title-group>
        <article-title>Formal Program Verification: a Comparison of Selected Tools and Their Theoretical Foundations</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <string-name>unter der Anleitung von</string-name>
          <xref ref-type="aff" rid="aff0">0</xref>
          <xref ref-type="aff" rid="aff1">1</xref>
          <xref ref-type="aff" rid="aff2">2</xref>
        </contrib>
        <aff id="aff0">
          <label>0</label>
          <institution>A.o.Univ.</institution>
          <addr-line>Prof. DI. Dr. Gernot Salzer</addr-line>
        </aff>
        <aff id="aff1">
          <label>1</label>
          <institution>Theory and Logic Group Institute of Computer Languages Vienna University of Technology</institution>
        </aff>
        <aff id="aff2">
          <label>2</label>
          <institution>durch Ingo Feinerer</institution>
          ,
          <addr-line>Bakk.techn. Felixdorfer Gasse 11 A-2700 Wiener Neustadt</addr-line>
        </aff>
      </contrib-group>
      <pub-date>
        <year>2003</year>
      </pub-date>
      <fpage>45</fpage>
      <lpage>86</lpage>
    </article-meta>
  </front>
  <body>
    <fig>
      <graphic xlink:href="D:\output\methods\cermine\cermine-TUW-140533.images\img_37_1.png" />
    </fig>
    <sec id="sec-1">
      <title>Zusammenfassung</title>
      <p>Formale Spezifikation und Verifikation sind durch die durch kontinuierliche
Weiterentwicklung in letzter Zeit an einem Punkt angelangt, wo Programme
beinahe automatisch verifiziert werden k¨onnen.</p>
      <p>Das Ziel dieser Magisterarbeit ist es, sowohl kommerzielle als auch fu¨r
wissenschaftliche Zwecke entwickelte Verifikationsprogramme zu testen. Der
Hauptaugenmerk liegt auf dem Nutzen dieser Werkzeuge in der
SoftwareEntwicklung und in der Lehre. Hierzu wird diese Magisterarbeit die
theoretischen Grundlagen vorstellen und auf die verschiedenen F¨ahigkeiten und
Eigenheiten der ausgew¨ahlten Werkzeuge eingehen.</p>
      <p>Die theoretischen Grundlagen behandeln einerseits Ans¨atze, die fu¨r die
formale Verifikation gebraucht werden, andererseits wird die Funktionsweise
der ausgew¨ahlten Werkzeuge erkl¨art.</p>
      <p>Die begutachteten Programme sind der Frege Program Prover, KeY,
Perfect Developer und das Prototype Verification System. Die Beispiele, mit
denen diese Werkzeuge getestet werden, sind typische Problemstellung der
Informatik. Bei der Evaluation wird auf den ganzen Ablauf beim Einsatz
dieser Werkzeuge eingegangen und nicht nur auf das Endergebnis.
Formal specification and verification of software have made small but
continuous advances throughout its long history, and have reached a point where
commercial tools became available for verifying programs semi-automatically
or automatically.</p>
      <p>The aim of the master thesis is to evaluate commercial and academic
verification tools with respect to their usability in developing software and in
teaching formal methods. The thesis will explain the theoretical foundation
and compare the capabilities and characteristics of selected commercial and
academic tools on concrete examples.</p>
      <p>The theoretical foundations deal on the one hand with the general ideas
and principles of formal software verification, on the other hand present some
internals of the selected tools to give a comprehensive understanding.</p>
      <p>The discussed tools are the Frege Program Prover, KeY, Perfect
Developer, and the Prototype Verification System. The examples encompass
simple standard computer science problems. The evaluation of these tools
concentrates on the whole development process of specification and
verification, not just on the verification results.</p>
    </sec>
    <sec id="sec-2">
      <title>Acknowledgements</title>
      <p>I would like to thank my family, especially my mother Inge, for supporting
me.</p>
      <p>Gernot Salzer, my advisor, helped me whenever he could and invested
a lot of time in discussing and investigating problems together with me.
David Crocker gave excellent support on Perfect Developer, Andreas Roth
and Steffen Schlager offered helpful instructions on KeY, Ju¨rgen Winkler
provided papers and references on FPP. Also the subscribers of the PVS
mailing list came up with nice ideas.
1 Introduction
4 Examples 34
4.1 Criteria . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
4.2 Methodology . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
4.3 Frege Program Prover . . . . . . . . . . . . . . . . . . . . . . 37
4.3.1 Cubic sum . . . . . . . . . . . . . . . . . . . . . . . . . 38
4.3.2 Division . . . . . . . . . . . . . . . . . . . . . . . . . . 39
4.3.3 Factorial . . . . . . . . . . . . . . . . . . . . . . . . . . 42
4.3.4 Fibonacci numbers . . . . . . . . . . . . . . . . . . . . 43
4.3.5 Inconsistency test . . . . . . . . . . . . . . . . . . . . . 46
4.3.6 Multiplication . . . . . . . . . . . . . . . . . . . . . . . 48
4.3.7 False theorem test . . . . . . . . . . . . . . . . . . . . 49
4.3.8 Correct theorem test . . . . . . . . . . . . . . . . . . . 50
4.3.9 Conditional weakest precondition . . . . . . . . . . . . 51
4.4 KeY System . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
4.4.1 Cubic sum . . . . . . . . . . . . . . . . . . . . . . . . . 53
4.4.2 Conditional . . . . . . . . . . . . . . . . . . . . . . . . 54
4.4.3 Division . . . . . . . . . . . . . . . . . . . . . . . . . . 56
4.4.4 Factorial . . . . . . . . . . . . . . . . . . . . . . . . . . 57
4.4.5 List maximum . . . . . . . . . . . . . . . . . . . . . . . 58
4.4.6 Multiplication . . . . . . . . . . . . . . . . . . . . . . . 59
4.4.7 Prime . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
4.5 Perfect Developer . . . . . . . . . . . . . . . . . . . . . . . . . 62
4.5.1 Cubic sum . . . . . . . . . . . . . . . . . . . . . . . . . 63
4.5.2 Factorial . . . . . . . . . . . . . . . . . . . . . . . . . . 63
4.5.3 Intersection . . . . . . . . . . . . . . . . . . . . . . . . 64
4.5.4 Inversions . . . . . . . . . . . . . . . . . . . . . . . . . 66
4.5.5 List maximum . . . . . . . . . . . . . . . . . . . . . . . 67
4.5.6 Multiplication . . . . . . . . . . . . . . . . . . . . . . . 68
4.5.7 Prime . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
4.5.8 Quicksort . . . . . . . . . . . . . . . . . . . . . . . . . 70
4.6 PVS Specification and Verification System . . . . . . . . . . . 71
4.6.1 Cubic sum . . . . . . . . . . . . . . . . . . . . . . . . . 72
4.6.2 Factorial . . . . . . . . . . . . . . . . . . . . . . . . . . 73
4.6.3 Inversions . . . . . . . . . . . . . . . . . . . . . . . . . 74
4.6.4 Multiplication . . . . . . . . . . . . . . . . . . . . . . . 75
4.6.5 Quicksort . . . . . . . . . . . . . . . . . . . . . . . . . 76</p>
      <sec id="sec-2-1">
        <title>5 Summary 79</title>
      </sec>
    </sec>
    <sec id="sec-3">
      <title>Introduction</title>
      <p>Formal software verification has become a more and more important issue in
developing security related software during the last decades. As a reaction,
ISO — the International Organisation for Standardisation — issued the ISO
15408 Standard, defining exactly various quality levels for tested and verified
software. This standard is represented in the Common Criteria Project, with
members of security organisations around the globe.</p>
      <p>During the last years, formal specification and verification tools have been
introduced, especially designed for standard development processes. The
focus ranges from security related projects, over hardware circuit verification
to software driver verification. In particular model checking has been very
successful.</p>
      <p>Based on this evolution this thesis deals with four specification and
verification tools that enable the user to build software complying with the most
demanding restrictions of the ISO 15408 Standard. The aim is to construct
software that meets the Evaluation Assurance Levels 6 and 7 (EAL 6, EAL
7) defined in the Common Criteria Project. In other words this means fully
verified specification and code.</p>
      <p>For a long time users of these tools have been assumed to be experts in
formal methods. With new target groups requirements changed. Therefore
this thesis evaluates the tools with respect to two groups: software engineers
with a good knowledge of computer science but without specific training in
formal methods, and students of computer science and software engineering
in the middle of their studies, being confronted with formal verification tools
for the first time.</p>
      <p>The four tools that will be investigated are the Frege Program Prover,
KeY, Perfect Developer, and the Prototype Verification System. In the first
part of this work, the theoretical background — main calculi and ideas of
formal verification — is presented. Then the internals of the tools are
discussed, showing the different approaches and techniques from the theoretical
side. Finally, by going through a set of simple standard computer science
examples, the different characteristics and capabilities are presented in a
practical form. By examining the tools from both sides, theory and practice,
their usability in developing software and in teaching formal methods for the
above defined target group is discussed.</p>
      <sec id="sec-3-1">
        <title>Historical perspective</title>
        <p>Formal verification has always been a well discussed problem by a lot of
excellent computer scientists. Jones [2003] mentions three phases of historical
development:
Pre-Hoare Herman Goldstine, John von Neumann, Alan Turing, Robert
Floyd and John McCarthy are only some famous computer pioneers
that can be mentioned here. They started thinking about errors in
their programs from the start on and had already ideas to avoid them.</p>
        <p>The idea of assertions for programs was borne.</p>
        <p>Hoare’s axiomatic approach Tony Hoare presented his axioms in his
famous paper Hoare [1969] — the calculus is also discussed in section 2.4
of this thesis. This formulation led to new approaches towards formal
verification in the late 1970s.</p>
        <p>Post-Hoare After Hoare’s axiomatic approach formal verification became
a broad scientific research problem with connections to the semantics
of programming languages. Many scientists, like Edsger Dijkstra, Tony
Hoare himself and many more, continued to work on these foundations
and made continuous improvements.</p>
        <p>Until today automatic verification is an intensively considered problem. E.g.
Tony Hoare stated the problem of building a “verifying compiler” as one of
the big challenges of computer science in his paper Hoare [2003]. Also the
idea of reusing verified software is appreciated by the scientific community
— Meyer [2003] deals in detail with that idea.</p>
      </sec>
    </sec>
    <sec id="sec-4">
      <title>Theoretical Foundations</title>
      <p>This section deals with general ideas and principles underlying formal
software verification and explains basic notions and calculus frameworks.</p>
      <p>The reader is assumed to have a minimal background on formal logic,
especially in classical propositional and first order logic. Detailed explanations
of these basics are given in Gallier [2003] or Huth and Ryan [2004].</p>
      <p>The following sections discuss an introduction to propositional logic,
natural deduction, the sequent calculus, the Hoare calculus and weakest
preconditions.</p>
      <p>We present only rules for propositional logic to give the flavour of the
various approaches. Real systems for proving statements about programs
are more complex in at least two respects: first, propositional logic has to
be extended to first-order or even higher-order logics, i.e., in general we need
quantification over first-order or higher-order variables. Second, provers need
built-in knowledge about the data types used in programs and formal
specifications, like reals and integers, lists and sets. Moreover, special mechanisms
have to be provided to deal with equalities, inequalities and other basic
theories, using e.g. decision procedures.
2.1</p>
      <sec id="sec-4-1">
        <title>Propositional Logic</title>
        <p>This section deals with the basics of propositional classical logic. The
following notations will be used as the basic formalism in later chapters.</p>
        <sec id="sec-4-1-1">
          <title>Syntax</title>
          <p>The alphabet for propositional formulas consists of:
A countable set of propositional symbols Ai,
logical connectives ∨, ∧, ¬, ⊃, ⊥ and
auxiliary symbols (parentheses).</p>
          <p>Definition 2.1 The set of well formed propositional formulas PROP is
inductively defined as:</p>
          <p>Every propositional symbol Ai and ⊥ are ∈ PROP ,
Whenever A, B ∈ PROP , then ¬A, A ⊃ B, A ∨ B, A ∧ B ∈ PROP .
Definition 2.2 A valuation v is a function that maps well formed
propositional formula to truth values, hence v : PROP 7→ {true, false}.
Let A, B ∈ PROP . We write v |= A iff A evaluates to true under the
valuation v. The satisfaction relation is defined as:
v |= A iff v(A) = true
v |= A ∧ B iff v |= A and v |= B
v |= A ∨ B iff v |= A or v |= B
v |= A ⊃ B iff v 2 A or v |= B
v |= ¬A iff v 2 A
2.2</p>
        </sec>
      </sec>
      <sec id="sec-4-2">
        <title>Natural Deduction</title>
        <p>Let φ1, φ2, φ3, . . . , φn be formulas, which are called premises, and ψ be
another formula called conclusion.</p>
        <p>Definition 2.3 The expression φ1, φ2, φ3, . . . , φn ` ψ is called sequent.
But instead of φ1, φ2, φ3, . . . , φn ` ψ we write
φ1
φ2
. . .</p>
        <p>φn
φ3
ψ
This means that if all premises φ1, φ2, φ3, . . . , φn are true, we conclude that
the conclusion ψ is true.</p>
        <p>From now on let φ, ψ and χ denote propositional formulas. The
natural deduction rules for propositional logic distinguish between introduction
(i-rules) and elimination (e-rules) rules for connectives and are defined as
follows:
Disjunction Rules:</p>
        <p>∨i1
∨e</p>
        <p>φ
φ ∨ ψ
φ ∨ ψ</p>
        <p>∨i2
φ ` χ</p>
        <p>χ</p>
        <p>ψ
φ ∨ ψ
ψ ` χ</p>
        <sec id="sec-4-2-1">
          <title>Implication Rules:</title>
        </sec>
        <sec id="sec-4-2-2">
          <title>Negation Rules:</title>
        </sec>
        <sec id="sec-4-2-3">
          <title>Bottom Rule:</title>
        </sec>
        <sec id="sec-4-2-4">
          <title>Double Negation Rule: Some Derived Rules:</title>
          <p>∧e1
φ ∧ ψ</p>
          <p>ψ
∧i
φ ∧ ψ
φ
⊃ i
⊃ e
φ
φ ψ
φ ∧ ψ</p>
          <p>∧e2
φ ` ψ
φ ⊃ ψ
φ ⊃ ψ
φ
¬i
¬e</p>
          <p>⊥e
¬¬e
φ ` ⊥</p>
          <p>¬φ
φ</p>
          <p>¬φ
⊥
⊥
φ
¬¬φ</p>
          <p>φ
¬¬i</p>
          <p>φ
¬¬φ
Modus tollens
φ ⊃ ψ
¬φ</p>
          <p>¬ψ
Reductio ad absurdum</p>
          <p>Tertium non datur
¬φ ` ⊥</p>
          <p>φ
φ ∨ ¬φ
Definition 2.4 A proof in natural deduction is the smallest set X such that
the one element tree φ belongs to X for all well formed propositional
formulas φ and
if φ ∈ X, ψ ∈ X and χ ∈ X, then every application of the above defined
natural deduction rules is ∈ X.</p>
          <p>Definition 2.5 Logical formulas φ such that ` φ holds are called theorems.
Definition 2.6 Two formulas of propositional logic φ and ψ are called
provably equivalent iff φ ` ψ and ψ ` φ.</p>
          <p>Proposition 2.7 The natural deduction calculus for propositional formulas
is sound.</p>
          <p>Proposition 2.8 The natural deduction calculus for propositional formulas
is complete.</p>
          <p>More information on natural deduction can be looked up in Huth and
Ryan [2004] and van Dalen [2004].
2.3</p>
        </sec>
      </sec>
      <sec id="sec-4-3">
        <title>Sequent Calculus</title>
        <p>The sequent calculus was originally developed by Gentzen, and published in
one of his famous papers [Gentzen, 1935].</p>
        <p>Definition 2.9 A sequent is a pair (Γ, Δ) of finite multi-sets of propositional
formulas.</p>
        <p>It should be mentioned that some authors (like Fitting [1990]) define a
sequent as a set of formulas, others as a sequence.</p>
        <p>Instead of (Γ, Δ) the notation Γ → Δ is common. Γ is called antecedent
and Δ succedent. For simplicity, propositional sequents {A1, . . . , An} →
{B1, . . . , Bm} are denoted as A1, . . . , An → B1, . . . , Bm. Similarly, we write
→ Δ and Γ → if Γ and Δ is empty, respectively.</p>
        <p>A valuation v makes a sequent A1, . . . , An → B1, . . . , Bm true iff
v |= (A1 ∧ . . . ∧ An) ⊃ (B1 ∨ . . . ∨ Bm)</p>
        <p>Let Γ, Δ be arbitrary propositional sequents and let A and B be
propositions. The rules in the Gentzen System are then as follows:</p>
        <sec id="sec-4-3-1">
          <title>Conjunction Rules:</title>
        </sec>
        <sec id="sec-4-3-2">
          <title>Implication Rules: Negation Rules:</title>
          <p>(∨-l)
Γ, A ` Δ Γ, B ` Δ</p>
          <p>Γ, A ∨ B ` Δ
(∨-r)
(∧-l)
Γ ` Δ, A, B
Γ ` Δ, A ∨ B
Γ, A, B ` Δ
Γ, A ∧ B ` Δ
(∧-r)
(⊃-l)
Γ ` Δ, A Γ ` Δ, B</p>
          <p>Γ ` Δ, A ∧ B
Γ ` Δ, A Γ, B ` Δ</p>
          <p>Γ, A ⊃ B ` Δ
(⊃-r)</p>
          <p>Γ, A ` Δ, B
Γ ` Δ, A ⊃ B
(¬-l)
(¬-r)
Γ ` Δ, A
Γ, ¬A ` Δ
Γ, A ` Δ
Γ ` Δ, ¬A
Every rule consists of one or two upper sequents called premises, and one
lower sequent called conclusion.</p>
          <p>Definition 2.10 A sequent A1, . . . , An → B1, . . . , Bm is falsifiable iff there
exists a valuation v such that
v |= (A1 ∧ . . . ∧ An) ∧ (¬B1 ∧ . . . ∧ ¬Bm).
Definition 2.11 A sequent A1, . . . , An → B1, . . . , Bm is valid iff for every
valuation v</p>
          <p>v |= (A1 ∧ . . . ∧ An) ⊃ (B1 ∨ . . . ∨ Bm).</p>
          <p>This is also denoted by</p>
          <p>|= (A1, . . . , An) → (B1, . . . , Bm).</p>
          <p>Definition 2.12 An axiom is any sequent Γ → Δ such that Γ and Δ contain
some common formula.</p>
          <p>Proposition 2.13 Every axiom is valid.</p>
          <p>A deduction tree is a tree whose nodes are labelled with sequents. Every
sequent at an inner node must be obtained from the sequents at its children
nodes by applying one of the rules of sequent calculus. The label on the
root is the sequent that is proved. It is called the conclusion. A proof is a
deduction tree that has only axioms as leaves. A counterexample is a sequent
consisting only of propositional letters that is no axiom. A failed deduction
tree is a deduction tree with a counterexample as one of its leaves. A sequent
is provable iff there is a proof tree of which it is the conclusion. If a sequent
Γ → Δ is provable, it is denoted as</p>
          <p>` Γ → Δ.</p>
          <p>Proposition 2.14 The Gentzen calculus for formulas in propositional logic
is sound. Thus, if a sequent Γ → Δ is provable, then it is valid.
Proposition 2.15 The Gentzen calculus for propositional formulas is
complete. Thus, every valid sequent is provable. Furthermore there exists an
algorithm for deciding whether a sequent is valid and if so, a proof tree is
generated.</p>
          <p>The interested reader may find additional material in Gallier [2003] and
Salzer [2002].
2.4</p>
        </sec>
      </sec>
      <sec id="sec-4-4">
        <title>Hoare Calculus</title>
        <p>This calculus was introduced in Hoare [1969].</p>
        <p>The input-output relation for a program S is specified as follows:
{P } S {Q}.
P and Q are logic formulas. In this context they are often called assertions
or conditions. P is the precondition and Q is the postcondition. The
precondition describes the set of intended initial states for the program S, whereas
the postcondition describes the set of final states for S, if S terminates.
Definition 2.16 {P } S {Q} is partially correct if every terminating
computation of S starting from a P -state ends up in a Q-state.</p>
        <p>Definition 2.17 {P } S {Q} is called totally correct if every computation
of S starting from a P -state terminates and ends up in a Q-state.</p>
        <p>The Hoare calculus proves the correctness of programs with a
syntaxdriven axiomatic system. The Hoare System consists of the following axioms
and rules:</p>
        <sec id="sec-4-4-1">
          <title>Skip statement:</title>
        </sec>
        <sec id="sec-4-4-2">
          <title>Assignment statement:</title>
          <p>{P } skip {P }
{P vt } v ← t {P }
where P vt describes the state P except that v has the value of t.</p>
        </sec>
        <sec id="sec-4-4-3">
          <title>Composition rule:</title>
        </sec>
        <sec id="sec-4-4-4">
          <title>Conditional rule: Loop rule:</title>
          <p>{P } S1 {R}</p>
          <p>{R} S2 {Q}
{P } S1; S2 {Q}
{P ∧ B} S1 {Q} {P ∧ ¬B} S2 {Q}
{P } if B then S1 else S2 {Q}
{P ∧ B} S {P }
{P } while B do S {P ∧ ¬B}</p>
        </sec>
        <sec id="sec-4-4-5">
          <title>Consequence rule:</title>
          <p>P ⊃ P1
{P1} S {Q1}
{P } S {Q}</p>
          <p>Q1 ⊃ Q
The rules presented so far are not enough to prove the termination of any
program. This system is only able to prove partial correctness. In order to
prove total correctness, it is necessary to adapt the loop rule:</p>
        </sec>
        <sec id="sec-4-4-6">
          <title>Loop rule 2:</title>
          <p>{P ∧ B} S {P }
{P ∧ B ∧ (t = x)} S {t &lt; x}</p>
          <p>P ⊃ t ≥ 0
{P } while B do S {P ∧ ¬B}
Notice that t is an integer expression and x is an integer variable that is not
part of P , B, t or S.</p>
          <p>Proposition 2.18 The Hoare calculus for the partial correctness of
programs is sound.</p>
          <p>Proposition 2.19 The Hoare calculus for the total correctness of programs
is sound.</p>
          <p>Proposition 2.20 The Hoare calculus for the partial correctness of
programs is complete.</p>
          <p>Further information can be found in Apt and Olderog [1994] or Salzer
[2002].
2.5</p>
        </sec>
      </sec>
      <sec id="sec-4-5">
        <title>Weakest Preconditions</title>
        <p>Let S be a program statement and let Q be a predicate.</p>
        <p>Definition 2.21 The weakest precondition wp(S, Q) is the set of initial
states, described by a predicate, for which S terminates and Q is true on
termination.</p>
        <p>In contrast to the axiomatic Hoare logic the termination is inherent in the
definition of pre- and postconditions.</p>
        <p>Proposition 2.22 A program S is correct with respect to the predicates P
and Q if P ⊃ wp(S, Q).</p>
        <p>Weakest preconditions satisfy the following properties:
wp(S, false) = false</p>
        <p>P ⊃ Q
wp(S, P ) ⊃ wp(S, Q)</p>
        <p>wp(S, P ∨ Q)
wp(S, P ) ∨ wp(S, Q)</p>
        <p>wp(S, P ∧ Q)
wp(S, P ) ∧ wp(S, Q)
The weakest preconditions for typical program statements can be computed
as follows:</p>
        <sec id="sec-4-5-1">
          <title>Skip rule:</title>
        </sec>
        <sec id="sec-4-5-2">
          <title>Assignment rule:</title>
        </sec>
        <sec id="sec-4-5-3">
          <title>Composition rule:</title>
        </sec>
        <sec id="sec-4-5-4">
          <title>Conditional rule: Loop rule:</title>
          <p>where</p>
          <p>wp(skip, Q) = Q
wp(v ← t, Q) = Q vt
wp(S1; S2, Q) = wp(S1, wp(S2, Q))
wp(if B then S1 else S2, Q) = (B ⊃ wp(S1, Q)) ∧ (¬B ⊃ wp(S2, Q))
= (B ∧ wp(S1, Q)) ∨ (¬B ∧ wp(S2, Q))
wp(while B do S, Q) = H(Q)</p>
          <p>= H0(Q) ∧ H1(Q) ∧ H2(Q) ∧ H3(Q) ∧ . . .</p>
          <p>H0(Q) = ¬B ⊃ Q</p>
          <p>Hk+1(Q) = B ⊃ wp(S, Hk(q))</p>
          <p>For additional material consult Gannon et al. [1993], Gries [1989] or
Dijkstra and Scholten [1990]. For the advanced reader, Winkler [1995] discusses
the different views and implications of weakest precondition as a predicate
transformer versus the idea of weakest precondition as a state set transformer.</p>
        </sec>
      </sec>
    </sec>
    <sec id="sec-5">
      <title>Selected Tools</title>
      <p>This section introduces the reader to the tested tools in a theoretical fashion.
We evaluate the verification tools with respect to the following intended users:
Software engineers with a good knowledge of computer science but
without specific training in formal methods
Students of computer science and software engineering in the
middle of their studies, being confronted with formal verification tools for
the first time.</p>
      <p>The four tools selected for this thesis are:
Frege Program Prover (FPP) FPP was chosen because of its academic
nature. It was explicitly designed for teaching formal methods. It is
also a candidate for being used in some lectures at the TU Vienna.
The tested version is available as web service, which was last updated
on May 22, 2001.</p>
      <p>KeY System (KeY) KeY is the successor of the Karlsruhe integrated
Verifier (KiV). KiV has a long tradition and is well known in academia.
The KeY system is, at least concerning its intentions, one of the few
systems comparable to FPP and PD.</p>
      <p>The tested version is KeY-0.1342, the most recent internal version
provided by the KeY team.</p>
      <p>Perfect Developer (PD) PD was already used for internships and courses
at TU Vienna and claims to be one of the few existing commercial tools
that can be used by almost any person with just a little knowledge of
formal methods.</p>
      <p>The tested version is Perfect Developer 2.00.</p>
      <p>Prototype Verification System (PVS) PVS is famous and widely cited,
and has served as a reference for many years. Therefore it is included
in this comparison even though it aims mainly at verification of
algorithms, not programs.</p>
      <p>The tested version is PVS 3.2.
Further tools We list some other tools, which are of interest in the context
of software verification, but which will not be discussed in detail.
Isabelle Isabelle can be obtained from www.cl.cam.ac.uk/Research/HVG/
Isabelle/. It provides a generic theorem prover, supports higher-order
logic, ZF set theory and a lot of other features. It is developed at the
Cambridge University and TU Munich.</p>
      <p>ACL2 ACL is both a programming language in which one can model
computer systems and a tool for proving properties of those models. It can
be found at http://www.cs.utexas.edu/users/moore/acl2/.
B-Method The B-Method includes the B-Tool and B-Toolkit and is in
detail explained at http://vl.fmnet.info/b/.</p>
      <p>Model Checking Tools Model checking tools have been very successful in
real world applications during the last years. Examples are
SPIN (http://spinroot.com),
SMV (http://www-2.cs.cmu.edu/∼modelcheck/smv.html) and
SLAM (http://research.microsoft.com/slam/) used for driver
verification.</p>
      <p>A more extensive overview and description on various tools can be found at
the formal methods virtual library at http://vl.fmnet.info/#notations.
Related work In general there do not exist many comparisons in the style
of this thesis. Special impact on this work had Griffioen and Huisman [1998].
They compare PVS and Isabelle by implementing some examples and
investigating the logics behind these tools. They come to the result that both
tools are very powerful, but also have some weak points. They give advice
on how to combine both tools to obtain even better proofs. Zolda [2004]
compares Isabelle and ACL2 and points out the different approaches. He
comes to the conclusion that both tools have a lot of functionality but need
a good background in logic. Freining et al. [2002] compare FPP with NPPV
and SPARK. NPPV and SPARK have advantages in special tasks, but FPP
is the winner in the specified test environment.
3.2</p>
      <sec id="sec-5-1">
        <title>Frege Program Prover</title>
        <p>The Frege Program Prover, from now on called FPP, was developed at the
University of Jena, Department of Mathematics and Computer Science,
Programming Languages and Compilers.</p>
        <p>Find an introduction to FPP at http://psc.informatik.uni-jena.de/
Fpp/fpp-intr.htm, whereas the system itself can be found at http://psc.
informatik.uni-jena.de/FPP/FPP-main.htm.</p>
        <p>FPP is an experimental system, implemented as a web application, for
analysing the semantics of programs and for performing correctness proofs
of annotated programs. FPP supports a subset of Ada — the concrete FPP
syntax can be found at psc.informatik.uni-jena.de/Fpp/fpp-synt.htm.
Identifiers are assumed to be integer or boolean variables.</p>
        <p>FPP offers various capabilities:
Computation of the weakest precondition FPP computes the weakest
precondition for a given program statement S in combination with a
given postcondition Q. The internal mechanism is mainly based on the
calculations of weakest preconditions as presented in section 2.5.
Check for the correctness of a program Given a precondition P , a
program S and a postcondition Q, FPP checks whether the Hoare triple
{P } S {Q} is consistent. Such a triple is called consistent, if the
program S satisfies the conditions stated by the precondition P and the
postcondition Q. Hence FPP checks consistency by testing</p>
        <p>P ⊃ wp(S, Q)
Theorem prover FPP can be used as a theorem prover by setting the
precondition P to “true”, the program S to “NULL” and the postcondition
Q to the theorem that needs to be proved. The typical structure of such
an FPP instance looks like:
--!Pre: true;
NULL;
--!Post: &lt;theorem to be proved&gt;;
It should be mentioned that this functionality is a logical consequence
of the two previous capabilities. It is not considered to be competitive
with other pure theorem provers.
function cardIntSec(A: seq of nat, B: seq of nat): nat
pre A.isndec, B.isndec
satisfy result = #(those x::A :- (exists y::B :- x = y))
via
var cardCount: nat != 0;
loop
var a: nat != 0,</p>
        <p>b: nat != 0;
change cardCount
keep a’ &lt;= #A, b’ &lt;= #B, A.isndec &amp; B.isndec &amp;
#(those x::A :- (exists y::B :- x = y))
= cardCount’ + #(those x::A.drop(a’)</p>
        <p>:- (exists y::B.drop(b’) :- x = y))
until a’ = #A | b’ = #B
decrease (#A + #B) - (a’ + b’);
if
[A[a] = B[b]]:
cardCount! + 1,
a! + 1;
[A[a] &lt; B[b]]:</p>
        <p>a! + 1;
[A[a] &gt; B[b]]:</p>
        <p>b! + 1;
fi;
end;
value cardCount
end;</p>
        <sec id="sec-5-1-1">
          <title>Analysis</title>
          <p>Ease of problem formulation The declarative part was easy to formulate
and written within minutes. The implementation is longish and was
difficult to formulate.</p>
          <p>Complexity of user interaction The implementation part was tricky to
write and is error prone. Only after a lot of reformulations the number
of non verifiable obligations could be reduced. PD still could not prove
the invariant of this program.</p>
          <p>Degree of coverage Due to the complex implementation part PD could
not verify the whole program. Without the separate implementation
part PD could verify the whole program and was still able to produce
executable code. So the implementation with its improved performance
behaviour leads to not verifiable program fragments for PD.</p>
          <p>Support in finding errors PD gives good hints on errors or problematic
formulations in the declarative part, but fails to give such good reports
for the implementation part.</p>
        </sec>
        <sec id="sec-5-1-2">
          <title>4.5.4 Inversions</title>
          <p>Compute the number of inversions within a sequence of numbers.
Program code
function countInversions(A: seq of nat): nat
^= (
#flatten
(
)
)
assert result &lt; (#A)^2;</p>
        </sec>
        <sec id="sec-5-1-3">
          <title>Prover output</title>
          <p>for i::0..&lt;#A
yield for those j::0..&lt;#A
:- i &lt; j &amp; A[i] &gt; A[j]
yield pair of (nat, nat){i, j}
Failed to prove obligation: Assertion valid
In the context of class: Examples
Obligation location: Examples.pd (19,9)
Condition defined at: Examples.pd (30,19)
To prove:
#flatten(
(for i::0 .. &lt;#A yield
for those j::0 .. &lt;#A :- (i &lt; j) &amp;</p>
          <p>(A[j as nat] &lt; A[i as nat])
yield pair of (nat,nat) {i as nat,j as nat}))</p>
          <p>&lt; (#A ^ (2 as nat))
Reason: Exhausted rules
Could not prove:
(+ over for x::0 .. (-1 + #A) yield
#(those x::(0 .. (-1 + #A)).ranb
:</p>
          <p>(A[j] &lt; A[x]) and (j &lt; x))) &lt; (#A ^ 2)
Ease of problem formulation The formulation is tricky and needs
intricate operators to obtain the correct return type. Nevertheless the
formulation is very short and compact.</p>
          <p>Complexity of user interaction No modifications were necessary. The
proving process by PD is done without any user interaction.</p>
          <p>Degree of coverage All obligations can be discharged except the assertion
result &lt; (#A)^2. The proof requires induction, which is not
supported by PD.</p>
          <p>Support in finding errors As one can see from the prover output above,
PD shows what the problem is in verifying this program, but gives no
hint on how to solve it.</p>
        </sec>
        <sec id="sec-5-1-4">
          <title>4.5.5 List maximum</title>
          <p>Find the maximum from a list of numbers.</p>
          <p>Program code
function listMax(l: seq of nat, maxValue: nat,
maxValueIndex: nat, i: nat):</p>
          <p>pair of (nat, nat)
decrease #l
^= (
[#l = 0]:</p>
          <p>pair of (nat, nat){maxValue, maxValueIndex},
[l.head &gt; maxValue]:</p>
          <p>listMax(l.tail, l.head, i, i + 1),
listMax(l.tail, maxValue,</p>
          <p>maxValueIndex, i + 1)
)
assert (#l &gt; 0 &amp; maxValue = 0 &amp; maxValueIndex = 0 &amp; i = 0) ==&gt;
(result.x = l.max);</p>
        </sec>
        <sec id="sec-5-1-5">
          <title>Analysis</title>
          <p>Ease of problem formulation The functional recursive definition allows
a short formulation. Language constructs like pair and seq allow
sophisticated return types.</p>
          <p>Complexity of user interaction No extra user interaction was necessary.
Degree of coverage Everything except the final assertion can be proved.</p>
          <p>The final assertion requires induction, which is not supported by PD.
Support in finding errors PD signals that it cannot prove the final
assertion, but gives no help how to solve this.
4.5.6</p>
        </sec>
        <sec id="sec-5-1-6">
          <title>Multiplication</title>
          <p>Multiply two integer numbers.</p>
          <p>Program code
function mult(x: nat, y: nat, z: nat): nat
decrease y
^= (
[y = 0]:</p>
          <p>z,
)
assert result = (x * y + z);</p>
        </sec>
        <sec id="sec-5-1-7">
          <title>Analysis</title>
          <p>Ease of problem formulation The formulation was very easy and clear.</p>
          <p>No tricks were necessary.</p>
          <p>Complexity of user interaction None. Complete automatic verification.
Degree of coverage PD could verify the program completely.
Support in finding errors The output is clear and short for the trivial
example.
4.5.7 Prime
Tests whether a nonnegative number is prime.</p>
          <p>Program code
function factors(n: nat): seq of int
^= (</p>
          <p>those x::2..(n-1) :- (n % x) = 0
);
function isPrime(n: nat): bool
^= (
[n &lt; 2]:</p>
          <p>false,</p>
        </sec>
        <sec id="sec-5-1-8">
          <title>Analysis</title>
          <p>Ease of problem formulation PD allows to write down the
mathematical properties for primes in a very intuitive way. This minimises the
probability of introducing intricate errors already in the design phase.
Complexity of user interaction No fine tuning is necessary. The prover
works automatically.</p>
          <p>Degree of coverage All properties could be verified.</p>
          <p>Support in finding errors On the first attempt the assertion was specified
in the wrong way. The user could see immediately that PD could not
verify the final assertion.</p>
        </sec>
        <sec id="sec-5-1-9">
          <title>4.5.8 Quicksort</title>
          <p>Sorts a sequence of numbers according to the well known Quicksort algorithm
developed by Tony Hoare.</p>
          <p>Program code
function quickSort(numbers: seq of int): seq of int
decrease #numbers
^=
(
[#numbers = 0]:</p>
          <p>seq of int{},
let pivot ^= numbers.last;
let pivotindex ^= &lt;#numbers;
let rest ^= numbers.remove(pivotindex);
let smallerOrEqual ^= those x::rest
:</p>
          <p>x &lt;= pivot;
let bigger ^= those x::rest :- x &gt; pivot;
quickSort(smallerOrEqual).append(pivot)</p>
          <p>++ quickSort(bigger)
)
assert result.isndec;
Ease of problem formulation The functional definition of the Quicksort
algorithm is very intuitive and a real advantage. This avoids errors in
a non declarative implementation.</p>
          <p>Complexity of user interaction No additional help needs to be given to
the PD prover.</p>
          <p>Degree of coverage PD could not show that this Quicksort formulation
yields the same properties as the built-in isndec property, since it
requires induction.</p>
        </sec>
        <sec id="sec-5-1-10">
          <title>Support in finding errors No support necessary.</title>
          <p>4.6</p>
        </sec>
      </sec>
      <sec id="sec-5-2">
        <title>PVS Specification and Verification System</title>
        <p>PVS was already presented in section 3.5. Its characteristics are:
Commercial or academic nature PVS is of academic nature, with some
commercial additions. The tool can be freely downloaded and used by
any end user.</p>
        <p>Supported platforms and portability Supported platforms are only
Solaris and Intel Linux platforms. PVS uses heavily Emacs and LISP.
Theoretically it is possible to port the application, but so far this has
not been done.</p>
        <p>Installation The installation is straightforward. It suffices to copy the
whole build into a directory and call a small script to relocate
relevant links. On a standard Linux system PVS finds immediately Emacs
and necessary libraries without problems.</p>
        <p>General support The PVS team runs various mailing lists. Competent
and fast answers per e-mail make up a good support.</p>
        <p>Code generation PVS is not intended to produce executable code. PVS is
a specification language integrated with support tools and a theorem
prover. So the code has to be written in the specification language,
which then can be verified. A translation of such algorithms into real
code is still necessary.</p>
        <p>Learning curve PVS is hard to learn. PVS offers many possibilities during
the proving phase. How and when to use them requires not only
intensive training with PVS but also a profound knowledge of logic. PVS is
highly interactive, advanced knowledge is definitively necessary.</p>
        <sec id="sec-5-2-1">
          <title>4.6.1 Cubic sum</title>
          <p>Compute the sum of cubed numbers.</p>
        </sec>
        <sec id="sec-5-2-2">
          <title>Program code</title>
          <p>cubicSum: THEORY</p>
          <p>BEGIN
n: VAR nat
cubicSum(n): RECURSIVE nat =</p>
          <p>IF n = 0 THEN 0 ELSE n^3 + cubicSum(n - 1) ENDIF
MEASURE n
cubicSum_test: LEMMA cubicSum(3) = 36
cubicSum_formula: LEMMA cubicSum(n) = n^2 * (n + 1)^2 / 4
END cubicSum</p>
        </sec>
        <sec id="sec-5-2-3">
          <title>Proof procedure</title>
          <p>cubicSum_test: (grind)
cubicSum_formula: (induct-and-simplify "n")</p>
        </sec>
        <sec id="sec-5-2-4">
          <title>Analysis</title>
          <p>Ease of problem formulation The recursive specification is natural and
constitutes a nice mathematical way to describe this problem.
Complexity of user interaction The (grind) meta rule is powerful and
discharges most obligations. After careful study of the documentation
it is also clear that an induction on the recursively decreasing variable
is the way to success.</p>
          <p>Degree of coverage With the above commands the whole program could
be verified.</p>
          <p>Support in finding errors PVS hardly gives hints on structural problems.</p>
          <p>Often the proving process becomes so interactive and intricate that it
is hard to follow PVS problems. The user has already to have a plan
to use induction, otherwise he will fail.</p>
        </sec>
        <sec id="sec-5-2-5">
          <title>4.6.2 Factorial</title>
          <p>The factorial for a given number shall be computed.</p>
        </sec>
        <sec id="sec-5-2-6">
          <title>Program code</title>
          <p>fac: THEORY</p>
          <p>BEGIN
n, x, y, z: VAR nat
fac(n): RECURSIVE nat =</p>
          <p>(IF n = 0 THEN 1 ELSE n*fac(n-1) ENDIF)
MEASURE (LAMBDA n: n)
mul_mon: LEMMA FORALL x, y, z:</p>
          <p>(x &gt; 0 AND y &gt; z) IMPLIES x * y &gt; x * z
fac_non_neg: LEMMA FORALL x: fac(x) &gt; 0
fac_inc: LEMMA FORALL x: fac(x + 1) &lt; fac(x + 2)
fac_test: LEMMA fac(0) = 1
fac_test2: LEMMA fac(5) = 120</p>
          <p>END fac
Proof procedure
Ease of problem formulation The function and the lemmas can be
expressed in an intuitive functional style.</p>
          <p>Complexity of user interaction The amount of user interaction is quite
high, especially for fac_inc. The rewriting and instantiating of already
proved lemmas is non trivial and needs insight into the structure of the
proof.</p>
          <p>Degree of coverage With the above mentioned tricks everything could be
verified.</p>
          <p>Support in finding errors Due to the complex proving procedure, PVS
could not give any hints.</p>
        </sec>
        <sec id="sec-5-2-7">
          <title>4.6.3 Inversions</title>
          <p>Prove some properties on inversion pairs of numbers.</p>
        </sec>
        <sec id="sec-5-2-8">
          <title>Program code</title>
          <p>inv: THEORY</p>
          <p>BEGIN</p>
          <p>A: VAR ARRAY[nat -&gt; nat]
lenA: VAR nat
%% A set is defined as a predicate in PVS
inv(A, lenA): set[[nat, nat]] =
{ (i: below(lenA), j: below(lenA)) |</p>
          <p>i &lt; j AND A(i) &gt; A(j) }
%% An array is a (total) function in PVS
inv_test: LEMMA inv((LAMBDA (x: nat):
IF x = 0 THEN 3 ELSE 1 ENDIF), 2) =</p>
          <p>add((0,1), emptyset[[nat, nat]])
inv_null: LEMMA inv((LAMBDA (x: nat): 0), 0) =
emptyset[[nat, nat]]</p>
          <p>END inv</p>
        </sec>
        <sec id="sec-5-2-9">
          <title>Proof procedure</title>
          <p>inv_test: (apply-extensionality)
(grind)
inv_null: (apply-extensionality)
(grind)</p>
        </sec>
        <sec id="sec-5-2-10">
          <title>Analysis</title>
          <p>Ease of problem formulation PVS makes it quite difficult to handle this
problem. The first aspect is that arrays are just functions. This leads
to difficulties with return types and getting the length or the number
of elements of an array.</p>
          <p>Complexity of user interaction Sets cause problems with the meta
strategy (grind). At first one has to use the mechanism of extensionality. It
takes time to extract this from the documentation or the PVS mailing
list.</p>
          <p>Degree of coverage The properties could be proved, but with a significant
amount of interactivity.</p>
          <p>Support in finding errors PVS failed to give any support for this
problem. In the beginning in inv_test the order of numbers in the arrays
was unwillingly permuted. PVS gave no hints why it could not prove
anything. It took hours to find the error manually.
4.6.4</p>
        </sec>
        <sec id="sec-5-2-11">
          <title>Multiplication</title>
          <p>Multiply two integer numbers.</p>
        </sec>
        <sec id="sec-5-2-12">
          <title>Program code</title>
          <p>mult: THEORY</p>
          <p>BEGIN
c, x, y, z: VAR nat
mult(x, y, z): RECURSIVE nat =</p>
          <p>IF y = 0 THEN z ELSE mult(x, y - 1, z + x) ENDIF
MEASURE y
mult_test: LEMMA mult(3, 5, 0) = 15
mult_ok: LEMMA FORALL (x, y, z): mult(x, y, z) = x * y + z
mult_add: LEMMA mult(x, y, z + c) = mult(x, y, c) + z
mult_ok2: LEMMA FORALL (x, y): mult(x, y, 0) = x * y
END mult</p>
        </sec>
        <sec id="sec-5-2-13">
          <title>Proof procedure</title>
          <p>mult_test: (grind)
mult_ok: (induct-and-simplify "y")
mult_add: (induct-and-simplify "y")
mult_ok2: (skosimp*)</p>
          <p>(rewrite "mult_ok" :subst ("z" 0))
Ease of problem formulation The program itself can be easily
formulated in a recursive style. The lemmas for the conditions are also easily
stated with the help of quantifiers.</p>
          <p>Complexity of user interaction At the first try it is hard to find out
that the proof of mult_ok2 requires the proof of a more general
theorem, mult_ok. Only the latter can be proved directly by induction.
mult_ok2 is then obtained by instantiation and rewriting.</p>
          <p>Degree of coverage With the rewriting complete coverage was possible.</p>
          <p>The high interactivity of the user shall be mentioned here explicitly.
Support in finding errors PVS gives only passive support in finding
errors. By inspecting unprovable sequents one has to deduce which
premises are missing or whether errors in the specification occurred.
4.6.5</p>
        </sec>
        <sec id="sec-5-2-14">
          <title>Quicksort</title>
          <p>Sort a sequence of numbers according to the well known Quicksort algorithm
developed by Tony Hoare. This example is due to Griffioen and Huisman
[1998].</p>
        </sec>
        <sec id="sec-5-2-15">
          <title>Program code</title>
          <p>sort[T:TYPE,&lt;=:[T,T-&gt;bool]]: THEORY
BEGIN</p>
          <p>ASSUMING
total: ASSUMPTION total_order?(&lt;=)
l,m: VAR list[T]
e: VAR T
i: VAR nat
b: VAR bool
x,y: VAR T
p: VAR pred[T]
IMPORTING list_adt[T]
% def and lems on sorting.
sorted_rec(l): RECURSIVE bool =
null?(l) OR null?(cdr(l)) OR (car(l) &lt;= car(cdr(l))</p>
          <p>AND sorted_rec(cdr(l)))
MEASURE length(l)
qsort(l:list[T]): RECURSIVE list[T] =</p>
          <p>IF null?(l) THEN null
ELSE</p>
          <p>LET piv = car(l)
IN append(qsort(filter(cdr(l),(LAMBDA e: e &lt;= piv))),
cons(piv,
qsort(filter(cdr(l),(LAMBDA e: NOT e &lt;= piv)))))
ENDIF</p>
          <p>MEASURE length(l)
qsort_sorted : LEMMA sorted_rec(qsort(l))
END sort
int_sort: THEORY</p>
          <p>BEGIN</p>
          <p>IMPORTING sort[int,&lt;=]
int_oke: LEMMA FORALL (l:list[int]): sorted_rec(qsort(l))
qsort_test: LEMMA qsort((: 3, 1, 2 :)) = (: 1, 2, 3 :)
LEMMA qsort((: 4, 3, 5, 2, 1, 6, 6, 9, 8, 7 :)) =</p>
          <p>(: 1, 2, 3, 4, 5, 6, 6, 7, 8, 9 :)</p>
          <p>END int_sort
Proof procedure Due to the length of the proof, the proof was omitted
here. It can be found in the source code package accompanying this thesis.
Ease of problem formulation This example shows how powerful the PVS
specification language is. Generic and modular theories with abstract
data types are used here. PVS allows to write expressive formulas with
short code.</p>
          <p>Complexity of user interaction The proof is very complex with high user
interactivity due to the massive use of PVS features. Also lists are
somehow tricky, as it is sometimes necessary to give PVS hints on the
used types (eg. ::nat).</p>
          <p>Degree of coverage All properties could be verified.</p>
          <p>Support in finding errors Similar to the previous example.</p>
        </sec>
      </sec>
    </sec>
    <sec id="sec-6">
      <title>Summary</title>
      <p>The last two sections compared in detail the four selected tools: section 3
presented the tools from a theoretical point of view, whereas section 4
discussed the implementation of several examples to illustrate the differences
and capabilities. This section summarises the results with respect to the two
target groups, namely software engineers and students of computer science
with a limited background in formal logic.</p>
      <p>Frege Program Prover FPP supports a small subset of Ada consisting of
typical imperative program structures like loop, case- and if-statements.
The only data types available are integer and boolean. The language
for specifying pre- and post-conditions is rather restricted. E.g.,
function definitions, recursive specifications and structured data types like
arrays are not supported.</p>
      <p>FPP is able to verify simple programs and to compute their weakest
pre-conditions. The prover, Analytica, acts as a black box signalling
either the validity of a formula or returning unprovable sub-formulas;
formal proofs are not supplied.</p>
      <p>Due to its simplicity and its web interface, FPP is easy to learn and use.
It seems to be a valuable tool for illustrating the ideas of formal program
verification in basic courses. It is not suitable, however, for advanced
courses on the subject or for real world applications, as it is neither able
to deal with standard examples from Gries [1989] and Dijkstra and
Scholten [1990] involving arrays, nor does it support object-oriented
features. Moreover, the terse output in pure ASCII makes it difficult
to trace errors.</p>
      <p>The KeY system The KeY system supports a subset of Java known as
JavaCard, which is increasingly used for mobile and embedded devices.
Verification is based on dynamic logic, a generalisation of the Hoare
calculus. The system is integrated into a professional CASE tool
(Borland’s Together Control Center); an integration into the free Eclipse
environment is under way. Objects and constraints can be specified
using UML and OCL.</p>
      <p>Java, UML, OCL, and CASE tools are familiar to software engineers
and students alike, which helps in getting started. Nevertheless, KeY
cannot be recommended for these target groups at present: the
interactive prover and its interaction with the user are in their infancy
(compare the example in section 4.4.2) and are inadequate for any
serious use. Moreover, OCL is not expressive enough to specify complex
program behaviour.</p>
      <p>Considering that KeY is still in alpha stage, it seems to be worthwhile
to reevaluate the system in a few years in order to see whether it lives
up to expectations.</p>
      <p>Perfect Developer PD consists of a full-fledged object-oriented
programming language, Perfect, of a powerful automated theorem prover and
of a code generator translating programs from Perfect to Java, Ada,
and C++. A rich collection of built-in data types, classes, functions
and theories allows the user to write concise specifications on a fairly
abstract level.</p>
      <p>PD is a technically mature product that is ready for use in a regular
development process. However, software engineers will need some time
to become sufficiently acquainted with the many features of Perfect.
Moreover, at least a basic knowledge of formal logic is required to be
able to interpret the prover output and to use it for detecting errors
in the specification or in the program. Perfect Developer is also well
suited for teaching advanced courses on formal program verification.
Usually there will not be enough time to cover all features of Perfect.
Therefore a tutorial is required that concentrates on just those elements
of the language that are necessary to implement and verify instructive
examples like those in Gries [1989].</p>
      <p>PD is the only tool of the four that comes close to the ideal of
automatic and easy program verification. But there are also still some
shortcomings. One is that the prover currently does not support
induction. Consequently certain recursive functions and loops cannot be
verified by the system. Another weakness, at least from an academic
point of view, is the lack of information concerning the inner
workings of the prover. Ideally the logical rules used in correctness proofs
should be open for inspection such that independent proof checkers can
establish additional trust in the system.</p>
      <p>Prototype Verification System PVS is a powerful interactive theorem
prover, which has been used for various real world applications. In
contrast to the other systems it does not generate verified program
code, but proves properties of algorithms. The prover is versatile and
offers many possibilities. It is automatic to a certain degree, but usually
requires frequent user interactions.</p>
      <p>Due to its many basic inference rules and tactics it takes a long learning
phase to become familiar with the system. Moreover, users of PVS
need a firm background in mathematics and formal logic to guide the
prover. In our opinion typical software engineers and average students
of computer science will have a hard time using PVS. Graduate or
Ph.D. students might have a chance, provided they are given enough
time. For courses with just a few hours per week in the lab PVS seems
to be too complex.</p>
      <p>Figure 2 compares the four selected tools FPP, KeY, PD and PVS
according to formal background in logic and the field of application.</p>
      <p>Tools for formal software verification have made considerable progress in
recent years. With the advent of tools that offer formal methods on a level
accessible to software engineers the costs for formal software verification will
decrease such that it will be used in more and more projects. Universities
have to react already today by training students in formal methods, using
one or the other system.</p>
      <p>Latest announcements have also affirmed that there is ongoing
development in the field of software verification tools and the grand challenge towards
the verifying compiler is more up-to-date than ever before. Nevertheless a
lot needs to be done to achieve a wide acceptance of formal verification:</p>
      <p>Most of the general public, and even many programmers, are
unaware of the possibility that computers might check the
correctness of their own programs [Hoare, 2003, p. 65].</p>
    </sec>
    <sec id="sec-7">
      <title>Resources</title>
      <p>Wolfgang Ahrendt, Thomas Baar, Bernhard Beckert, Richard Bubel,
Martin Giese, Reiner H¨ahnle, Wolfram Menzel, Wojciech Mostowski, Andreas
Roth, Steffen Schlager, and Peter Schmitt. The KeY tool. Software and
System Modeling, 2004. Online First issue, to appear in print.
Krzysztof Apt and Ernst-Ru¨diger Olderog. Programmverifikation.
Springer</p>
      <p>Verlag, 1994. ISBN 3-540-57479-4.</p>
      <p>Franz Baader and Tobias Nipkow. Term Rewriting and All That. Cambridge</p>
      <p>University Press, 1998.</p>
      <p>Andrej Bauer, Edmund Clarke, and Xudong Zhao. Analytica — An
Experiment in Combining Theorem Proving and Symbolic Computation. Journal
of Automated Reasoning, 21:295–325, 1998.</p>
      <p>Bernhard Beckert, Martin Giese, Elmar Habermalz, Reiner H¨ahnle, Andreas
Roth, Philipp Ru¨mmer, and Steffen Schlager. Taclets: A new paradigm for
constructing interactive theorem provers. Revista de la Real Academia de
Ciencias Exactas, F´ısicas y Naturales, Serie A: Matem´aticas (RACSAM),
98(1), 2004. Special Issue on Symbolic Computation in Logic and Artificial
Intelligence.</p>
      <p>Alan Bundy. The Paradox of the Case Study, 2004. URL http://www-unix.</p>
      <p>mcs.anl.gov/AAR/issuesept04/index.html#paradox.</p>
      <p>Edmund Clarke and Xudong Zhao. Analytica — A Theorem Prover for</p>
      <p>Mathematica. The Mathematica Journal, 3:56–71, 1993.</p>
      <p>David Crocker. The Perfect Developer Language Reference Manual,
September 2001.</p>
      <p>David Crocker. Developing Reliable Software using Object-Oriented Formal</p>
      <p>Specification and Refinement. Escher Technologies Ltd., 2003a.
David Crocker. Perfect Developer: A tool for Object-Oriented Formal
Specification and Refinement. Tools Exhibition Notes at Formal Methods Europe,
2003b.
David Crocker. Automated Reasoning in Perfect Developer. Escher
Technologies Ltd., 2004a.</p>
      <p>David Crocker. Safe Object-Oriented Software: The Verified
Design-ByContract Paradigm. In Redmill and Anderson, editors, Proceedings of the
Twelfth Safety-Critical Systems Symposium, pages 19–41, London, 2004b.</p>
      <p>Springer-Verlag. ISBN 1-85233-800-8.</p>
      <p>Edsger Dijkstra and Carel Scholten. Predicate Calculus and Program
Semantics. Springer-Verlag, 1990.</p>
      <p>Melvin Fitting. First-order logic and automated theorem proving.
Springer</p>
      <p>Verlag, 1990. ISBN 0-387-97233-1.</p>
      <p>Carsten Freining, Stefan Kauer, and Ju¨rgen Winkler. Ein Vergleich der
Programmbeweiser FPP, NPPV und SPARK. Ada-Deutschland-Tagung 2002,
pages 127–145, 2002. ISSN 1433-9986. URL http://psc.informatik.
uni-jena.de/Fpp/fpp-intr.htm#references.</p>
      <p>Jean Gallier. Logic for Computer Science: Foundations of Automatic
Theorem Proving. Wiley, 2003. URL http://www.cis.upenn.edu/∼jean/
gbooks/logic.html.</p>
      <p>John Gannon, James Purtilo, and Marvin Zelkowitz. Software Specification:
A Comparison of Formal Methods. International Specialized Book Service
Inc., September 1993.</p>
      <p>Gerhard Gentzen. Untersuchungen u¨ber das logische Schließen.
Mathematische Zeitschrift, 39, 1935.</p>
      <p>David Gries. The Science of Programming. Springer-Verlag, 1989.
David Griffioen and Marieke Huisman. A comparison of PVS and
Isabelle/HOL. In Jim Grundy and Malcolm Newey, editors, Theorem
Proving in Higher Order Logics: 11th International Conference, TPHOLs ’98,
volume 1479 of Lecture Notes in Computer Science, pages 123–142,
Canberra, Australia, September 1998. Springer-Verlag.</p>
      <p>Tony Hoare. An axiomatic basis for computer programming.
Communications of the ACM, 12(10):576–580, 1969. ISSN 0001-0782. doi:
http://doi.acm.org/10.1145/363235.363259.</p>
      <p>Tony Hoare. The verifying compiler: A grand challenge for computing
research. J. ACM, 50(1):63–69, 2003. ISSN 0004-5411. doi: http:
//doi.acm.org/10.1145/602382.602403.
Michael Huth and Mark Ryan. Logic in Computer Science: Modelling and
Reasoning about Systems. Cambridge University Press, 2nd edition, 2004.</p>
      <p>ISBN 0 521 54310X.</p>
      <p>Cliff Jones. The Early Search for Tractable Ways of Reasoning about
Programs. IEEE Annals of the History of Computing, 25:26–49, 2003. ISSN
1058-6180.</p>
      <p>Bertrand Meyer. The grand challenge of Trusted Components. In ICSE ’03:
Proceedings of the 25th International Conference on Software Engineering,
pages 660–667. IEEE Computer Society, 2003. ISBN 0-7695-1877-X.
OMG. Object Constraint Language Specification, 2003a. URL http://www.</p>
      <p>omg.org/docs/ptc/03-10-14.pdf.</p>
      <p>OMG. OMG Unified Modeling Language Specification, March 2003b. URL
http://www.uml.org/#UML2.0.</p>
      <p>Sam Owre, John Rushby, and Natarajan Shankar. PVS: A prototype
verification system. In Deepak Kapur, editor, 11th International Conference on
Automated Deduction (CADE), volume 607 of Lecture Notes in Artificial
Intelligence, pages 748–752, Saratoga, NY, June 1992. Springer-Verlag.</p>
      <p>URL http://www.csl.sri.com/papers/cade92-pvs/.</p>
      <p>Sam Owre, John Rushby, Natarajan Shankar, and David Stringer-Calvert.</p>
      <p>PVS: an experience report. In Dieter Hutter, Werner Stephan, Paolo
Traverso, and Markus Ullman, editors, Applied Formal
Methods—FMTrends 98, volume 1641 of Lecture Notes in Computer Science, pages
338–345, Boppard, Germany, October 1998. Springer-Verlag. URL http:
//www.csl.sri.com/papers/fmtrends98/.</p>
      <p>Sam Owre, John Rushby, Natarajan Shankar, and David Stringer-Calvert.</p>
      <p>PVS Language Reference, November 2001a.</p>
      <p>Sam Owre, John Rushby, Natarajan Shankar, and David Stringer-Calvert.</p>
      <p>PVS Prover Guide, November 2001b.</p>
      <p>Sam Owre, John Rushby, Natarajan Shankar, and David Stringer-Calvert.</p>
      <p>PVS System Guide, November 2001c.</p>
      <p>Sam Owre and Natarajan Shankar. The Formal Semantics of PVS, March
1999.</p>
      <p>Gernot Salzer. Theoretische Informatik 1. Institute of Computer Languages,
Vienna University of Technology, June 2002.</p>
    </sec>
  </body>
  <back>
    <ref-list>
      <ref id="ref1">
        <mixed-citation>
          <string-name>
            <surname>Dirk van Dalen</surname>
          </string-name>
          .
          <source>Logic and Structure</source>
          . Springer-Verlag,
          <source>4th extended edition</source>
          ,
          <source>2004. ISBN 3-540-20879-8.</source>
        </mixed-citation>
      </ref>
      <ref id="ref2">
        <mixed-citation>
          <article-title>Ju¨rgen Winkler. wp is Basically a State Set Transformer</article-title>
          . Institute of Computer Science,
          <string-name>
            <surname>Friedrich-</surname>
          </string-name>
          Schiller-University,
          <year>1995</year>
          .
        </mixed-citation>
      </ref>
      <ref id="ref3">
        <mixed-citation>
          <article-title>Ju¨rgen Winkler</article-title>
          .
          <source>The Frege Program Prover</source>
          .
          <volume>42</volume>
          . Internationales Wissenschaftliches Kolloquium, Technische Universit¨at Ilmenau, pages
          <fpage>116</fpage>
          -
          <lpage>121</lpage>
          ,
          <year>1997</year>
          . ISSN 0943-7207.
        </mixed-citation>
      </ref>
    </ref-list>
  </back>
</article>