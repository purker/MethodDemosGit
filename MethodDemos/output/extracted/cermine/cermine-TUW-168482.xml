<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
  <front>
    <journal-meta />
    <article-meta>
      <title-group>
        <article-title>Dialogue Games for Fuzzy Logics</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <string-name>zur Erlangung des akademischen Grades</string-name>
          <xref ref-type="aff" rid="aff0">0</xref>
        </contrib>
        <aff id="aff0">
          <label>0</label>
          <institution>Christoph Roschger</institution>
          ,
          <addr-line>Bakk.techn</addr-line>
        </aff>
      </contrib-group>
      <pub-date>
        <year>2002</year>
      </pub-date>
      <volume>4</volume>
      <fpage>44</fpage>
      <lpage>85</lpage>
      <abstract>
        <p>an der Fakultät für Informatik der Technischen Universität Wien Betreuer: Ao.Prof.Dipl-Ing.Dr.techn. Christian G. Fermüller</p>
      </abstract>
    </article-meta>
  </front>
  <body>
    <fig>
      <graphic xlink:href="D:\output\methods\cermine\cermine-TUW-168482.images\img_1_1.png" />
    </fig>
    <fig>
      <graphic xlink:href="D:\output\methods\cermine\cermine-TUW-168482.images\img_1_2.png" />
    </fig>
    <fig>
      <graphic xlink:href="D:\output\methods\cermine\cermine-TUW-168482.images\img_27_1.png" />
    </fig>
    <fig>
      <graphic xlink:href="D:\output\methods\cermine\cermine-TUW-168482.images\img_28_1.png" />
    </fig>
    <fig>
      <graphic xlink:href="D:\output\methods\cermine\cermine-TUW-168482.images\img_29_1.png" />
    </fig>
    <fig>
      <graphic xlink:href="D:\output\methods\cermine\cermine-TUW-168482.images\img_30_1.png" />
    </fig>
    <fig>
      <graphic xlink:href="D:\output\methods\cermine\cermine-TUW-168482.images\img_30_2.png" />
    </fig>
    <fig>
      <graphic xlink:href="D:\output\methods\cermine\cermine-TUW-168482.images\img_31_1.png" />
    </fig>
    <sec id="sec-1">
      <title>-</title>
      <p>Diplom-Ingenieur
im Rahmen des Studiums
Computational Intelligence</p>
      <p>eingereicht von
_______________________
(Unterschrift Verfasser)
______________________
(Unterschrift Betreuer)</p>
      <p>Master Thesis
Dialogue Games for Fuzzy Logics</p>
    </sec>
    <sec id="sec-2">
      <title>Performed at the Department of</title>
      <sec id="sec-2-1">
        <title>Computer Languages</title>
        <p>Vienna University of Technology
advised by</p>
      </sec>
      <sec id="sec-2-2">
        <title>Ao.Prof.Dipl.-Ing.Dr.techn.</title>
      </sec>
      <sec id="sec-2-3">
        <title>Christian G. Fermu¨ller</title>
        <p>by</p>
      </sec>
      <sec id="sec-2-4">
        <title>Christoph Roschger, Bakk.techn.</title>
        <p>Erlgasse 40/15
1120 Wien</p>
        <sec id="sec-2-4-1">
          <title>Zusammenfassung</title>
          <p>Formale Dialogspiele werden schon seit langem dazu verwendet, die Semantik verschiedener
Logiken zu charakterisieren. In den 70er Jahren pr¨asentierte Robin Giles seinen Versuch, eine
operationale Grundlage fu¨r formales Schließen zu definieren, basierend auf atomaren
Experimenten, welche Dispersion aufweisen k¨onnen. Diese Masterarbeit motiviert und beschreibt
seinen Ansatz und die Verbindung zu t-Norm-basierten Fuzzy-Logiken.</p>
          <p>Wir geben eine kurze Einfu¨hrung in t-Normen und mehrwertige Fuzzy-Logiken, die auf
diese Bezug nehmen. Im Speziellen liegt der Schwerpunkt auf drei solchen
fundamentalen Fuzzy-Logiken: Lukasiewicz-Logik, G¨odel-Logik und Produkt-Logik. Verschiedene
M¨oglichkeiten, die Spielregeln von Giles’ Spiel zu ¨andern, um dieses ad¨aquat fu¨r G¨odel- und
Produkt-Logik zu machen, werden pr¨asentiert und diskutiert. Daru¨ber hinaus beschreiben
wir die starke Verbindung zwischen Gewinnstrategien im Spiel und Ableitungen in einem
analytischen Kalku¨l, der auf relationalen Hypersequenten basiert.</p>
          <p>Eine andere Art von Dialogspielen sind sogenannte “Truth Comparison Games”. Diese
sind besonders geeignet fu¨r Go¨del-Logik, da sie der gradbasierten Semantik der G¨odel-Logik
mehr entsprechen als Giles’ Spiel. Wir pr¨asentieren das Spiel und diskutieren
Gewinnstrategien fu¨r beide Spieler, welche als Beweis fu¨r die Gu¨ltigkeit oder Widerlegbarkeit einer Formel
gesehen werden ko¨nnen.</p>
          <p>Zus¨atzlich werden mehrere Hilfsprogramme vorgestellt, die im Kontext dieser
Masterarbeit entwickelt wurden. Darunter befindet sich auch eine webbasierte Anwendung zur
interaktiven Exploration von Giles’ Spiel und dessen Erweiterungen.
Formal dialogue games are a traditional approach to characterize the semantics of logics. In
the 1970s Robin Giles attempted to provide an operational foundation for formal reasoning in
physical theories by dialogue games based on atomic experiments that may show dispersion.
This thesis motivates, describes and analyzes his approach and the connection to t-norm
based fuzzy logics.</p>
          <p>We give a short introduction into t-norms and many-valued logics based on t-norms. In
particular we focus on three fundamental t-norm based fuzzy logics: Lukasiewicz Logic,
G¨odel Logic, and Product Logic. We present and discuss several approaches for extending
the game rules of Giles’s Game in order to make it adequate for G¨odel Logic and Product
Logic. Moreover, we give hints at a strong correspondence between winning strategies in the
game and derivations in an analytic proof system based on relational hypersequents.</p>
          <p>Another type of dialogue games are truth comparison games. This type is suitable for
G¨odel Logic and relates more to the degree based semantics of that logic than Giles’s Game.
We present the game and discuss winning strategies for both players indicating the validity
or refutability of a formula.</p>
          <p>Additionally, several utilities implemented in the context of this thesis are presented.
Amongst these is a web-based application which allows for the interactive exploration of
Giles’s Game and its extensions.
1 Introduction
1
Notation used
List of Figures
List of Tables
Index
77
79
82
83
84
“Everything is vague to a degree you do not realize
till you have tried to make it precise.”
Bertrand Russell
CHAPTER 1</p>
        </sec>
        <sec id="sec-2-4-2">
          <title>Introduction</title>
          <p>Vagueness is a ubiquitous and pervasive phenomenon in information processing. Modelling
vagueness is often accomplished by assigning degrees of truth to propositions. Fuzzy logics,
taken here in Zadeh’s “narrow sense” [Zad96], are based on the extension of the two classical
truth values by infinitely many intermediary degrees of truth. Degrees of truth should
strictly be distinguished from degrees of belief, and therefore require methods different from
probability theory. In particular, in fuzzy logics the semantics of the logical connectives is
required to be truth functional.</p>
          <p>In the 1970s Robin Giles attempted to provide an operational foundation for formal
reasoning in physical theories based on atomic experiments that may show dispersion. A formula
is interpreted by a strategic game, where two players bet on the combined results of atomic
experiments, that may show different outcomes when repeated. The degree of truth is then
related to the expected loss of the player initially asserting the formula. Giles proved that
the propositions that a player can bet on without expecting loss coincide with those that are
valid in Lukasiewicz Logic, one of three fundamental, so-called t-norm based fuzzy logics.</p>
          <p>Giles’s remarkable result can, with hindsight, be seen as one of the few attempts to solve
a fundamental problem in approximate reasoning: how to derive a fuzzy logic from first
principles, in this case from dialogue rules combined with a betting scheme.
1. Introduction</p>
          <p>In Chapter 2 we motivate fuzzy logics based on so-called t-norms. We present the three
fundamental t-norm based fuzzy logics Lukasiewicz Logic L, Product Logic Π, and G¨odel
Logic G. An analytic proof system for these three logics based on relational hypersequents
is described which is of special interest in the context of Giles’s Game.</p>
          <p>Chapter 3 presents Giles’s Game itself. Giles’s approach of reasoning in physical theories
by assigning a “tangible meaning” to propositions is motivated and discussed. The dialogue
game rules for subsequently decomposing compound propositions as well as an adequate
betting scheme for atomic propositions are given. This chapter also includes a version of
Giles’s proof which relates the game to Lukasiewicz Logic. Moreover, we provide hints at an
extension of Giles’s Game adequate for first order Lukasiewicz Logic.</p>
          <p>Chapter 4 shows that variants of Giles’s Game are adequate for Product Logic and Go¨del
Logic. This is accomplished in the first place by changing the underlying betting scheme.
We also have to modify the game rules for decomposing implications. Several ways of doing
so are presented.</p>
          <p>Chapter 5 presents so-called truth comparison games. This type of game is a dialogue game
adequate for Go¨del Logic G which, in contrast to L and Π, only requires the comparison
of different degrees of truth and no arithmetical operations on these. We also show how
to model strategies for both players in this framework. These strategies can be used for
characterizing validity and refutability of formulas in G¨odel Logic.</p>
          <p>In the context of this thesis four small tools have been implemented. The applications
and their usage are subject of Chapter 6:
Webgame: A web-based application which enables the interactive exploration of Giles’s
Game and its variants for Product Logic and G¨odel Logic. After playing the game
and having reached a final game state, one can simulate the evaluation of atomic
propositions based on (dispersive) experiments using the respective betting scheme.
Giles: A utility which creates and visualizes game trees of Giles’s Game. Most illustrations
of game trees in this thesis are generated using giles.</p>
          <p>Hypseq: A tool which constructs and displays derivations of hypersequents in the
hypersequent calculus rH presented in Section 2.6.</p>
          <p>TCGame: A tool which searches for winning strategies for the proponent in the truth
comparison game presented in Chapter 5. Such a strategy can be displayed as a tree and
can be seen as a proof of the initial proposition of the game.
“There is nothing worse than a sharp image of a fuzzy concept.”
Anselm Adams</p>
          <p>CHAPTER 2</p>
        </sec>
        <sec id="sec-2-4-3">
          <title>T-Norm Based Fuzzy Logics</title>
          <p>In this chapter we concretize the notion of a fuzzy logic by choosing so called t-norms as a
starting point for defining a logic. We then describe three important t-norms and
corresponding logics in more detail, which are of special relevance when dealing with dialogue games
later on. This chapter also includes a brief description of a proof system using relational
hypersequents and uniform rules for those three logics.
2.1 Design Choices
Fuzzy logics are commonly understood as many valued logics that allow to model reasoning
in presence of different degrees of truth. In order to achieve this, we follow Petr H´ajek
([H´a02] and [H´aj02]) in making the following fundamental “design choices”:
1. The real unit interval [0, 1] is taken as our set of truth values, 0 meaning absolute falsity,
1 standing for absolute truth. The truth values are linearly ordered using the usual
ordering 6. An important implication of this choice is that we always can compare
the truth values of two propositions. For example, we can say, the proposition “I am
tall” is true to a higher degree than the proposition “the weather is good today”.
2.1. Design Choices
2. The truth value of a formula (A, B) shall solely be determined by the truth values
of the formulas A and B. This notion is called truth functionality and is formalized
as follows: Each binary connective shall have a truth function f : [0, 1]2 → [0, 1]
determining for any pair of formulas the truth degree of the compound formula and
similarly for unary connectives.</p>
          <p>This requirement, for example, hinders us to simply regard truth values as probabilities
of arbitrary events; the resulting logic would not be truth functional: The probability
value of the proposition “A and B” then is not composable into the truth values of A
and B alone, but depends on how these events are related to each other. In general
one cannot assume that arbitrary experiments are independent of each other. The
same applies to propositions of the form “A or B” as the probability P(A or B) can be
calculated as P(A or B) = P(A)+P(B)−P(A and B). Nevertheless, there are approaches
to probabilistic reasoning in a logical framework; see e.g. [HGE95].
3. When choosing truth functions for connectives each fuzzy logic shall be a generalization
of classical logic. So, for the truth values 0 and 1 the truth functions must behave
classically. For example, if we call a connective “→” implication, its truth function
f→ : [0, 1]2 → [0, 1] must satisfy the equalities f→(0, 1) = 1, f→(0, 0) = 1, f→(1, 0) = 0
and f→(1, 1) = 1. Hence, all tautologies (formulas that always evaluate to the truth
value 1 regardless of the truth values of their atoms) in our fuzzy logic are also classical
tautologies, while the other way round this does not need to be true.
4. We start with formulating requirements for the conjunction. These requirements are
described using the notion of a t-norm (see the next section). Based on the truth
function for conjunction a “reasonable” definition for implication can be formulated;
we then will see that having defined truth functions for conjunction and implication
the truth functions for the other connectives are determined as well.
5. The truth function f¬ for the negation is defined by f¬(a) := f→(f(a), 0) where f(a) is
the truth value of a and f→ is the truth function for the implication.</p>
          <p>In other words: The truth value for the negation of a proposition states to which degree
we can conclude an absolutely false statement from this proposition.</p>
          <p>This view of fuzzy logics also corresponds to what Lotfi A. Zadeh, the inventor of fuzzy
sets, describes as fuzzy logics in a narrow sense, [Zad96],[RJM94].</p>
          <p>Moreover, we will restrict ourselves to propositional fuzzy logics; a short treatment of
predicate fuzzy logics and their relation to dialogue games will be in Section 3.7.
2.2 T-Norms
As mentioned above we start defining a fuzzy logic by looking for suitable truth functions
for conjunction. Possible candidate functions must adhere to the following rather intuitive
requirements:</p>
          <p>Asserting the statement “A and B” shall be equivalent to asserting the statement
“B and A”. Although, in natural language this is not necessarily the case (because the
emphasis is rather placed on A respectively B) we require this in analogy to classical logic.</p>
          <p>Let “A and B” be a proposition with truth value v. Then, if we replace A by another
statement which has a higher truth value than A, the truth value of the new conjunction
shall not be smaller than v and similarly for B.</p>
          <p>Moreover, a small change in the truth value of A should only result in a small change in
the truth value of the statement “A and B”, and the same for B. Thus, we require continuity
of our truth function1.</p>
          <p>Finally, in order to ensure that classical logic remains a special case we will further require
that 1 is the unit element and 0 the zero element.</p>
          <p>Thus we arrive at the notion of a t-norm:
Definition 1. A function ∗ : [0, 1]2 → [0, 1] is called a t-norm if it is
commutative and associative:
1 ∗ x = x and 0 ∗ x = 0.
non-decreasing in both arguments:</p>
          <p>x ∗ y = y ∗ x
(x ∗ y) ∗ z = x ∗ (y ∗ z),
x 6 x0 implies x ∗ y 6 x0 ∗ y,
y 6 y0 implies x ∗ y 6 x ∗ y0,
1Following this argument, it would suffice to require the t-norm to be continuous in each of its variables,
which is in general weaker than calling for continuity of the function itself. However, it can be proved
that because of the non-decreasingness of t-norms, these two properties are equivalent. (See [KMP00],
Chapter 1, Proposition 1.19 )</p>
        </sec>
      </sec>
    </sec>
    <sec id="sec-3">
      <title>A t-norm is continuous if the functions</title>
      <p>∗x(y) : [0, 1] → [0, 1], ∗x (y) := x ∗ y and
∗y(x) : [0, 1] → [0, 1], ∗y (x) := x ∗ y
are continuous.</p>
      <p>There exist infinitely many different t-norms, but we will only deal with three of them:
1. Lukasiewicz t-norm ∗L: x ∗L y = max(0, x + y − 1),
2. G¨odel t-norm ∗G: x ∗G y = min(x, y),
3. Product t-norm ∗Π: x ∗Π y = x · y</p>
      <p>These are considered to be the most important ones. All other continuous t-norms can
be obtained from them using a so-called ordinal sum construction. (See [H´a02] for a precise
description and proof.)</p>
      <p>For defining a truth function for implication for a given t-norm, we will make use of the
residuum of a given t-norm:
Definition 2. Let ∗ be a continuous t-norm. Then the operation x ⇒∗ y2 is defined as
x ⇒∗ y := sup{z | x ∗ z 6 y}. It is called the residuum of ∗.</p>
      <p>Lemma 1. Let ∗ be a continuous t-norm and ⇒∗ its residuum. Then x ∗ (x ⇒∗ y) 6 y holds.
Proof.</p>
      <p>x ∗ (x ⇒∗ y) = x ∗ sup{z | x ∗ z 6 y} = sup{x ∗ z | x ∗ z 6 y} 6 y
Here we make use of the fact that the t-norm ∗ is non-decreasing and continuous in its second
argument.</p>
      <p>Instead of x ∗ (x ⇒∗ y) 6 y we could also write (x ⇒∗ y) ∈ {z | x ∗ z 6 y} or sup{z | x ∗ z 6
y} ∈ {z | x ∗ z 6 y}. As we see, we could have defined x ⇒∗ y as max{z | x ∗ z 6 y} as well.</p>
      <p>The residuum, as it is defined here, is uniquely determined by the property
∀x, y, z ∈ [0, 1] : z ∗ x 6 y if and only if z 6 x ⇒∗ y
In fact, ∗ does not even have to be continuous. The condition already holds for all
leftcontinuous t-norms. The logic based on all left-continuous t-norms is called monoidal t-norm
logic or short MTL (see [EG01]).</p>
      <p>2Instead of e.g. ⇒∗L we will just write ⇒L.</p>
      <p>There are several reasons suggesting to use the residuum as the truth function for
implication:</p>
      <p>The residuum x ⇒∗ y is non-increasing in x and non-decreasing in y. This means that
the implication gets less true as we make the antecedent x more true. Vice versa, the
implication gets more true as we make the succedent more true.</p>
      <p>Knowing the truth values x and x ⇒∗ y one can compute the truth value y (a lower
bound of y, respectively) using the term x ∗ (x ⇒∗ y). Moreover, if x &gt; y we can
show that x ∗ (x ⇒∗ y) = y. This follows from the last step of the proof of the lemma
together with the consideration that fx(y) := x ∗ y is continuous (x ∗ 1 = fx(1) = x and
x ∗ 0 = fx(0) = 0, thus there must exist a z such that fx(z) = x ∗ z = y):</p>
      <p>x ∗ (x ⇒∗ y) = sup{x ∗ z | x ∗ z 6 y} = y
This can be regarded as a fuzzy version of the modus ponens inference rule.
In analogy to classical logic, where we can conclude everything from a false antecedent
(quodlibet ex falso), x ⇒∗ y evaluates to 1 if x is smaller than y.</p>
      <p>So, the expression x ∗ (x ⇒∗ y) evaluates to y if y 6 x and to x if x 6 y; thus, it gives us
the minimum of x and y. Similarly, it is possible to express the maximum in terms of ∗ and
⇒∗ using the following lemma:
Lemma 2. For each continuous t-norm ∗ and its residuum ⇒∗ the following two equalities
hold:
(i) min(x, y) = x ∗ (x ⇒∗ y)
(ii) max(x, y) = min((x ⇒∗ y) ⇒∗ y, (y ⇒∗ x) ⇒∗ x)</p>
    </sec>
    <sec id="sec-4">
      <title>Proof. (i) we have just seen.</title>
      <p>(ii): Let x 6 y. Then x ⇒∗ y = 1 and (x ⇒∗ y) ⇒∗ y = 1 ⇒∗ y = y. On the other hand,
we know y ∗ (y ⇒∗ x) 6 x and using the definition of the residuum we can conclude that
y 6 (y ⇒∗ x) ⇒∗ x. Thus, min(((x ⇒∗ y) ⇒∗ y), ((y ⇒∗ x) ⇒∗ x)) = y; the case y 6 x is
symmetric.</p>
      <p>For the three t-norms mentioned above it is possible to compute their residua directly:3
Note that, although we only use continuous t-norms, their residua do not need to be
contin3The residuum of product conjunction is also often called Goguen implication in literature.
uous. In fact, it is possible to show that the residuum ⇒L of Lukasiewicz Logic is the only
continuous one.</p>
      <p>t-norm residuum
Lukasiewicz x ∗ y = max(0, x + y − 1) x ⇒L y = min(1, 1 − x + y)
G¨odel x ∗ y = min(x, y) x ⇒G y = 1y ioftxhe6rwyise
Product x ∗ y = x · y x ⇒Π y = 1y/ixf xot6heyrwise</p>
      <p>Given a continuous t-norm and its residuum we are now ready to define a propositional
logic. To denote atomic propositions we use lower letters a, b, . . ., for arbitrary propositions
we use the upper letters A, B, . . ..</p>
      <p>Definition 3. Let ∗ be a continuous t-norm and ⇒∗ its residuum. We define a logic L∗ based
on a language with binary connectives →, &amp; and constant ⊥. A valuation or interpretation
for L∗ is a function v assigning to each propositional variable a truth value from the real unit
interval [0, 1], uniquely extended to v∗ for formulas by:</p>
      <p>v∗(A&amp;B) = v∗(A) ∗ v∗(B) v∗(A → B) = v(A) ⇒∗ v(B) v∗(⊥) = 0
Furthermore, based on these three ones we define the following connectives:
¬A := A → ⊥
A ∧ B := A&amp;(A → B)</p>
      <p>A ∨ B := ((A → B) → B) ∧ ((B → A) → A)
Definition 4. Let ∗ be a continuous t-norm. Then two formulas A and B are equivalent in
L∗, denoted A ≡ B, if and only if for all valuations v, the equality v∗(A) = v∗(B) holds.</p>
      <p>To distinguish between &amp; and ∧, which represent different forms of conjunction, we call
&amp; strong conjunction and ∧ min-conjunction. Note that, by Lemma 2 min-conjunction and
disjunction just select the minimum, respectively the maximum, of the truth values of its
two arguments.</p>
      <p>We call the logics L∗L, L∗G and L∗Π, Lukasiewicz Logic L, G¨odel Logic G and Product
Logic Π, respectively.</p>
      <p>Finally, the notion of a valid formula is defined as expected:
2.3. Lukasiewicz Logic
Definition 5. Let L∗ be the logic based on the t-norm ∗. A formula A is valid in L∗, written
|=L∗ A, iff v∗(A) = 1 for all valuations v for L∗.
2.3 Lukasiewicz Logic
Lukasiewicz Logic L is the fuzzy logic based on the Lukasiewicz t-norm x ∗L y = max(0, x +
y − 1). In the 1920s Jan Lukasiewicz introduced a family of many-valued logics [Luk20]. L
is the infinite-valued member of this family.
Theorem 1. Lukasiewicz Logic L is the only logic based on a continuous t-norm where ⇒∗
is continuous.</p>
      <p>For a proof of Theorem 1 we refer to [FK06].</p>
      <p>Another property of L is that all connectives are definable by the implication → and the
constant ⊥. Since the connectives ∨, ∧, and ¬ are derived from →, &amp; and ⊥ in Definition
3, the only relevant connective here is &amp;:
Lemma 3. Strong conjunction &amp; can be defined as
Proof. According to Definition 3 the valuation of the formulas ¬(A → ¬B) is calculated as
1 − vL(A) ⇒L (1 − vL(B)) . We see that vL(¬(A → ¬B)) equals 0 if vL(A) + vL(B) 6 1 holds
and equals vL(A) + vL(B) − 1 otherwise which is equivalent to ∗L.</p>
      <p>A&amp;B := ¬(A → ¬B).
2.4. G¨odel Logic
Moreover, the maximum of two truth values can be expressed as follows:</p>
      <p>max(x, y) = ((x ⇒L y) ⇒L y)
yielding a simpler definition for ∨, namely A ∨ B := ((A → B) → B).</p>
      <p>Lukasiewicz also gave an axiomatic characterization of L:
(L1) A → (B → A)
(L2) (A → B) → ((B → C) → (A → C))
(L3) (¬A → ¬B) → (B → A)
(L4) ((A → B) → B) → ((B → A) → A)
A formula A is derivable from this four axioms by modus ponens if and only if |=L A holds,
i.e. if and only if vL(A) = 1 for all valuations v for L. A proof of this is presented in [HGE95].
Note that negation is involutive in L, i.e. ¬ 6= A ≡ A holds for all formulas A.
2.4 G¨odel Logic
G¨odel Logic G is based on the t-norm x ∗G y = min(x, y). Thus, the same truth value is
assigned to both formulas A and A&amp;A. Moreover, the connectives ∧ and &amp; coincide. Kurt
G¨odel defined a family of finite-valued logics in [G¨od32]. G was introduced 1959 by Dummet
[Dum59] as the infinite-valued version of these logics.</p>
      <p>Note that G does not enjoy double negation. Instead, it is easy to see that

vG(¬A) = 1 if vG(A) = 0</p>
      <p>0 otherwise</p>
      <p>As for Lukasiewicz Logic, there exist also axiomatizations for G¨odel Logic. One of
particular interest is obtained when taking an axiomatization of Intuitionistic Logic and adding
the following axiom:</p>
      <p>((A → B) → C) → (((B → A) → C) → C)
(For a proof that this axiomatization is indeed adequate for G we refer to [H´a02].) Therefore,
G is often called an intermediary logic between Intuitionistic Logic and Classical Logic or,
sometimes as well, “Intuitionistic Fuzzy Logic”.
2.5. Product Logic
2.5 Product Logic
Product Logic Π is based on the product t-norm x ∗Π y = x · y. It was introduced in 1996
[HGE96]. The residuum, x ⇒Π y = 1 for x 6 y and x ⇒Π y = y/x otherwise, however was
already defined by Goguen in 1969 [Gog69].</p>
      <p>The truth function for negation is exactly the same one as for G¨odel Logic.
is 1, but the limit limt→0(t ⇒Π 0) is 0.
example.</p>
      <p>Note that the ⇒Π is not continuous at the point x = 0, y = 0: There the residuum 0 ⇒Π 0
As well as for L and G it is possible to give axiomatizations for Π, see [H´a02] as an
2.6 A Uniform Hypersequent System
In this section we present a uniform and analytic proof system for L, G, and Π following A.
Ciabattoni, C.G. Fermu¨ller and G. Metcalfe in [CFM04]; we will refer to it as rH. This proof
system is based on so-called relational hypersequents or, short, r-hypersequents and features
uniform logical rules for L, G, and Π which are invertible. In spite of the existence of several
other calculi for fuzzy logics, this one is of special interest concerning dialogue games. We
will see later in Chapter 3 that there is a close correspondence between the game rules of
Giles’s Game and the logical rules of rH.</p>
      <p>Ordinary sequent systems feature rules with the premises as well as the conclusion being
a sequent, that is, two (possibly empty) multisets of formulas divided by Gentzen’s sequent
arrow `, [Gen69].</p>
      <p>Hypersequent systems can be seen as an extension to sequent systems where the premises
and conclusions do not consist of sequents but of finite sets of sequents. There are calculi
for many fuzzy logics presented in a framework of hypersequent systems, see, as an example
[MOG05], [Avr91], and [MOG04] for hypersequent calculi for L, G, and Π.</p>
      <p>On the other hand, relational sequents can be seen as a variant of ordinary Gentzen
sequents where Gentzen’s sequent arrow ` is replaced by other symbols. A relational sequent
then may contain one of these symbols instead of the sequent arrow `. In [BF99] such
sequents are used in a calculus for G which has, in contrast to the respective hypersequent
calculus, invertible rules. In the case of rH, we have two types of sequents where in one
Gentzen’s sequent arrow is replaced by &lt; and in the other by 6. When make a statement
about relational sequents where that symbol is not important, we will use the variable / to
denote either 6 or &lt; consistently for the whole statement.</p>
      <p>Relational hypersequents are the combination of these two concepts. For rH they are
formally defined as follows:
Definition 6. A relational hypersequent (r-hypersequent) is a finite multiset of the form:</p>
      <p>G = Γ1 /1 Δ1 | . . . | Γn /n Δn
where /i ∈ {&lt;, 6} and Γi and Δi are finite multisets of formulas for i = 1, . . . , n. The
r-hypersequent G is called atomic if all formulas in G are atomic.</p>
      <p>Next we define which r-hypersequents are regarded to be valid :
Definition 7. An r-hypersequent G = Γ1 /1 Δ1 | . . . | Γn /n Δn is valid for L ∈ {L, G, Π},
written |=L G, iff for all valuations v for L,</p>
      <p>#vLΓi /i #vLΔi for some i, 1 6 i 6 n,
where #vL∅ = 1 for L ∈ {L, G, Π} and
#vL(Γ ) = 1 + X {v(A) − 1}</p>
      <p>A∈Γ
#vG(Γ ) = 1 + min {v(A)}</p>
      <p>A∈Γ
#vΠ(Γ ) = 1 + Y {v(A)}</p>
      <p>A∈Γ</p>
      <p>Note that using this definition, for any formula A the hypersequent 6 A is valid iff A is
valid in the respective logic. Also note that the symbols &lt; and 6 are used both semantically
as relations and syntactically as symbols in sequents.</p>
      <p>Since an r-hypersequent is valid if one relational sequent occurring in it is valid (viewed
as an r-hypersequent with one element), an r-hypersequent can be regarded as a disjunction
of sequents at the meta-level.</p>
      <p>The logical rules of rH to decompose non-atomic r-hypersequents are defined as follows:
(G and H are used as metavariables to denote possibly empty r-hypersequents; Γ, A is short
for Γ ∪· {A} and Γ, Δ for Γ ∪· Δ where ∪· is the multiset union.</p>
      <p>Definition 8. We define the following uniform logical rules for / ∈ {&lt;, 6}:
(→, /, l) G | Γ / Δ | Γ, BG/| AΓ,,AΔ→ BG/ Δ|Γ / Δ | B &lt; A
(→, /, r) G | Γ / Δ</p>
      <p>G | Γ, A / B, Δ | A 6 B</p>
      <p>G | Γ / A → B, Δ
(&amp;, /, l) G | Γ, A,GB|/Γ,ΔA&amp;BG/ Δ|Γ, ⊥ / Δ
(&amp;, /, r) G | ΓG/ |⊥Γ, /ΔA| &amp;Γ/B,AΔ, B, Δ</p>
      <p>As an example the rule (&amp;, /, l) can be read as: “If both r-hypersequents G | Γ, A, B / Δ
and G | Γ, ⊥ / Δ are derivable, then the r-hypersequent G | Γ, A&amp;B / Δ is derivable as well.”
Theorem 2. Soundness and Completeness of rH:</p>
      <p>Soundness: If an r-hypersequent G is derivable in rH from atomic r-hypersequents
valid in L, G, or Π, then G is valid in L, G, or Π respectively.</p>
      <p>Completeness: If an r-hypersequent is valid in L, G, or Π then G is derivable in rH
from atomic r-hypersequents valid in L, G, or Π respectively.</p>
      <p>For a proof of Theorem 2 we refer to [CFM04]. Note that by Theorem 2 a formula A is
valid in L, G, or Π if and only if “6 A” is derivable in rH. From Theorem 2 it is easy to
prove the following:
Theorem 3. The rules of rH are invertible: E.g. if the r-hypersequent G | Γ, A&amp;B / Δ is
valid, then both r-hypersequents G | Γ, A, B / Δ and G | Γ, ⊥ / Δ are valid as well.</p>
      <p>Another property of rH which is easy to observe is its analyticity: Every formula occuring
in a premise also occurs in the conclusion. This implies that in a derivation of A only
subformulas of A occur.</p>
      <p>Uniform rules for ∧ and ∨ are derivable using Definition 3 but we can also give more
streamlined versions:
(∧, /, l) G |GΓ,| AΓ, /AΔ∧| BΓ,/BΔ/ Δ</p>
      <p>(∧, /, r) G | Γ /GA|,ΓΔ/ A ∧GB|,ΓΔ/ B, Δ
(∨, /, l) G | Γ, GA |/ΓΔ/ A ∨GB|,ΓΔ, B / Δ
(∨, /, r) G |GΓ |/ΓA,A,Δ∨| BΓ // ΔB, Δ</p>
      <p>Obviously, repeatedly applying the uniform logical rules upwards to an r-hypersequent
terminates with atomic r-hypersequents. Such a derivation can be seen as a tree with the
starting r-hypersequent as root and atomic r-hypersequents as leaves. In order to decide if
the r-hypersequent in the root of such a tree is valid, we have to decide this property for each
leaf. Because of the soundness property of rH, if all of them are valid, then we can conclude
that the r-hypersequent in the root is valid as well. As an example Figure 2.4 shows a proof
tree starting with the r-hypersequent 6 (a (a → b)) → b.</p>
      <p>(Atomic)
6</p>
      <p>(Atomic) (Atomic)
a 6 b | a, b 6 a, b a 6 b | b &lt; a
a, a → b 6 b
(→, 6, l)
(Atomic)</p>
      <p>⊥6 b (&amp;, 6, l)
6 (a&amp;(a → b)) → b</p>
      <p>a&amp;(a → b) 6 b (→, 6, r)</p>
      <p>In [CFM04] it is shown that checking an atomic r-hypersequent for validity is polynomial.
For Lukasiewicz Logic, for example, this can be done efficiently using linear programming.
Checking the validity of an arbitrary r-hypersequent is not polynomial, of course. Moreover,
A 6 B for the truth value of A being less than or equal to the one of B).</p>
      <p>If we want to state that a formula F is satisfiable, this is formalized as stating that there
exists an interpretation where &gt; 6 F holds. If we want to state that F is unsatisfiable, this
is formalized as stating that each interpretation F 6 &gt; holds. The main idea for this game
is now that any logical connective ◦ of G can be characterized via an adequate response by
player O to the other player P’s attack on O’s claim that a statement of the form (A ◦ B) / C
or C / (A ◦ B) holds, where / is either &lt; or 6 and ◦ is a (binary) connective.</p>
      <p>For describing the game we use the following definitions:</p>
      <p>An assertion F / G is called atomic if both F and G are atoms.</p>
      <p>An assertion that is not atomic is called a compound assertion
Atomic assertions of the form a &lt; a, a &lt; ⊥, &gt; &lt; a or &gt; 6 ⊥ are called elementary
contradictions. These are assertions which are false regardless of the interpretation.
A set of two assertions of the form {e /1 e, e /2 g}, where e,g and g are atoms and
/1, /2 ∈ {&lt;, 6} is called an elementary order claim.</p>
      <p>The game starts with the proponent P’s initial claim that a formula F is valid. In return
the other player, called the opponent O, contradicts P’s by asserting F &lt; &gt;. This can
informally be seen as O believing that there exists an interpretation v such that vG(F) yields
a truth value lesser than 1, in other words, that F is not valid.</p>
      <p>From that point on each round of the game consists of two steps:
1. P chooses and attacks either a compound assertion or an elementary order claim from
the set of assertions made by O so far in the game, but that have not yet been attacked
by P.
2. O answers to this attack by adding a set of assertions according to the rules of Table
5.1. Note that, in some cases O can choose between two answers, while in other cases,
there is no such choice for O.</p>
      <p>If O asserts an elementary contradiction at any point in the game, the game ends and P
is declared the winner of the game. Such a node containing an elementary contradiction is
called a winning node for P. Otherwise, O wins if there is no further possible attack for P.</p>
      <p>Since this game can be seen as a zero-sum game with perfect information, the saddle point
theorem states that there exists a winning strategy for either O or P. [FP03] proves that a
P attacks: O asserts as answer:
A ∧ B / C {A / C} or {B / C}
C / A ∧ B {C / A, C / B}
A ∨ B / C {A / C, B / C}
C / A ∨ B {C / A} or {C / B}
A → B &lt; C {B &lt; A, B &lt; C}
C &lt; A → B {C &lt; B} or {A 6 B, C &lt; &gt;}
A → B 6 C {&gt; 6 C} or {B &lt; A, B 6 C}
C 6 A → B {A 6 B} or {C 6 B}</p>
    </sec>
    <sec id="sec-5">
      <title>P attacks: O asserts as answer:</title>
      <p>{A 6 B, B 6 C} {A 6 C}
{A &lt; B, B / C} {A &lt; C}
{A / B, B &lt; C} {A &lt; C}
with / denoting either &lt; or 6 consistently through each line.
formula F is valid exactly P has such a winning strategy for the corresponding game starting
with P claiming F.</p>
      <p>Such a strategy can be modeled as a dialogue tree. This is a tree, where each node is
labeled either as an O-node (together with the set of assertions stated by O at that point
in the game) or as a P-node (together with the assertion attacked by P). The root node is
an exception to this scheme: It is labeled as a P-node together with the assertion claimed
by P to be true. On each path from the root to a leaf in this tree, O-nodes and P-nodes
alternate. Since by attacking a compound assertion, only assertions which are less complex
(i.e.: they have fewer connectives than the formula attacked) and since compound assertions
and elementary order claims can be attacked at most once, a dialogue tree is always finite.
Winning strategies for O
A winning strategy for O can be seen as such a dialogue tree where each P-node has exactly
one child, each O-node has a child P-node for each attack which P can issue at that point
in the game (or is a leaf node, if no attack is possible for P) and no leaf node is a winning
node for P.</p>
      <p>In [FP03] it is shown, that it is possible to extract counter-models from winning strategies
for O as well as to find winning strategies for O induced by counter-models. In particular, one
can show that the leaf nodes of a winning strategy for O represent a complete specification
of all counter models to the formula at the root node.
Winning strategies for P
Similarly, a winning strategy for P can be seen as such a dialogue tree where each O-node is
either a winning node for P or has exactly one child and each P-node as a child O-note for
each possible answer to P’s attack by O. For example, Figure 5.1 shows a winning strategy
for P for the truth comparison game starting with P claiming (A ∧ B) → (B ∧ A) to be
valid1. At each P-node (except the root) the side of the assertion which is being attacked is
underlined. Otherwise, an attack would be ambiguous, if both the left and the right hand
side of that assertion consisted of a compound formula2. In the course of this thesis a small
application, tcgame, has been implemented, which computes winning strategies for P (if
there are any) draws a graph showing the strategy. Figure 5.1 has, as an example, been
generated using tcgame. More about tcgame can be found in section 6.4.</p>
      <p>It is possible to construct a complete dialogue tree for a game, which is a dialogue tree in
which at every node for each possible move in the game at that point a corresponding child
node exists. It is possible as well to show that such a complete dialogue tree either contains
a winning strategy for O or for P as a subtree sharing the same root node.</p>
      <p>Moreover, in [FP03] a calculus based on relational hypersequents is presented, which is
sound and complete for G. The interesting point here is that there exists a one-to-one
correspondence between winning strategies for P and proofs in this calculus.
5.1 Extending G by Additional Operators
We can observe that in G there exists no formula F/, / ∈ {&lt;, 6} with occurrences of
propositional variables A and B such that for all interpretations:</p>
      <p>
vG(F/) = 1 if vG(A) / vG(B)</p>
      <p>0 otherwise
holds. This means that we cannot fully express the natural order on truth degrees within G
itself.</p>
      <p>In order to make G more powerful, we can define two unary connectives 4 and 5 which
1In [FP03] such a such a winning strategy is sketched for the formula (A → B) ∨ (B → A). Note that the
corresponding illustration actually does not show a winning strategy for P; the second O-node would be
required to have only one child node for that purpose.
2Note that in [FP03] this information is not explicitly included in the label attached to a P-node. In order
to know which side of the assertion has been attacked, one would need to take a look at the next O-node
and find out to which attack the answer fitted.
5.1. Extending G by Additional Operators</p>
      <p>P ((a ∧ b) → (b ∧ a))
O {((a ∧ b) → (b ∧ a)) &lt; ⊤}
P ((a ∧ b) → (b ∧ a)) &lt; ⊤</p>
      <p>O {(b ∧ a) &lt; (a ∧ b), (b ∧ a) &lt; ⊤}
{(b{(∧ba∧)a&lt;) &lt;⊤,⊤b,&lt;bb&lt;a&lt;,(ba(a&lt;∧∧bb)b}}) POO P (OOPb ∧{{aa(()&lt;bb&lt;∧∧(a(aaa))∧∧&lt;&lt;b)b⊤⊤),, aa&lt;&lt;(aa ∧,ab&lt;)}b}
Figure 5.1: Winning strategy for P for the game starting with (a ∧ b) → (b ∧ a)
67
accomplish exactly that:</p>
      <p>
v(4A) = 1 if v∗(A) = 1
0 otherwise
and</p>
      <p>
v(5A) = 1 if v∗(A) 6= 0
0 otherwise
(Note that the 5 connective could as well have been defined in G as 5A := ¬¬A, but for
4 this is not possible.)</p>
      <p>By adding the 4 connective to G, it is possible to find formulas F&lt; and F 6 as specified
above: The formula</p>
      <p>F6 := 4(A → B)
evaluates to 1 if A 6 B and to 0 otherwise, and the formula</p>
      <p>F&lt; := 4((B → A) → B) ∧ ¬(4A)
accomplishes the same for &lt;.</p>
      <p>The new connective 4 can be characterized using the truth comparison game presented
in this section by adding the following rules in table 5.2 to the game rules. This allows the
proponent to attack assertions involving the 4 connective. (As 5F is equivalent to ¬¬F for
any formula F, this connective can already be characterized by the game without introducing
new rules.)</p>
    </sec>
    <sec id="sec-6">
      <title>P attacks: O asserts as answer:</title>
      <p>4A &lt; C {A &lt; &gt;, ⊥ &lt; C}
C &lt; 4A {&gt; 6 A, C &lt; &gt;}
4A 6 C {A &lt; &gt;} or {⊥ &lt; C}
C 6 4A {&gt; 6 A} or {C 6 ⊥}
where / is either &lt; or 6.
“The game is up.”
William Shakespeare, “Cymbeline”
CHAPTER 6</p>
      <sec id="sec-6-1">
        <title>Implementation of Giles’s Game</title>
        <p>In the context of this thesis four utilities have been implemented. In the following these
applications as well as their usage are documented.</p>
        <p>The first application, Webgame, runs on any web browser capable of executing JavaScript
code. The other three applications are implemented in Haskell, a purely functional
programming language1. As a compiler, the Glasgow Haskell Compiler2 is used. For executing, a
standard Unix-like environment is required, however they also work under Microsoft
Windows using the Cygwin environment3.</p>
        <p>Binaries for Linux and Windows as well as the source code can be downloaded from
http://www.logic.at/people/roschger/thesis.
6.1</p>
        <p>Webgame
Webgame is a web-based application which allows to play Giles’s Game and its variants
for Product Logic and G¨odel Logic. After playing the game the evaluation of the final
game state is simulated. Therefore probability values are assigned to the experiments
1see http://haskell.org
2see http://www.haskell.org/ghc/
3see http://www.cygwin.com/
corresponding to all atomic propositions. Then arbitrarily many runs of the evaluation
can be performed and the average loss is displayed. Webgame can be played online at
http://www.logic.at/people/roschger/thesis/webgame/.</p>
        <p>The game is divided into five steps which are explained below. At any point in the game
it is possible to go back to a former step. In some situations it is necessary to cancel the
current game; in this case a warning is issued before stepping back. As an example the
current dialogue has to be abandoned if one wants to change the initial game state or the
logic determining the game rules. On the other hand, when evaluating a final game state
and one wants to change only the probability values assigned to atomic experiments this can
be done without replaying the complete dialogue (although the evaluation of the final game
state so far will be dismissed of course).</p>
        <p>The first step of the game consists of choosing one of Lukasiewicz Logic, Product Logic,
or G¨odel Logic as seen in Figure 6.1. This choice affects the game rules, the evaluation
scheme and in some cases how connectives are eliminated (see below). Additionally, there is a
checkbox, “Don’t use special characters in formulas”. By checking this, no special characters
will be used when displaying formulas. Instead, formulas will be displayed exactly as they
have been typed by the user. A user will choose this option if his web browser uses a font
which does not support the special characters used for various connectives and symbols.
by ((A → B) → B) as shown in Section 2.3.</p>
        <p>Next, in Step 3, the user has to give valuations for all atomic propositions (except ⊥ and
&gt;) which occur in the initial game state. These valuations give the success probability of an
experiment associated with the corresponding atomic proposition. These probability values
will be used when simulating the evaluation of an atomic game state in Step 5.</p>
        <p>In Step 4 the dialogue game itself is played finally. The tenets of both players are displayed.
Below the available moves for both players are listed (see screen shot 6.4(a)). If the mouse
pointer hovers over a button for doing a move, the corresponding formula is highlighted in
the tenet. If the move involves a min-conjunction or max-disjunction, the chosen formula
additionally is underlined.</p>
        <p>When Product Logic or G¨odel Logic have been selected in Step 1, implications are attacked
as described in Rules 1a and 1b. In this case there are only two possibilities for the following
move: the attacked player has to choose whether to challenge the attack or not. If an attack
is challenged and the flag ¶ is raised, this is indicated by the symbol ¶ on the right side of
the tenet.</p>
        <p>Using the “Undo last move” button it is always possible to go back in the game. This
also works multiple times, one can always get back as far as to the initial state. Using the
“Redo move” button the game can replayed after undoing one or more moves.</p>
        <p>Eventually, at some point in the game only atomic propositions are left in the players’
tenets. Then the button “Next Step: Evaluation” is activated as screen shot 6.4(b) shows.
Clicking it, we reach Step 5.</p>
        <p>In Step 5 the final game state reached in Step 4 is evaluated. For Lukasiewicz Logic the
risk values for both players are calculated and displayed; for Product Logic and G¨odel Logic
the expect gain is used instead. Additionally the evaluation using dispersive experiments
can be simulated: for each atomic proposition in the final game the outcome of the
associated experiment is determined using a random number generator. The probability of each
experiment to succeed is equal to the probability value given in Step 3.</p>
        <p>Using the buttons at the bottom the evaluation can be repeated several times. My average
gain or loss is displayed; one can see that it approaches the difference of the risk values
(respectively expected gain) calculated for both players. Screen shot 6.5 shows a repeated
evaluation of the final game state.</p>
        <p>When repeating the evaluation very often, this can easily slow down the application. The
reason is that, at some point, the table showing the outcomes gets too large. Thus, when
the checkbox “Do not display evaluations” is checked, the outcomes of the experiments are
not displayed in that table. Instead, only my average gain (respectively loss) is calculated
and displayed.
(a) Doing a Move
(b) Reaching a Final Game State
6.2 Giles
giles is a small program implemented in Haskell. Its main purpose is to visualize game
trees of Giles’s Game for Lukasiewicz Logic. The output of the Haskell program is a dot-file
to be further processed by the Graphviz-tools4. These tools help drawing graphs by trying to
layout them as planarly as possible and providing many output formats such as postscript,
png, or svg.</p>
        <p>giles is invoked at the command prompt. Provided with a formula A it will generate a
game tree for Giles’s Game starting in the game state [| A]. The edges of this game tree are
labeled with the corresponding moves.</p>
        <p>If there are several compound assertions present in a game state, giles will pick one of
these and branch according to the possible successor states. Thus, by taking into account
that the order in which assertions are being attacked does not matter (see Section 3.4), it is
possible to simplify the game tree considerably.</p>
        <p>The game tree is then automatically passed to dot, one of the Graphviz-tools. The
resulting postscript file is saved as game.ps.</p>
        <p>If invoked without argument, giles prints a usage message explaining the input syntax
and giving some example formulas. Table 6.2 shows the notation for formulas. Note that
there is no explicit symbol for negation; ¬A has to be typed as A -&gt; 0.</p>
        <p>Most of the game trees in this thesis have been generated using giles. For example,
Figure 3.6 has been generated by issuing giles "((a -&gt; b) -&gt; b) /\((b -&gt; a) -&gt; a)"
at the command prompt.
6.3. Hypseq
6.3 Hypseq
hypseq is small utility which finds and prints derivations of formulas in the hypersequent
calculus rH (see Section 2.6). If invoked with a formula A, hypseq searches for a derivation
with 6 A as the root hypersequent. hypseq is written in Haskell, its output is LATEX-code
using the bussproofs package5.</p>
        <p>For parsing the user input, i.e. the formula to start with, the same Haskell module is used
as for the giles utility above. Therefore, the input syntax is equal to the one described
in Table 6.2. After invoking hypseq the LATEX compiler is executed automatically and the
resulting document is converted to a postscript file. It is saved as proof.ps in the current
directory.</p>
        <p>Note that hypseq just provides derivations with atomic hypersequents as axioms. It is
not checked whether these hypersequents are valid as in Definition 7. If there exist multiple
derivations (this occurs when there are multiple rules which can be applied to one relational
hypersequent), internally a complete tree is constructed including all derivations. Before
generating the LATEX output, however, this tree is reduced such that only one derivation
chosen and printed. This final derivation is chosen such that it is the derivation with the
smallest depth, i.e. the shallowest derivation. If there are more than one derivations for
which this applies, one of them is picked.</p>
        <p>In Section 2.6 hypersequents are defined as a multiset set of sequents. hypseq instead
treats them as sets of sequents, which means that a sequents can occur at most once in
a hypersequent. This does not change the expressiveness of the calculus, but makes some
proofs more concise.</p>
        <p>For example, the derivation tree in Figure 2.4 is generated by hypseq by issuing the
command hypseq "a &amp; (a -&gt; b)" at the command prompt.
6.4 TCGame
tcgame was developed for finding and printing winning strategies for the proponent of a
Truth Comparison Game as defined in Chapter 5. Provided with a formula A it searches for
a winning strategy for the proponent of A. The existence of such a strategy can be seen as
a proof of A.</p>
        <p>The application is implemented in Haskell, like giles and hypseq. Since in G¨odel Logic
min-conjunction and strong conjunction coincide, the latter one can be omitted. Thus the
input syntax for formulas is exactly the same as for these two programs with the only
difference that there is no symbol for strong conjunction.</p>
        <p>The definition of winning strategies given in Chapter 5 refers to [FP03]. Such a
strategy consists of a tree with the starting formula at the root node. It is visualized using
latex and pst-tree, part of the PSTricks package6. The output is saved as a postscript
file tcgame.ps. For example, Figure 5.1 has been generated by issuing the command
tcgame "(a /\b) -&gt; (b /\a)".
Atom
Prop
Exper</p>
        <p>The set of all atomic propositions. Atomic propositions are usually denoted using lower
letters, e.g. a, b, c, . . ..</p>
        <p>The set of all propositions as defined in Definition 3, Prop ⊃ Atom. Compound
propositions are usually denoted using upper letters, e.g. A, B, C, . . ..</p>
        <p>The set of all yes/no experiments. The experiment associated with the atomic
proposition a is denoted as Ea (see Definition 9).
f : [0, 1]n → [0, 1]</p>
        <p>The truth function assigned to the n-ary connective .
v : Atom → [0, 1]</p>
        <p>The truth value assigned to an atomic proposition.
v∗ : Prop → [0, 1]</p>
        <p>The truth value assigned to an arbitrary proposition in the fuzzy logic based on the
t-norm ∗; see Definition 3.
π : Exper → [0, 1]</p>
        <p>The subjective probability assigned to an experiment; see definition 13.
A game state, where Γ denoting a multiset of formulas asserted by you and Δ denoting
a multiset of formulas asserted by me.
hΓ | Δi∗ for ∗ ∈ {L, G, Π}</p>
        <p>My risk value for the game state [Γ | Δ], i.e. the amount of money I expect to lose
assuming both players acting rationally. See Definition 14.
hAi∗ for ∗ ∈ {L, G, Π}</p>
        <p>The risk value of the game starting in [| A]. I.e. short for h| Ai∗
hΓ | Δi∗ for ∗ ∈ {L, G, Π}</p>
        <p>The extension of the evaluation function v∗ (see Definition 3) to arbitrary game states
as in Definitions 15 and 18.
[EG01]</p>
        <p>Arnon Avron. Hypersequents, logical consequence and intermediate logics for
concurrency. Annals of Mathematics and Artificial Intelligence, 4(3):225–248,
1991.</p>
        <p>Matthias Baaz and Christian G. Fermu¨ller. Analytic calculi for projective logics.
In TABLEAUX ’99: Proceedings of the International Conference on Automated
Reasoning with Analytic Tableaux and Related Methods, pages 36–50, London,
UK, 1999. Springer-Verlag.</p>
        <p>Agata Ciabattoni, Christian G. Fermu¨ller, and George Metcalfe. Uniform Rules
and Dialogue Games for fuzzy logics. In Franz Baader and Andrei Voronkov,
editors, LPAR, volume 3452 of Lecture Notes in Computer Science, pages 496–
510. Springer, 2004.</p>
        <p>M. Dummett. A propositional calculus with denumerable matrix. J. Symbolic
Logic, 24(2):97–106, 1959.</p>
        <p>F. Esteva and L. Godo. Monoidal t-norm based logic: towards a logic for
leftcontinuous t-norms. Fuzzy sets and systems, 124(3):271–288, 2001.
[EGHM03] F. Esteva, L. Godo, P. H´ajek, and F. Montagna. Hoops and Fuzzy Logic. Journal
of Logic and Computation, 13(4):532–555, 2003.</p>
        <p>Christian G. Fermu¨ller. Revisiting Giles - Connecting Bets, Dialogue Games, and
Fuzzy Logics. In Ondrej Majer, Ahti-Veikko Pietarinen, and Tero Tulenheimo,
[KMP00]
editors, Games: Unifying Logic, Language, and Philosophy, volume 15 of Logic,
Epistemology and the Unity of Science. Springer, 2009.</p>
        <p>C.G. Fermuller and R. Kosik. Combining Supervaluation and Degree Based
Reasoning Under Vagueness. Lecture Notes in Computer Science, 4246:212, 2006.
Christian G. Fermu¨ller and Norbert Preining. A Dialogue Game for Intuitionistic
Fuzzy Logic Based on Comparisons of Degrees of Truth. In Proceedings of
InTech‘03 (Fourth International Conference on Intelligent Technologies), Chiang
Mai, Thailand, December 2003.</p>
        <p>G. Gentzen. Investigations into logical deduction. The Collected Papers of
Gerhard Gentzen, pages 68–131, 1969.</p>
        <p>Robin Giles. A non-classical logic for physics. Studia Logica, 33(4):397–415,
1974.</p>
        <p>Robin Giles. Semantics for Fuzzy Reasoning. International Journal of
ManMachine Studies, 17:401–415, 1982.</p>
        <p>K. G¨odel. Zum intuitionisticschen Aussagenkalku¨l. Anzeiger Akademie der
Wissenschaften Wien, mathematisch-naturwiss. Klasse, 32:65–66, 1932.</p>
        <p>J.A. Goguen. The logic of inexact concepts. Synth´ese, 19(3):325–373, 1969.
Petr H´ajek. Why fuzzy logic. In Dale Jacquette, editor, A Companion to
Philosophical Logic, pages 595–605. Blackwell, Massachusetts, 2002.</p>
        <p>Petr H´ajek, Lluis Godo, and Francesc Esteva. Fuzzy logic and probability. In
Proceedings of the 11th Annual Conference on Uncertainty in Artificial
Intelligence (UAI-95), pages 237–244, San Francisco, CA, 1995. Morgan Kaufmann.
P. H´ajek, L. Godo, and F. Esteva. A complete many-valued logic with
productconjunction. Archive for Mathematical Logic, 35(3):191–208, 1996.</p>
        <p>E.P. Klement, Radko Mesiar, and Endre Pap. Triangular Norms, volume 8 of
Trends in Logic. Springer, 2000.</p>
        <p>P. Lorenzen. Logik und Agon. In Atti del Congresso Internazionale di Filosofia,
pages 187–194, Firenze, 1960. Sansoni.</p>
        <p>P. Lorenzen. Ein dialogisches Konstruktivit¨atskriterium. In Infinitistic Methods,
pages 193–200, Warszawa, 1961. PWN. Proceed. Symp. Foundations of Math.
J. Lukasiewicz. O logice trojwartosciowej. Ruch Filozoficzny, 5(169-171):32,
1920.</p>
        <p>George Metcalfe, Nicola Olivetti, and Dov Gabbay. Analytic Proof Calculi for
Product Logics. Archive for Mathematical Logic, 43(7):859–889, 2004.</p>
        <p>George Metcalfe, Nicola Olivetti, and Dov Gabbay. Sequent and hypersequent
calculi for abelian and Lukasiewicz logics. ACM Trans. Comput. Logic, 6(3):578–
613, 2005.</p>
        <p>II Robert J. Marks. Fuzzy Logic Technology and Applications I. IEEE Press,
Piscataway, NJ, USA, 1994.</p>
        <p>B. Scarpellini. Die Nichtaxiomatisierbarkeit des unendlichwertigen
Pra¨dikatenkalku¨ls von Lukasiewicz. Journal of Symbolic Logic, 27(2):159–
170, 1962.</p>
        <p>L.A. Zadeh. The role of fuzzy logic in modeling, identification and control. Fuzzy
Sets, Fuzzy Logic, and Fuzzy Systems: Selected Papers, 1996.
2.1 Lukasiewicz T-Norm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
2.2 G¨odel T-Norm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.3 Product T-Norm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.4 Sample proof for a&amp;(a → b) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
5.1 Winning strategy for P for the game starting with (a ∧ b) → (b ∧ a) . . . . . 67
6.1 Step 1: Choosing the Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
6.2 Step 2: Choosing an Initial Game State . . . . . . . . . . . . . . . . . . . . . . 71
6.3 Step 3: Probabilities for Atomic Experiments . . . . . . . . . . . . . . . . . . 72
6.4 Step 4: Playing the Game . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
6.5 Step 5: Evaluating the Final Game State . . . . . . . . . . . . . . . . . . . . . 74
2.1 T-Norms and Their Residua . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
5.1 Game Rules for the Truth Comparison Game . . . . . . . . . . . . . . . . . . 65
5.2 Game Rules for the Extended Truth Comparison Game . . . . . . . . . . . . . 68
analyticity, 14
avowed meaning, 17</p>
      </sec>
    </sec>
    <sec id="sec-7">
      <title>Cancellative Hoop Logic, 47</title>
      <p>CHL, see Cancellative Hoop Logic
completeness, 13
conditions of admissability, 16
conjunction
min conjunction, 8
strong conjunction, 8
dialogue game rules, 20
dialogue tree, 65
dispersion-free, 17
dispersive, 17
elementary contradiction, 64
elementary order claim, 64
equivalent formulas, 8
equivalent game states, 32
first order Lukasiewicz Logic, 37
flag, 47
frame rules, 20
fuzzy modus ponens, 7
game state, 22
game tree, 23
Giles, Robin, 16
hypersequent system, 12
implication</p>
      <p>G¨odel, 8
Goguen, 7
Lukasiewicz, 8</p>
      <p>Product, 8
interpretation, 8
Intuitionistic Logic, 10
invertible rules, 14
involutive negation, 10
logical identity, 25
Lorenzen, Paul, 18, 20
monoidal t-norm logic, 6
omniscient player, 39
ordinal sum, 6
parametric experiment, 38
principle of limited liability, 19, 20, 61
t-norm, 5</p>
      <p>G¨odel, 6
Lukasiewicz, 6</p>
      <p>Product, 6
tangible meaning, 17
tenet, 22
truth comparison game, 63
truth functionality, 4</p>
    </sec>
  </body>
  <back>
    <ref-list />
  </back>
</article>